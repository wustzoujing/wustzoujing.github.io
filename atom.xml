<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jessie_Zou’s Homepage</title>
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-02T04:43:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络学习笔记（二）</title>
    <link href="http://yoursite.com/2017/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/02/计算机网络学习笔记（二）/</id>
    <published>2017-05-02T00:36:05.000Z</published>
    <updated>2017-05-02T04:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-网络层（二）"><a href="#计算机网络-网络层（二）" class="headerlink" title="计算机网络-网络层（二）"></a>计算机网络-网络层（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;本节介绍最重要的几层，就是网络层（IP），运输层（TCP，UDP），应用层（HTTP，DNS，STMP等）。IP的分配，子网掩码，IP协议确保数据流主机到主机，而计算机通信代表的是计算上进程之间的通信，所以TCP，UDP提出端口概念，一个进程占用一个端口，这样就实现了准确的通信。TCP和UDP两者的不同是：TCP先建立连接且利用相关技术保证了可靠的传输，而UDP只是尽最大限度的进行传输，是面向非连接的，是不可靠的，两者在应用层都有相关利用。另外，ip+：+port就是套接字socket。所谓的socket通信中的socket是一个编程api，设计之初它的思想是不止用于TCP／IP协议，一般的用法是他制定源套接字和目的套接字，再指定使用的协议，这样就能实现通信，他能实现TCP／IP协议的通信，具体在下面结合图和实例阐述。</p>
  <a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>即虚电路服务和数据报服务。</p>
<p>&#160; &#160; &#160; &#160;虚电路：面向连接的，建立虚电路，以保证双方通信所需的一切资源，这是一条逻辑上的连接，不同于电话交换的物理连接，如果再使用可靠的网络传输协议，就可使所发送的分组无差错按步序到达终点。</p>
<p>&#160; &#160; &#160; &#160;数据报服务：无连接的通信方式，只提供尽最大能力交付的数据报服务。</p>
<p>&#160; &#160; &#160; &#160;这两种方式，在当时很有争议，焦点就是到底可靠的交付是在网络层还是运输层，有人觉得借助电信网成功经验，而互联网先驱却提出崭新的设计思路：<font color="red">交给上层即计算机来进行差错处理，充分利用了计算机的处理能力。</font>多年实践证明，当时决定在交给上层去实现可靠传输就是正确决定。由于在网络层要保证可靠的传输成本很大，而现在只需成本较低的路由器就行。将可靠的交付交给运输层来解决，即我们的TCP协议。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494293515&amp;di=f0143bb189d8a9c8cde2a47f038d8133&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fblog.chinaunix.net%2Fattachment%2F201402%2F14%2F26275986_1392346156Z19P.png" alt=""></p>
<h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>&#160; &#160; &#160; &#160;进行网络的互连可能借助以下设备：物理层-集线器；数据链路层-交换机；网络层-路由器；更高层-网关。而从网络层看使用集线器和交换机只是扩大了当前网络，并没有进行网络互连，从网络层来看它仍是一个网络。而网关比较复杂，所以一般采用<font color="red">路由器</font>进行网络互连。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">TCP／IP体系中在网络层采用了标准化协议，即使互连的网络是异构的，在网络层看了它好像是一个统一的网络，但是是逻辑互连，内部差异性仍然存在。</font></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>&#160; &#160; &#160; &#160;文档：RFC791；整个因特网是一个单一的，抽象的网络。IP地址就是给因特网上的每一个主机或路由器的每一个借口分配一个在全世界范围内唯一的32位标识符。IP地址表示为：{&lt;网络号&gt;,&lt;主机号&gt;}。分类如下图：</p>
<p>&#160; &#160; &#160; &#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494294197&amp;di=f001c8f32c69d084119f3968d732d922&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.bo56.com%2Fwp-content%2Fuploads%2F2014%2F11%2Fip_class.png" alt=""></p>
<h3 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h3><p>&#160; &#160; &#160; &#160;物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。它们分别在IP数据报和MAC帧的首部。如下图所示：</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493700242235&amp;di=3a2d74e813de29bb1f389b000b2f6e86&amp;imgtype=0&amp;src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F672098%2F201501%2F082256050466766.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;<font color="red">尽管互连在一起的网络硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层的这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或者路由器之间的通信。</font>关于这方面有重要的两个协议。ARP和RARP。</p>
<h3 id="ARP和RARP协议"><a href="#ARP和RARP协议" class="headerlink" title="ARP和RARP协议"></a>ARP和RARP协议</h3><p>&#160; &#160; &#160; &#160;地址解析协议ARP，和逆地址解析协议RARP。来实现IP地址和硬件地址的相互转换。<font color="red">现在RARP的功能在DHCP中已经完成，所以没人再单独使用了。</font></p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>&#160; &#160; &#160; &#160;ARP高速缓存，请求的时候广播，得到结果保存到缓存中，且定时更新，因为如果请求的主机网络适配器坏了，它的硬件地址也就坏了，改变了，定时更新防止这种情况。</p>
<p>详细细节参考这篇博文。<a href="http://www.cnblogs.com/luckyxiaoxuan/p/3395527.html" target="_blank" rel="external">ARP协议详解</a></p>
<h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p><img src="http://s1.sinaimg.cn/middle/4b503921475bd7925f320&amp;690" alt=""></p>
<p>（1） 版本（version）：包含IP地址的版本号，4个比特。</p>
<p>（2） 首部长度（header length）：表示IP数据报头长度，4个比特。</p>
<p>（3） 优先级与服务器类型（priority and type of service）:用于表示数据包的优先级和服务器类型，8个比特。</p>
<p>（4） 总长度（total length）：表示整个IP数据包的长度，16个比特（两个字节）。</p>
<p>（5） 标识符（identification）：用于表示IP数据包的标识符，16个比特。</p>
<p>（6） 标志（flags）：标志字段，3个比特。</p>
<p>（7） 段偏移量（fragment offset）：用于表示段的偏移量。</p>
<p>（8） TTL(time to time)：表示IP数据包的生命周期，8个比特。当TTL为0时，该数据包将被丢弃。TTL还对应一个数据报通过的路由器的数目。一个数据报每经过一个路由器，TTL值就会减一。</p>
<p>（9） 协议号：（protocol）：协议字段，8个比特，表示IP数据段封装的协议，是TCP还是UDP，TCP的协议号是6，UDP的协议号是17。</p>
<p>（10） 首部校验和（header chechsum）：用于表示校验和，16个比特。</p>
<p>（11） 源地址（SA，source ip address）：32比特位，表示数据包的源地址</p>
<p>（12） 目的地址（DA，destination ip address），32个比特位，表示数据报道目的地址。</p>
<p>（13） 可选项,内容其实很丰富，用来支持排错、测量以及安全等措施1-40个字节。</p>
<h3 id="子网划分、路由表、超网——解决怎么转发"><a href="#子网划分、路由表、超网——解决怎么转发" class="headerlink" title="子网划分、路由表、超网——解决怎么转发"></a>子网划分、路由表、超网——<strong>解决怎么转发</strong></h3><h4 id="原始做法："><a href="#原始做法：" class="headerlink" title="原始做法："></a>原始做法：</h4><p>&#160; &#160; &#160; &#160;<em>数据报在网络层怎么转发</em>：分组转发算法。数据报在IP层转发分组就是从一个路由器转发到下一个路由器，直到到达目的主机。路由器中有路由表保存下面两个信息：（目的网络地址，下一跳地址），也有默认路由，中间可能经过多次的间接交付。</p>
<p>&#160; &#160; &#160; &#160;<em>存在的问题</em>：因为，第一：IP地址空间的利用率有时很低；第二：路由表太大导致性能变坏；第三：两级IP地址不够灵活。</p>
<p>&#160; &#160; &#160; &#160;<em>策略</em>：<font color="red">划分子网，采用三级IP地址。</font>IP地址表示为{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}，子网在外看仍然表现成一个网络，内部确感觉划分了若干个子网。增加灵活性，减少主机数。子网掩码：和IP按位与运算得到网络地址。在路由表中加入<font color="red">子网掩码信息</font>。</p>
<p><img src="https://imgsa.baidu.com/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=cf7ed0480eb30f242197e451a9fcba26/cefc1e178a82b901fe67b81a728da9773812efd5.jpg" alt=""></p>
<h4 id="在划分子网情况下，路由器转发分组算法"><a href="#在划分子网情况下，路由器转发分组算法" class="headerlink" title="在划分子网情况下，路由器转发分组算法"></a>在划分子网情况下，路由器转发分组算法</h4><p>（1）从分组的首部提取目的IP地址D</p>
<p>（2）先用与该路由器直接相连的网络的子网掩码与D进行与运算，看结果是否与相应的网络 地址相匹配。若匹配，则进行直接交付。否则就是间接交付，马上执行3</p>
<p>（3）若路由表中有一条到目的主机D的特定路由，则将分组转发给其指明的下一跳路由器。否则执行4</p>
<p>（4）对路由表中每一行的子网掩码和D进行与运算，若结果与该行的目的网络地址匹配，则将分组传给该行指明的下一跳路由器。否则执行5</p>
<p>（5）若路由表中有一个默认路由，则将分组传给路由表中指明的默认路由器。否则执行6</p>
<p>（6）报告转发分组出错。</p>
<h4 id="CIDR-无分类编址（构造超网）"><a href="#CIDR-无分类编址（构造超网）" class="headerlink" title="CIDR 无分类编址（构造超网）"></a>CIDR 无分类编址（构造超网）</h4><p>出现问题：IP地址都快分完了。</p>
<p>解决办法：CIDR，特点：消除传统的A、B、C类地址以及划分子网的概念，回到二级地址，网络前缀+主机号，还可采用斜线法，斜线数字代表前缀中1的个数。</p>
<h4 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h4><p>&#160; &#160; &#160; &#160;两者比较可参考这个博文：<a href="http://tech.hexun.com/2015-01-10/172249335.html" target="_blank" rel="external">ipv4和ipv6之间区别比较</a>，但是当前主流的仍然是v4，为什么，这个我看了下知乎上的答案：<a href="http://tech.hexun.com/2015-01-10/172249335.html" target="_blank" rel="external">IPv6的概念都出来好久了，为什么现在的主流还是IPv4？</a>,感觉主要是已经大范围的使用，如果要更新，很多软硬件需要换代，这样成本太高。。。</p>
<h3 id="ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠"><a href="#ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠" class="headerlink" title="ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠"></a>ICMP网际控制报文协议——<strong>解决怎么尽最大限度的保证可靠</strong></h3><p>&#160; &#160; &#160; &#160;为了更有效的转发IP数据和提高交付机会，使用ICMP，IP层协议。它的应用有常用<font color="red">ping</font>。<br>详细细节参考博文：<a href="http://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" target="_blank" rel="external">ping原理和ICMP协议</a>，<a href="http://network.chinabyte.com/23/13155523.shtml" target="_blank" rel="external">ICMP协议基础讲解</a>。</p>
<h3 id="因特网路由选择协议——解决路由选择"><a href="#因特网路由选择协议——解决路由选择" class="headerlink" title="因特网路由选择协议——解决路由选择"></a>因特网路由选择协议——<strong>解决路由选择</strong></h3><p>&#160; &#160; &#160; &#160;目前的因特网中，一个大的ISP（信息服务提供者）就是一个AS（自治系统），分两类内部网关协议IGP和外部网关协议EGP，自治系统之间的路由也叫做域间路由选择，内部叫做域内路由选择。</p>
<h4 id="内部网关协议RIP和OSPF"><a href="#内部网关协议RIP和OSPF" class="headerlink" title="内部网关协议RIP和OSPF"></a>内部网关协议RIP和OSPF</h4><p>&#160; &#160; &#160; &#160;两者的内容和比较可以参考博文：<a href="http://www.2cto.com/net/201210/161420.html" target="_blank" rel="external">RIP和OSPF的区别比较</a>。</p>
<h4 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h4><p>BGP是不同自治系统的路由器之间交换路由信息的协议。只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要找到一条最佳。</p>
<p><a href="http://blog.csdn.net/cogbee/article/details/35228467" target="_blank" rel="external">动态路由选择三个协议之间比较</a></p>
<h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>&#160; &#160; &#160; &#160;在因特网上进行多播，比如90个主机接收视频节目，并不能去一个个去发送，应该是发送一次，收听的人都收到。能运行多播协议的路由器叫多播路由器。</p>
<h4 id="多播所用到的协议"><a href="#多播所用到的协议" class="headerlink" title="多播所用到的协议"></a>多播所用到的协议</h4><p>&#160; &#160; &#160; &#160;IP多播需要两种协议：网际组管协议IGMP和多播路由选择协议（尚未标准化）</p>
<h3 id="VPN和NAT"><a href="#VPN和NAT" class="headerlink" title="VPN和NAT"></a>VPN和NAT</h3><p>&#160; &#160; &#160; &#160;有的时候有些机构的很多部分分布在相距较远的地点。不同地点有自己的专用网，如果这些专用网要进行通信的话那么就有两种方式。一种是租用电信公司的线路，但是这样费用较高；另外一种就是建立VPN。</p>
<p><img src="http://up.2cto.com/2013/0805/20130805084039266.jpeg" alt=""></p>
<p>&#160; &#160; &#160; &#160;显然，每个场所至少要有一个路由器具有合法的全球IP地址，如图中R1、R2。这两个路由器和因特网的接口地址必须是合法的全球地址，在专用网内部的接口地址则是专用网的本地地址。如果场所A中的主机需要和场所B中的主机进行通信的话，那么就需要经过R1、R2。</p>
<p>&#160; &#160; &#160; &#160;现在有一个问题就是，在专用网内部的主机有一个专用地址，但是又想和因特网上的主机通信，那么该怎么办？</p>
<p>&#160; &#160; &#160; &#160;网络地址转换NAT(Network Address Translation)，就用来解决这个问题。这种方法首先需要在专用网连接到因特网的路由器上安装NAT软件。就是当专用网的主机和外部网进行通信的时候，数据包经过NAT路由器的时，NAT路由器将专用网地址转换为一个全球地址，然后并记录下这个转换对。当收到发往某全球地址的数据包时候，再将此数据包转发到内部网中得某主机（与该地址对应的内部主机）。如下图：<br><img src="http://up.2cto.com/2013/0805/20130805084048370.jpeg" alt=""></p>
<p>&#160; &#160; &#160; &#160;如果NAT路由器有N个全球地址的话，那么就可以支持专用网内部N台主机同时与因特网进行通信。这样就可以使得专用网内较多的主机轮流使用这N个全球地址。注意：因为地址转换的关系，所以通过NAT路由器的通信必须由专用网内的主机发起。理解???因为一开始不知道如何转换。所以专用网内部的主机是不可以作为服务器的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-网络层（二）&quot;&gt;&lt;a href=&quot;#计算机网络-网络层（二）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-网络层（二）&quot;&gt;&lt;/a&gt;计算机网络-网络层（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本节介绍最重要的几层，就是网络层（IP），运输层（TCP，UDP），应用层（HTTP，DNS，STMP等）。IP的分配，子网掩码，IP协议确保数据流主机到主机，而计算机通信代表的是计算上进程之间的通信，所以TCP，UDP提出端口概念，一个进程占用一个端口，这样就实现了准确的通信。TCP和UDP两者的不同是：TCP先建立连接且利用相关技术保证了可靠的传输，而UDP只是尽最大限度的进行传输，是面向非连接的，是不可靠的，两者在应用层都有相关利用。另外，ip+：+port就是套接字socket。所谓的socket通信中的socket是一个编程api，设计之初它的思想是不止用于TCP／IP协议，一般的用法是他制定源套接字和目的套接字，再指定使用的协议，这样就能实现通信，他能实现TCP／IP协议的通信，具体在下面结合图和实例阐述。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（一）</title>
    <link href="http://yoursite.com/2017/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/01/计算机网络学习笔记（一）/</id>
    <published>2017-05-01T01:05:46.000Z</published>
    <updated>2017-05-02T04:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-概述（一）"><a href="#计算机网络-概述（一）" class="headerlink" title="计算机网络-概述（一）"></a>计算机网络-概述（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;非计算机专业，有过计算机网络的课程，但是理解的很浅显，最近面试感觉这方面确实要加强，因为主要的学习方向是Java Web，但是却连计算机网络的知识都不扎实，确实也说不过去，希望能系统的学习一下，查阅了网上的资料，下载了相关视频，书籍和ppt，学的是《计算机网络》谢希仁版的教材，下面记录学习中的重点部分和理解。</p>
  <a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="传统网络的意义"><a href="#传统网络的意义" class="headerlink" title="传统网络的意义"></a>传统网络的意义</h3><p>&#160; &#160; &#160; &#160;网络通常指的是最主要的三种网络，分别是电信网络、有线电视网络、计算机网络（核心）。想象一下以前家里电信网络可以链接互联网，通过调制解调器，然后现在家里电视机可以联网，机顶盒插网线。相互之间都可以通信。</p>
<h3 id="电路交换、报文交换、分组交换的比较"><a href="#电路交换、报文交换、分组交换的比较" class="headerlink" title="电路交换、报文交换、分组交换的比较"></a>电路交换、报文交换、分组交换的比较</h3><p>&#160; &#160; &#160; &#160;<br>1、电路交换<br>公共电话网(PSTN网)和移动网(包括GSM和CDMA网)采用的都是电路交换技术，它的基本特点是采用面向连接的方式，在双方进行通信之前，需要为通信双方分配一条具有固定宽带的通信电路，通信双方在通信过程中一直占用所分配的资源，直到通信结束，并且在电路的建立和释放过程中都需要利用相关的信令协议。这种方式的优点是在通信过程中可以保证为用户提供足够的带宽，并且实时性强，时延小，交换设备成本低，但同时带来的缺点是信道利用率低，一旦电路被建立不管通信双方是否处于通话状态分配的电路一直被占用。比如我们拨号的时候，对方应答则建立连接，双方进入占线状态。</p>
<p>&#160; &#160; &#160; &#160;2、报文交换<br>    报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式；由于报文长度差异很大，长报文可能导致很大的时延；为了满足各种长度报文的需要并且达到高效的目的，节点需要分配不同大小的缓冲区，否则就有可能造成数据传送的失败，这样对每个节点来说缓冲区的分配也比较困难。另外一个缺点是出错时，整个报文都将重传。这种方式已经淘汰，但是对于后面应运而生的分组交换是一种启发。</p>
<p>&#160; &#160; &#160; &#160;3、分组交换<br>    分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的地址和编号信息）逐个地发送出去。采用分组交换技术，在通信之前不需要建立连接，每个节点首先将前一节点送来的分组收下并保存在缓冲区中，然后根据分组头部中的地址信息选择适当的链路将其发送至下一个节点，这样在通信过程中可以根据用户的要求和网络的能力来动态分配带宽。分组交换比电路交换的信道利用率高，但时延较大。分组转发的带来的问题：排队时延以及增加头部带来的开销。 </p>
<p>&#160; &#160; &#160; &#160;总之，若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493698933186&amp;di=3be4210907fd965f5f49758fc5c76763&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D566293858%2C4184530263%26fm%3D214%26gp%3D0.jpg" alt=""></p>
<h3 id="OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构"><a href="#OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构" class="headerlink" title="OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构"></a>OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构</h3><p>&#160; &#160; &#160; &#160;在这里首先大概介绍每层的功能，后面章节对具体每层进行分析其中相关功能和技术，如下图所示：<br><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg" alt=""></p>
<p>####物理层（Physical Layer）</p>
<p>&#160; &#160; &#160; &#160;通过传输介质发送和接收二进制比特流。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。传输介质有双绞线，同轴电缆，光缆，微波接力。采用的技术有信道复用。物理层记住两个重要的设备名称，<font color="red">中继器</font>（Repeater，也叫放大器）和<font color="red">集线器</font>。他们都用于连接物理特性相同的网段，集线器所起的作用相当于多端口的中继器，中继器一般两个端口，而集线器很多。</p>
<p>####数据链路层（Data Link Layer）</p>
<p>&#160; &#160; &#160; &#160;数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<font color="red">有关数据链路层的三个基本问题：<br><br>&#160; &#160; &#160; &#160;1.封装成帧，在一段数据的前后分别添加首部和尾部；<br><br>&#160; &#160; &#160; &#160;2.透明传输，设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符，在这两个字符之前插入一个转义字符“ESC”;<br><br>&#160; &#160; &#160; &#160;3.错检测：循环冗余检验CRC，接受到的都是正确的，错误的都没接受所以并没有保障可靠的传输。</font>


<p>&#160; &#160; &#160; &#160;主要的协议：点对点PPP协议，对点到点信道；以太网协议，CSMA／DA协议：载波监听多点接入/冲突检测，针对广播信道，将许多计算机连接到一根总线上，局域网中的MAC地址，48位；FDDI光纤分布式数据接口。</p>
<p>&#160; &#160; &#160; &#160;两个重要设备名称：网桥和交换机。太网交换机实质上就是一个多接口的网桥。用于连接同一逻辑网络中、物理层规范不同的网段，这些网段的拓扑结构和其上的数据帧格式，都可以不同，它们具有物理地址，但没有逻辑地址。</p>
<p>####网络层（Network Layer）</p>
<p>　　网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p>
<p>　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p>
<p>　　1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</p>
<p>　　2&gt; 基本数据单位为IP数据报；</p>
<p>　　3&gt; 包含的主要协议：</p>
<p>　　<font color="red">IP协议（Internet Protocol，因特网互联协议）;</font></p>
<p>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</p>
<p>　　ARP协议（Address Resolution Protocol，地址解析协议）;</p>
<p>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</p>
<p>　　4&gt; 重要的设备：路由器</p>
<h4 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h4><p>&#160; &#160; &#160; &#160;第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>&#160; &#160; &#160; &#160;传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。<br>&#160; &#160; &#160; &#160;网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<p><font color="red">有关网络层的重点：</font></p>
<p>&#160; &#160; &#160; &#160;1.传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</p>
<p>&#160; &#160; &#160; &#160;2.包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</p>
<p>&#160; &#160; &#160; &#160;3.重要设备：网关。</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>　　为操作系统或网络应用程序提供访问网络服务的接口。</p>
<p>　　会话层、表示层和应用层重点：</p>
<p>　　1&gt; 数据传输基本单位为报文；</p>
<p>　　<font color="red">2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</font>
　　</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&#160; &#160; &#160; &#160;如下图，各层分布如下，我们在下一节中重点了解网络层ip、运输层tcp，udp和应用层的相关知识。<br>　　<br><img src="https://uploadfiles.nowcoder.com/images/20160825/537870_1472105349302_FEE2F1DA56B2D9B0ED608E700E39130D" alt=""></p>
<p>本文参考连接:<a href="http://www.cnblogs.com/maybe2030/p/4781555.html" target="_blank" rel="external">计算机网络知识总结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-概述（一）&quot;&gt;&lt;a href=&quot;#计算机网络-概述（一）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-概述（一）&quot;&gt;&lt;/a&gt;计算机网络-概述（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;非计算机专业，有过计算机网络的课程，但是理解的很浅显，最近面试感觉这方面确实要加强，因为主要的学习方向是Java Web，但是却连计算机网络的知识都不扎实，确实也说不过去，希望能系统的学习一下，查阅了网上的资料，下载了相关视频，书籍和ppt，学的是《计算机网络》谢希仁版的教材，下面记录学习中的重点部分和理解。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>算法基础篇：排序（二）</title>
    <link href="http://yoursite.com/2017/04/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/30/算法基础篇：排序（二）/</id>
    <published>2017-04-30T02:07:42.000Z</published>
    <updated>2017-05-01T07:16:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改进排序算法及其Java实现"><a href="#改进排序算法及其Java实现" class="headerlink" title="改进排序算法及其Java实现"></a>改进排序算法及其Java实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上节讲了经典的三个排序算法，这节将对改进的排序算法进行分析，有快速排序和归并排序。对于排序和数据结构，推荐一个很棒的网站，支持能动态的看排序过程，可以单步，调节快慢：<font color="red"><a href="http://zh.visualgo.net" target="_blank" rel="external"><strong>学习利器</strong></a></font></p>
  <a id="more"></a>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&#160; &#160; &#160;&#160; 快速排序（Quicksort）是对<em>冒泡排序</em>的一种改进。</p>
<p>&#160; &#160; &#160;&#160; 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序对海量数据来说，相对其他排序方式是较快的， 他的时间复杂度比经典排序小且常系数也比较小才称为快速排序。以数组{49,38,65,97,76,13,27,49}为例，选择第一个元素49为基准,初始化关键字： [49,38,65,97,76,13,27,49]</p>
<p>&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="http://img.blog.csdn.net/20160426213936501" alt=""></p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 首先随机选择数列中的一个数（可用随机数产生，但也可以就选第一个数），然后进行一个partition函数，他的思想是扫描一遍数列把大于这个基数的数都放在右边，小于这个基数的数都放在左边。最后利用分治的思想，对基数的右边和左边分别在进行这个partition操作，最后数列就有序了。我这里为了代码尽量简洁，写出以下代码。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>//快速排序，s代表数列，l是数列第一项索引，r是数列最后一项的索引
public static void quicksort(int[] s,int l,int r){
//用i，j接住首位和末位，后面分别代表小于区间和🐠等于区间。x代表基数，这里用首位代表基数，没有随机产生
    int i=l,j=r,x=s[l];
    //执行操作条件
    if(l&lt;r){
        //循环结束条件
        while(i&lt;j){
            //从右至左找小于基数的数
            while(i&lt;j&amp;&amp;s[j]&gt;=x)
                j--;//如果大于等于基数j--，因为它们顺序正确
             //找到之后放在左边，此处精妙的使用i++
            if(i&lt;j)
                s[i++]=s[j];
            //从左至右找大于等于基数的数
            while(i&lt;j&amp;&amp;s[i]&lt;x)
                i++;
            //放在
            if(i&lt;j)
                s[j--]=s[i];
        }
        //最后把基数放在i位置上，完成了partition操作
        s[i]=x;
        //对数列左边和右边分别递归
        quicksort(s,l,i-1);
        quicksort(s,i+1,r);
    }
}
</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 基本原理如下：对于给定的一组记录，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。 经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，直到进行比较的记录只剩下一个为止。</p>
<p>&#160; &#160; &#160;&#160;以数组{50,10,90,30,70,40,80,60,20}为例，排序过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20160427172905073" alt=""></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>public static void merge(int[] a, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;// 左指针
    int j = mid + 1;// 右指针
    int k = 0;
    // 把较小的数先移到新数组中
    while (i &lt;= mid &amp;&amp; j &lt;= high) {
        if (a[i] &lt; a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i &lt;= mid) {
        temp[k++] = a[i++];
    }
    // 把右边边剩余的数移入数组
    while (j &lt;= high) {
        temp[k++] = a[j++];
    }
    // 把新数组中的数覆盖nums数组
    for (int k2 = 0; k2 &lt; temp.length; k2++) {
        a[k2 + low] = temp[k2];
    }
}

public static void mergeSort(int[] a, int low, int high) {
    int mid = (low + high) / 2;
    if (low &lt; high) {
        // 左边
        mergeSort(a, low, mid);
        // 右边
        mergeSort(a, mid + 1, high);
        // 左右归并
        merge(a, low, mid, high);
        System.out.println(Arrays.toString(a));
    }

}
</code></pre><p> &#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493531505656&amp;di=3fcca775d3be2b21bad6ac93d3a7ade9&amp;imgtype=0&amp;src=http%3A%2F%2Fimgs.aixifan.com%2Fcontent%2F2016_09_10%2F1473520477.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改进排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#改进排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;改进排序算法及其Java实现&quot;&gt;&lt;/a&gt;改进排序算法及其Java实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上节讲了经典的三个排序算法，这节将对改进的排序算法进行分析，有快速排序和归并排序。对于排序和数据结构，推荐一个很棒的网站，支持能动态的看排序过程，可以单步，调节快慢：&lt;font color=red&gt;&lt;a href=&quot;http://zh.visualgo.net&quot;&gt;&lt;strong&gt;学习利器&lt;/strong&gt;&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础篇：排序（一）</title>
    <link href="http://yoursite.com/2017/04/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/27/算法基础篇：排序（一）/</id>
    <published>2017-04-27T04:19:38.000Z</published>
    <updated>2017-05-01T07:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法及其Java实现"><a href="#基础排序算法及其Java实现" class="headerlink" title="基础排序算法及其Java实现"></a>基础排序算法及其Java实现</h1><p>##前言</p>
<p>&#160; &#160; &#160; &#160;看完了牛客网上的买的算法课程，准备首先从基础的<font color="red"><strong>数据结构</strong></font>和<font color="red"><strong>算法</strong></font>开始写。  </p>
<p>  &#160; &#160; &#160; &#160;本篇先从基础的排序开始，需要要掌握的有<em>冒泡排序</em>，<em>选择排序</em>和 <em>插入排序</em>。</p>
  <a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>  1.<em>第一次循环</em>：从0到n-2（即0&lt;=i&lt;n-1-0），每个位置上的数拿本身和后一位相比，如果比后一位大就交换两个位置的值。</p>
<p>  2.<em>第二次循环</em>：从0到n-3即（即0&lt;=i&lt;n-1-1），操作同第一次循环一样。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：0位置上的数（即0&lt;=i&lt;n-1-(n-2)），操作同第一次循环。</p>
<p>  &#160; &#160; &#160; &#160;说明：为了实现本身和后一位相比直到最后，要用内层循环实现，范围区间已在上面给出，外层共有n-1次循环，我们可以写出代码如下。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>public static int[] BubbleSort(int[] A, int n) {

    // 给变量赋初识值
    int temp,i = 0,j = 0;
    //外层循环计数如上面算法思想的减数部分
    for(;i &lt; n-1;++i){
    //内层循环来实现相邻两个比较
        for(;j&lt;n-i-1;++j){
        //前一个比后一个大，冒泡到最后
        //说明：逆序排列的话条件相反
            if(A [j] &gt; A [j+1]){
                temp = A[j];
                A[j] = A[j+1];
                A[j+1] = temp;
            }
        }
    }
    return A;
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从0到n-1（即1&lt;=i&lt;n），选出区间最小值放到位置0上。</p>
<p>  2.<em>第二次循环</em>：从1到n-1（即2&lt;=i&lt;n），选出最小值放到位置1上。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从n-2到n-1（即n-2&lt;=i&lt;n），选出最小值放在位置n-2上。</p>
<p>  &#160; &#160; &#160; &#160;说明：内层循环选取区间内的最小值，循环区间上面已给出，利用附加空间的int k来存储最小值的索引，最后和对应位置值交换，外层循环循环n-1次。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] selectSort(int[] data){
//初始化变量，需要额外的k存最小智的索引
    int i, j, k, tmp = 0;
    //外层循环，0-n-2，循环n-2次
    for (i = 0; i &lt; data.length - 1; i++) {
        //记录下区间第一个值
        k = i;
        //内层循环从区间第二个值开始比较
        for (j = i + 1; j &lt; data.length; j++)
        //更新最小值索引
            if (data[j] &lt; data[k])
                k = j;
        //如果最小值索引不是当前位置，交换他们的值
        if (k != i) {
            tmp = data[i];
            data[i] = data[k];
            data[k] = tmp;
        }
    }
    return data;
}
</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从位置1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——1区间一定有序。</p>
<p>  2.<em>第二次循环</em>：从位置2上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——2区间一定有序。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从位置n-1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——n-1区间即整个数列就有序了。</p>
<p>  &#160; &#160; &#160; &#160;说明：外层循环循环n-1次。从1到n-1，即1&lt;=i&lt;n。内层循环首先取当前索引的前一位索引，与当前索引位置的值比较，如果当前索引位置较小就交换当前索引和前一位的值，并从它的前一位开始继续向前比较。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] insertionSort(int[] A, int n) {
    // 外层循环从1——n-1，共n-1次。
    for(int i=1;i&lt;n;++i){
        //j从当前索引i前一位开始，每次比较后j递减更新当前索引位置
        for(int j=i-1;j&gt;=0;--j){
            //比较前一位和当前索引位置，如果当前位置小则交换
            if(A[j]&gt;A[j+1]){
                int temp=A[j];
                A[j]=A[j+1];
                A[j+1]=temp;
            }
            //如果当前位置大，停止内层循环
            else
                break;
        }

    }
    return A;
}
</code></pre><p>明天讲其他几种，最后试着插入一个动图！！！</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://ww2.sinaimg.cn/bmiddle/88070423gw1ep30aw8an7g204d04gkgd.gif" alt="亦菲表演机器猫"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#基础排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法及其Java实现&quot;&gt;&lt;/a&gt;基础排序算法及其Java实现&lt;/h1&gt;&lt;p&gt;##前言&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看完了牛客网上的买的算法课程，准备首先从基础的&lt;font color=red&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/font&gt;和&lt;font color=red&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/font&gt;开始写。  &lt;/p&gt;
&lt;p&gt;  &amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇先从基础的排序开始，需要要掌握的有&lt;em&gt;冒泡排序&lt;/em&gt;，&lt;em&gt;选择排序&lt;/em&gt;和 &lt;em&gt;插入排序&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://yoursite.com/2017/04/27/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/04/27/hexo搭建个人博客/</id>
    <published>2017-04-27T02:14:11.000Z</published>
    <updated>2017-04-27T04:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-nodejs-markdown搭建hexo"><a href="#git-nodejs-markdown搭建hexo" class="headerlink" title="git+nodejs+markdown搭建hexo"></a>git+nodejs+markdown搭建hexo</h1><h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。<br><a id="more"></a></p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p>
<p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">创始人 John Gruber 的 Markdown 语法说明</a></p>
<p><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 中文版语法说明</a></p>
<h3 id="Mac下的编辑器Mou和MacDown"><a href="#Mac下的编辑器Mou和MacDown" class="headerlink" title="Mac下的编辑器Mou和MacDown"></a>Mac下的编辑器Mou和MacDown</h3><p>代码高亮</p>
<p>Mou 和 MacDown 都支持 fenced code blocks（前后三个反引号可以表示代码块），但 MacDown 支持加语言标识符实现代码高亮，这对程序员来说简直是福音啊，非常棒的功能。</p>
<p>MacDown 支持代码高亮<br>MacDown 支持代码高亮<br>GFM Task List 支持</p>
<p>MacDown 支持 Task list，有了这个功能，你可以将你的 MD 编辑器立马变成 TODO list，是不是很赞？</p>
<p>MacDown 对 Task list 的支持<br>MacDown 对 Task list 的支持<br>Jekyll Front-matter 支持</p>
<p>很多人使用 Jekyll 作为博客引擎，这时 Jekyll 的前面那段该怎么去渲染呢？MacDown 和 github 一样可以支持。</p>
<p>MacDown 对 Jekyll front-matter 的支持<br>MacDown 对 Jekyll front-matter 的支持</p>
<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><p><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">参考链接</a></p>
<h2 id="nodejs-git-并安装hexo"><a href="#nodejs-git-并安装hexo" class="headerlink" title="nodejs+git 并安装hexo"></a>nodejs+git 并安装hexo</h2><h3 id="这个教程很多，下面给个链接"><a href="#这个教程很多，下面给个链接" class="headerlink" title="这个教程很多，下面给个链接"></a>这个教程很多，下面给个链接</h3><p><a href="http://www.jianshu.com/p/ecd51e8ef2fa" target="_blank" rel="external">参考链接</a></p>
<h2 id="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"><a href="#next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。" class="headerlink" title="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"></a>next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git-nodejs-markdown搭建hexo&quot;&gt;&lt;a href=&quot;#git-nodejs-markdown搭建hexo&quot; class=&quot;headerlink&quot; title=&quot;git+nodejs+markdown搭建hexo&quot;&gt;&lt;/a&gt;git+nodejs+markdown搭建hexo&lt;/h1&gt;&lt;h2 id=&quot;markdown语法&quot;&gt;&lt;a href=&quot;#markdown语法&quot; class=&quot;headerlink&quot; title=&quot;markdown语法&quot;&gt;&lt;/a&gt;markdown语法&lt;/h2&gt;&lt;p&gt;Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。&lt;br&gt;
    
    </summary>
    
      <category term="hexo相关" scheme="http://yoursite.com/categories/hexo%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
