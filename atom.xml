<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jessie_Zou’s Homepage</title>
  <subtitle>我的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-06T11:12:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/05/06/%E5%89%91%E6%8C%87offer%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/05/06/剑指offer：用两个栈实现队列/</id>
    <published>2017-05-06T10:19:11.000Z</published>
    <updated>2017-05-06T11:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。</p>
  <a id="more"></a>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道栈是先进后出，而队列是先进先出。两个栈是可以实现先进后出的，我们模拟进队列操作时，进队列都进入第一个栈，然后出队列操作时，先把栈1全部倒入栈2，栈2出栈完成出队列操作，为了保证顺序，栈2中元素还要在倒入栈1。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    //定义两个栈</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    //进队都往第一个栈进。</div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    //出队列函数</div><div class="line">    public int pop() &#123;</div><div class="line">        //如果栈1不为空，把栈1值导入栈2，完成逆序</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        //栈2栈顶出队列</div><div class="line">        int first=stack2.pop();</div><div class="line">        //这里是重点：栈2的值都要倒回栈1，因为如果不倒回，出队列操作之后，栈2还有元素，但是之</div><div class="line">        //后进队列的元素又倒回栈2，这样就乱序了，倒回保证每次栈2中先进的都在下面，整体倒入栈2</div><div class="line">        //后肯定保证是先进的元素在栈顶</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        //</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：重建二叉树</title>
    <link href="http://yoursite.com/2017/05/05/%E5%89%91%E6%8C%87offer%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/05/05/剑指offer：重建二叉树/</id>
    <published>2017-05-05T09:16:00.000Z</published>
    <updated>2017-05-06T10:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。</p>
  <a id="more"></a>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道在二叉树的前序遍历中，第一个总是根值。中序遍历中，根节点的值在序列的中间。左子树的根节点位于根节点的左边，右子树的结点在根节点的右边，因此我们需要扫描中序遍历才能找到根节点的值。找到根结点之后，中序遍历分成两部分，分别是左右子树的中序遍历，而我们在前序遍历中根据左右子树的个数就能确定左右子树的前序遍历，因此我们就能递归的完成。具体步骤如下：</p>
<ol>
<li>先进行输入序列的检查。</li>
<li>把中序序列放入一个hashmap，值为key，索引为value，这样很方便的通过前序序列中的值得到在中序遍历中的索引，很巧妙，而且时间复杂度较低。</li>
<li>利用递归完成树重建，为了代码的简洁性，写了preIn函数完成功能。具体输入参数和意义如下注释部分。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</div><div class="line">    //为空则返回空，输入检查，还可检查两者长度是否相等。</div><div class="line">    if(pre==null||in==null)&#123;</div><div class="line">          return null;</div><div class="line">    &#125;   </div><div class="line">    java.util.HashMap&lt;Integer,Integer&gt; map=new java.util.HashMap&lt;Integer,Integer&gt;();</div><div class="line">    //中序遍历进map</div><div class="line">    for(int i=0;i&lt;in.length;i++)&#123;</div><div class="line">       map.put(in[i],i); </div><div class="line">    &#125;</div><div class="line">    //交给重建函数</div><div class="line">    return preIn(pre,0,pre.length-1,in,0,in.length-1,map);</div><div class="line">&#125;</div><div class="line">//p，n，map属于不变的，这样写代码简洁一点，变得是前序遍历和中序遍历在原序列中的起止索引。</div><div class="line">public TreeNode preIn(int[] p,int pi,int pj,int[] n,int ni,int nj,java.util.HashMap&lt;Integer,Integer&gt; map)&#123;</div><div class="line">    //前序遍历开始位置大于结束位置，返回空。</div><div class="line">    if(pi&gt;pj)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    //前序遍历开始位置就是根节点。</div><div class="line">    TreeNode head =new TreeNode(p[pi]);</div><div class="line">    //获得根节点在中序序列中的索引位置</div><div class="line">    int index=map.get(p[pi]);</div><div class="line">    //递归左子树，前序遍历pi自增1就行，结束位置算法是（pi+1）+（index-1-ni），因为</div><div class="line">    //index-1为中序遍历结束位置减去ni开始位置就是中序遍历的个数，在加上pi+1就是前序遍历</div><div class="line">    //结束为止</div><div class="line">    head.left=preIn(p,pi+1,pi+index-ni,n,ni,index-1,map);</div><div class="line">    //右子树的前序开始位置为左子树结束位置自增1，结束位置是pj，中序遍历开始是根节点位置自</div><div class="line">    //增1，结束位置是nj</div><div class="line">    head.right=preIn(p,pi+index-ni+1,pj,n,index+1,nj,map);</div><div class="line">    //重建完成返回</div><div class="line">    return head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/05/04/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/05/04/剑指offer：从尾到头打印链表/</id>
    <published>2017-05-04T12:41:39.000Z</published>
    <updated>2017-05-06T12:14:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;补充说明：使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。在Java中我们用自定义类来表示链表，本题就给出了链表默认类。—-源自<em>百度百科</em>，觉得讲的很清楚。</p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;从头到尾输出链表比较简单，因为是题目要求是打印且是从尾到头，打印一般不允许我们改原链表结构的，所以反向链表在从头打印不行的，我们有两个思路：</p>
<ol>
<li>考虑用递归来实现，链表最后一个节点的next节点为空，这也是我们递归结束条件。如果链表当前节点的next不为空，我们递归先打印它的next节点，但是递归都怕栈溢出。</li>
</ol>
<ol>
<li>考虑到这个类似先进后出，可用数据结构栈来实现这种顺序,但是没有递归简洁，而且先要遍历一遍存入栈，然后在出栈。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> import java.util.ArrayList;</div><div class="line"> public class Solution &#123;</div><div class="line"> </div><div class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        //递归结束条件  </div><div class="line">        if(listNode!=null)&#123;</div><div class="line">            //递归打印它的next数组</div><div class="line">            this.printListFromTailToHead(listNode.next);</div><div class="line">            arrayList.add(listNode.val);</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">        Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;();</div><div class="line">        //链表依次进栈</div><div class="line">        while(listNode!=null)&#123;</div><div class="line">            s.push(listNode.val);</div><div class="line">            listNode=listNode.next;</div><div class="line">        &#125;</div><div class="line">        //依次出栈到输出动态数组完成逆序打印</div><div class="line">        while(!s.empty())&#123;</div><div class="line">            arrayList.add(s.pop());</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：替换空格</title>
    <link href="http://yoursite.com/2017/05/03/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2017/05/03/剑指offer：替换空格/</id>
    <published>2017-05-03T07:23:15.000Z</published>
    <updated>2017-05-06T10:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
  <a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;C／C++中每个字符串都已字符’\0’作为结尾，这样我吗就能很方便的找到字符串的末位，但是这个特点导致字符串都有一个额外的开销。而在Java和C#中，String是不可变的，一旦试图改变，将产生一个新的实例。所以要活用StringBuilder和StringBuffer。可参考这个博文：<a href="http://blog.csdn.net/qh_java/article/details/46382265" target="_blank" rel="external">从源码角度分析Java三种字符串</a>。</p>
<p>&#160; &#160; &#160; &#160;用Java实现本题，输入的是一个StringBuffer，我们可以先定义一个返回字符串StringBuffer类型，遍历一遍字符串，使用charAt（int i）方法，如果当前字符没空字符，则使用append（char c）添加给定字符，如果不是则添加该字符。最后把StringBuffer变成String返回。使用toStirng（）方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>public String replaceSpace(StringBuffer str) {
    StringBuilder newstr =new StringBuilder();
    for(int i=0;i&lt;str.length();i++){
        if(str.charAt(i)==&apos; &apos; )
            newstr.append(&quot;%&quot;).append(&quot;2&quot;).append(&quot;0&quot;);
        else
           newstr.append(str.charAt(i));
    }
           return newstr.toString();
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：二维数组中的查找</title>
    <link href="http://yoursite.com/2017/05/02/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/05/02/剑指offer：二维数组中的查找/</id>
    <published>2017-05-02T08:28:06.000Z</published>
    <updated>2017-05-06T10:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。</p>
  <a id="more"></a>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;遍历数组能解决问题，但是由于所给数组已经部分排序，我们可以利用这个排序规则进行不必要的比较剔除，进行优化。试想如果起点是左下角，同目标值比较，如果大于目标值，整行我们就不用比较了，如果小于目标值，本行之前也都不用比较了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#160; &#160; &#160; &#160;以右上角为起点，代码如下：</p>
<pre><code>public boolean Find(int target, int [][] a) {
    // 右上角初始值，第一行最后一列。
    int j=a[0].length-1;
    int i=0;
    //循环条件
    while((j&gt;=0)&amp;&amp;i&lt;a.length){
        //大于目标值，该行之后肯定都大于目标值，只会在该行，减少列数查找
        if(a[i][j]&gt;target)
            --j;
        //小于目标指，则该行全小于目标值，往下一行查找
        else if(a[i][j]&lt;target)
            ++i;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><p>   &#160; &#160; &#160; &#160;以左下角为起点，代码如下： </p>
<pre><code>    public boolean Find(int target, int [][] a) {
    //左下角初始值，最后一行，第一列
    int i=a.length-1;
    int j=0;
    //循环条件
    while((i&gt;=0)&amp;&amp;j&lt;a[0].length){
        //大于目标值则该行都大于目标值，往上一行查找。
        if(a[i][j]&gt;target)
            --i;
        //小于目标值，则该行之前都小于目标值，结果只会在该行，再增加列数查找
        else if(a[i][j]&lt;target)
            ++j;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（一）</title>
    <link href="http://yoursite.com/2017/02/28/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/高效并发（一）/</id>
    <published>2017-02-28T05:20:54.000Z</published>
    <updated>2017-05-09T07:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型与线程（一）"><a href="#Java内存模型与线程（一）" class="headerlink" title="Java内存模型与线程（一）"></a>Java内存模型与线程（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。</p>
 <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;多任务处理在现代操作系统中几乎已是一项必备的功能了，许多情况下，让计算机同时去做几件事，只是处理器的运算能力太强大了，与通讯子系统差距太大，大部分时间花了在磁盘i／o，网络通讯和数据库访问。后来在主内存和处理器之间加入了高速缓冲区cache，java的内存模型也是参考那样的方式设计的如下图：</p>
<p><img src="http://img.my.csdn.net/uploads/201302/06/1360141335_1299.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;线程间通信的步骤：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>&#160; &#160; &#160; &#160;八种操作来完成：来完成一个变量从主内存拷贝到工作内存、以及工作内存同步回主内存之内。</p>
<ol>
<li>Lock（锁定）：作用于主内存的变量，将主内存该变量标记成当前线程私有的，其他线程无法访问。</li>
<li>Unlock（解锁）：作用于主内存的变量，解除主内存中该变量的锁定状态，让他变成线程共享变量。</li>
<li>Read（读取）：作用于主内存的变量，将该变量读取到当前线程的工作内存中，以便进行load操作。</li>
<li>Load（加载）：作用于工作内存中的变量，将read获取到的变量载入工作内存的变量副本中。</li>
<li>Use（使用）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了一个变量就会执行该操作，使用该变量。</li>
<li>Assgin（赋值）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了变量赋值的指令就会执行该操作。</li>
<li>Store（存储）：作用于工作内存中的变量，将工作内存中的变量放入主内存，以便进行write操作。</li>
<li>Write（写入）：作用于主内存中的变量，将store得到的变量放入主内存的变量中。</li>
</ol>
<p>&#160; &#160; &#160; &#160;说明：如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序的执行store和write操作。这两个操作必须按顺序执行，但是没有保证是连续执行，也就是说read与load之间、store与write之间是可插入其他指令的。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，就是对一个变量执行use和store之前必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，僵尸清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>&#160; &#160; &#160; &#160;它有两个语义：</p>
<ol>
<li>保证该变量对所以线程的可见性，但不是总能保证线程安全性，因为java的操作并非原子操作。</li>
<li>禁止指令重排序。指令重排序会干扰并发程序的执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;我们如何选择：volatile的效率是高于锁的，只是在写操作上因为防止重排序插入了内存屏障指令高于普通变量。我们重点放到只使用volatile是否就能满足我们的业务需求，而且对double和long类型变量我们一般不会用到，可能会读到半个变量。</p>
<p>&#160; &#160; &#160; &#160;Java内存模型中对volatile变量定义的特殊规则：</p>
<ol>
<li>在工作内存中，每次使用volatile变量前都必须从主内存中刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值。</li>
<li>在工作内存中，每次修改后的值都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量的修改。</li>
<li>volatile修饰的变量不会被指令重排优化，保证代码的执行顺序与程序的顺序相同。</li>
</ol>
<h2 id="内存模型的特点"><a href="#内存模型的特点" class="headerlink" title="内存模型的特点"></a>内存模型的特点</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&#160; &#160; &#160; &#160;由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们可以大致的认为基本数据类型的访问读写是具备原子性的（long和double除外）。Java代码中的同步块即synchronized关键字，因此在synchronized块之间的操作也具备原子性。内部是通过字节码指令monitorenter和monitorexit来实现。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>&#160; &#160; &#160; &#160;就是当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。关键字synchronized和final也能保证可见性。首先同步块是因为对变量执行unlock操作之前，必须先把次变量同步回主内存中。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this指针传递出去，那么在其他线程中就能看见final字段的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>&#160; &#160; &#160; &#160;用synchronized和volatile关键字来保证线程操作之间的有序性。volatile本省就包含禁止指令重排序的语义，而synchronized则是因为：一个变量在同一时刻只允许一条线程对齐进行lock操作。这个规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>&#160; &#160; &#160; &#160;如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦。java内存模型中的一个重点原则——先行发生原则（Happens-Before），使用这个原则作为依据，来指导你判断是否存在线程安全和竞争问题。</p>
<ol>
<li>程序顺序规则：在程序中，如果A操作在B操作之前（比如A代码在B代码上面，或者由A程序调用B程序），那么在这个线程中，A操作将在B操作之前执行。</li>
<li>管理锁定规则：一个unlock操作先于后面对同一个锁的lock操作之前执行。<br>volatile变量规则：对一个volatile变量的写操作必须在对该变量的读操作之前发生。</li>
<li>线程启动规则：线程的Thread.start()必须在该线程所有其他操作之前发生。</li>
<li>线程终止规则：线程中所有操作都先行发生于该线程的终止检测。可以通过Thread.join()方法结束、Thread.isAlive()的返回值判断线程是否终止。</li>
<li>线程中断规则：对线程interrupt()方法的调用必须在被中断线程的代码检测到interrupt调用之前执行。</li>
<li>对象终结规则：对象的初始化（构造函数的调用）必须在该对象的finalize()方法完成。<br>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生于C。</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>&#160; &#160; &#160; &#160;主要有三种方式：使用内核线程KLT、用户线程UT、使用用户和轻量级进程LWP混合。操作系统支持怎么样的线程模型，很大程度决定了java采用何种线程实现方式，对于java程序的编码和运行来说是差异是透明的。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>&#160; &#160; &#160; &#160;分为协同式和抢占式两种。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>&#160; &#160; &#160; &#160;分为以下几种：新建、运行、无限期等待、限期等待、阻塞、结束</p>
<p><img src="http://img.blog.csdn.net/20160717080817309" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型与线程（一）&quot;&gt;&lt;a href=&quot;#Java内存模型与线程（一）&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型与线程（一）&quot;&gt;&lt;/a&gt;Java内存模型与线程（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（四）</title>
    <link href="http://yoursite.com/2017/02/25/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/25/Java虚拟机（四）/</id>
    <published>2017-02-25T02:16:03.000Z</published>
    <updated>2017-05-09T05:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之类加载机制（四）"><a href="#JVM之类加载机制（四）" class="headerlink" title="JVM之类加载机制（四）"></a>JVM之类加载机制（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。<font color="red">而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？</font>。这是我们接下来要学习的内容。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;虚拟机把描述类的数据从calss文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<font color="red">与那些在编译期需要进行连接的工作语言不同，在Java语言里，类加载荷连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为程序提供高度的灵活性</font>，动态扩展的特性也就是依赖运行期间动态加载和动态连接这个特点实现的。如面向接口的编程。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>&#160; &#160; &#160; &#160;类从加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期共包含七个阶段，如下图：</p>
<p>&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20140105211344671" alt=""></p>
<p>&#160; &#160; &#160; &#160;其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="初始化规范"><a href="#初始化规范" class="headerlink" title="初始化规范"></a>初始化规范</h3><p>&#160; &#160; &#160; &#160;虚拟机规范中堆什么情况需要开始类加载的第一个阶段，加载并没有强制约束，但是对初始化阶段，规范了有且只有4种情况必须立即对类进行初始化。</p>
<ol>
<li>遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时（比如在使用new创建对象的时候，读取或设置一个类静态字段、调用一个类的静态方法）</li>
<li>使用java.lang.relect包的方法对类进行反射调用的时候，如果类没有进行初始化，首先出发初始化。</li>
<li>当初始化一个类，发现父类还没有进行初始化，先出发父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的哪个类），虚拟机会先初始化这个主类。</li>
</ol>
<p>&#160; &#160; &#160; &#160;以上四种是对类的主动引用，下面说几种被动引用：</p>
<ol>
<li>通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li>
<li>一个类的成员进入常量池，另一个类引用只是对常量池的引用，两个class就无关了。</li>
<li>接口加载和类加载稍微有点不同，只有真正使用到父接口的时候才会初始化。</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>&#160; &#160; &#160; &#160;接下来讲解一下类加载的全过程，也就是加载、验证、准备、解析和初始化这五个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法去访问数据的访问入口。</li>
</ol>
<p>&#160; &#160; &#160; &#160;正是因为没有指明具体的从哪获取，怎么获取，所以充满活力的开发前辈玩出了很多花样：</p>
<ol>
<li>从zip包中读取，最后成为jar，EAR，WAR格式的基础。</li>
<li>从网络中获取，比如Applet</li>
<li>从计算机运行生成，比如动态代理</li>
<li>其他文件，比如JSP</li>
<li>从数据库读取，有些中间件服务器可以把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ol>
<p>&#160; &#160; &#160; &#160;相对其他过程，加载是开发期可控性最强的阶段。可以使用系统的加载器，也可以自定义类加载器。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>文件格式验证；比如魔数、主次版本号；常量池是否含有不支持的常量类型；等等。。。经过验证才会进入内存的方法区进行存储。所以下面的几个验证阶段全部都是基于方法区的存储结构进行的。</li>
</ol>
<ol>
<li>元数据验证；验证点比如：这个类是否有父类，父亲是否成常量不允许基础的类，如果这个类不是抽象类，是否实现了父类或接口之中要求实现的索引方法，类中的字段、方法是否和父类产生了矛盾等。这一阶段主要进行语义检验，保证不存在不符合Java语言规范的元数据信息。</li>
</ol>
<ol>
<li><p>字节码检验；是最复杂的的一个阶段，主要工作是进行数据流和控制流分析。在第二个阶段堆数据类型做完校验之后，这阶段对类的方法体进行校验分析。比如：保证任何时刻操作数类型和指令码序列都能配合工作、保证跳转指令不会跳转到方法体以外的字节码指令、保证类型转换时有效的。如果通过不一定安全，不通过一定不安全。</p>
</li>
<li><p>符号引用；对类自身以外的信息进行匹配性校验。比如：全限定名能否找到该类，指定类中是否存在符合方法的字段描述符。</p>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>&#160; &#160; &#160; &#160;此阶段时正式为类变量（ 不包括实例变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配，</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>&#160; &#160; &#160; &#160;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法四类符号引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&#160; &#160; &#160; &#160;对类的静态变量，静态代码块执行初始化操作。</p>
<p>参考这边博文：<a href="http://www.cnblogs.com/ITtangtang/p/3978102.html" target="_blank" rel="external">类加载机制及反射</a>。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>&#160; &#160; &#160; &#160;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，实现这个动作的代码块称为类加载器。它在Java Applet、类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p>
<p>&#160; &#160; &#160; &#160;对任意一个类都需要由加载它的类加载器和这个类本身一同确定它在虚拟机中的唯一性。对虚拟机里来说只有两种不同的类加载器，一种是启动类加载器由C++实现，另一种就是Java写的，都继承java.lang.ClassLoader。对于开发人员来说它还进一步分为扩展类的和应用程序类的加载器。分别加载／lib/etc目录下的，和calsspath用户路径下的。</p>
<p><img src="http://img.my.csdn.net/uploads/201009/25/0_1285421756PHyZ.gif" alt=""></p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>&#160; &#160; &#160; &#160;工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。在classload的loadclass（）方法中实现。</p>
<p>&#160; &#160; &#160; &#160;好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之类加载机制（四）&quot;&gt;&lt;a href=&quot;#JVM之类加载机制（四）&quot; class=&quot;headerlink&quot; title=&quot;JVM之类加载机制（四）&quot;&gt;&lt;/a&gt;JVM之类加载机制（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;font color=red&gt;而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？&lt;/font&gt;。这是我们接下来要学习的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（三）</title>
    <link href="http://yoursite.com/2017/02/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/22/Java虚拟机（三）/</id>
    <published>2017-02-22T00:36:37.000Z</published>
    <updated>2017-05-09T02:07:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之Class文件结构（三）"><a href="#JVM之Class文件结构（三）" class="headerlink" title="JVM之Class文件结构（三）"></a>JVM之Class文件结构（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，<font color="red">越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式</font>。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。</p>
<a id="more"></a>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>&#160; &#160; &#160; &#160;Class文件是一组以8位字节为基础的二进制，各个数据项目严格按照顺序紧凑的排列Class文件之间，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。</p>
<p>&#160; &#160; &#160; &#160;虚拟机规范：Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中还有两种数据结构：无符号和表，后面的解析都要以这两种数据类型为基础。</p>
<p>&#160; &#160; &#160; &#160;无符号数属于基本的数据类型，用u1,u2,u4,u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，可以用来描述数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。</p>
<p>&#160; &#160; &#160; &#160;表是由多个无符号数或其他数据项构成的复合结构数据，整个class文件本质上就是一张表。</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>&#160; &#160; &#160; &#160;每个class文件的头四个字节被称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多图片格式在文件头都有魔数。Java中为：0XCAFFBABE；</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>&#160; &#160; &#160; &#160;紧接着4个字节存储的是Class文件的版本号：5-6是次版本，7-8是主版本。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>&#160; &#160; &#160; &#160;主次版本号之后是常量池的入口，也是与其他项目关联最多的数据类型，也是占用class文件空间最大的项目之一，同时还是第一个出现的表类型。主要存放字面量和引用。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>&#160; &#160; &#160; &#160;在常量池之后，紧接2个字节代表访问标志，包括是接口还是类，是否public，abstract，final等等。</p>
<h3 id="类索引、父亲索引与接口索引集合"><a href="#类索引、父亲索引与接口索引集合" class="headerlink" title="类索引、父亲索引与接口索引集合"></a>类索引、父亲索引与接口索引集合</h3><p>&#160; &#160; &#160; &#160;类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合。类确定了这个类的全限定名，父亲索引确定这个父类的全限定名。不允许多继承，所以父类索引直邮一个。除了object都有父类。接口索引表示这个类实现了哪些接口。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>&#160; &#160; &#160; &#160;字段表用于描述接口或类中声明的变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>&#160; &#160; &#160; &#160;访问标志、名称索引、描述符索引都表达清楚了，方法里面的代码经过编译器编译成字节码指令之后，存放在方法属性表集合中一个名为code的属性里面，属性表作为class文件格式最具扩展性的一种数据项目。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>&#160; &#160; &#160; &#160;class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<h2 id="class文件结构的发展"><a href="#class文件结构的发展" class="headerlink" title="class文件结构的发展"></a>class文件结构的发展</h2><p>&#160; &#160; &#160; &#160;上面这些属性大部分都用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;class文件是Java虚拟机执行引擎的数据入口，也是技术体系的基础支柱之一。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之Class文件结构（三）&quot;&gt;&lt;a href=&quot;#JVM之Class文件结构（三）&quot; class=&quot;headerlink&quot; title=&quot;JVM之Class文件结构（三）&quot;&gt;&lt;/a&gt;JVM之Class文件结构（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，&lt;font color=red&gt;越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式&lt;/font&gt;。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Class文件结构" scheme="http://yoursite.com/tags/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（二）</title>
    <link href="http://yoursite.com/2017/02/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/20/Java虚拟机（二）/</id>
    <published>2017-02-20T10:01:02.000Z</published>
    <updated>2017-05-08T14:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之垃圾回收机制（二）"><a href="#JVM之垃圾回收机制（二）" class="headerlink" title="JVM之垃圾回收机制（二）"></a>JVM之垃圾回收机制（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，<font color="red">我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。</font></p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说起GC，我们需要做下面三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>何时回收？</li>
<li>如何回收？</li>
</ol>
<p>&#160; &#160; &#160; &#160;现在内存的动态分配、垃圾回收技术已经相当的成熟，那我们为什么还要去学习内存分配和GC呢？答案：<font color="red">当需要排查各种OOM问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我就需要对自动化的技术实施必要的监控和调节。</font></p>
<h2 id="怎么判断对象已死？"><a href="#怎么判断对象已死？" class="headerlink" title="怎么判断对象已死？"></a>怎么判断对象已死？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>&#160; &#160; &#160; &#160;给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1；失效就减1；任何时刻为0的对象就是不可能再被使用的。</p>
<p>&#160; &#160; &#160; &#160;确定：不能解决循环引用的问题。</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>&#160; &#160; &#160; &#160;Java和C#所采用的方式，基本原理：通过一系列名为GC Roots的对象为起点，从这些根节点向下搜索，走过的路径叫引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。</p>
<p>&#160; &#160; &#160; &#160;Java语言中可作为GC Roots的对象包括：虚拟机栈中（本地变量表）引用的对象、方法区中的类静态属性引用的对象、方法区中的常量引用对象、本地方法栈中JNI，native方法引用的对象。</p>
<h2 id="引用的几个类型"><a href="#引用的几个类型" class="headerlink" title="引用的几个类型"></a>引用的几个类型</h2><p>&#160; &#160; &#160; &#160;无论是哪种方式，判断存活都与引用有关。引用概念在JDK1.2之后进行了扩充，包括四种：</p>
<ol>
<li>强引用；只要引用存在，垃圾回收器永远不会回收。</li>
<li>软引用；系统将要发生内存溢出之前，会把这些对象列进回收范围并进行第二次回收。如果还不够菜抛出异常。</li>
<li>弱引用；只能存活到下一次垃圾回收发生之前。</li>
<li>虚引用；一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过虚引用来获得实例，完全只是为了希望在对这个回收时收到一个系统通知。</li>
</ol>
<h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><p>&#160; &#160; &#160; &#160;根搜索算法不可达的对象也并不是一定被回收，这时候它处于缓刑阶段。至少要经历两次标记过程。如果发现没有引用链，那么标记一次并且进行一次筛选，条件是对象是否有必要执行finalize（），当对象没有覆盖finalize方法，或者已经被虚拟机调用过，都是为没有必要执行。</p>
<p>&#160; &#160; &#160; &#160;如果判断为有必要执行，就会放置在一个F-Queue队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalize线程区执行。但是并不承诺等待它运行结束，原因是：如果一个对象的finalize方法执行缓慢或者死循环了，其他对象将出现永久等待。</p>
<p>&#160; &#160; &#160; &#160;finalize（）是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次标记，如果对象在finalize中拯救自己—只要重新与引用链上的任何一个对象相连即可。只能自救一次，因为finalize最多使用一次。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>&#160; &#160; &#160; &#160;主要回收内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象类似。</p>
<p>&#160; &#160; &#160; &#160;判断无用的类得满足下面三个条件：</p>
<ol>
<li>加载该类的加载器已被回收</li>
<li>所有类的实例已经被回收</li>
<li>该类的java.lang.Class对象没有任何地方引用，无法反射得到。</li>
</ol>
<p>满足了也不一定回收，常用的参数如下：</p>
<ol>
<li>-verbose：class</li>
<li>-xx：+TraceClassLoading</li>
<li>-XX：+TraceClassUnLoding</li>
</ol>
<p>&#160; &#160; &#160; &#160;在大量使用反射、动态代理、CGLib等bytecode框架的时候，以及JSP、OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>&#160; &#160; &#160; &#160;首先标记出所有需要回收的对象，在标记完之后统一回收。</p>
<p>&#160; &#160; &#160; &#160;缺点：效率低，产生的碎片多。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>&#160; &#160; &#160; &#160;他将可用的内存划分为等大小的两块，每次只使用其中一块，当用完了，把存活的对象都复制到另一半上，然后把第一块的一次性清理。</p>
<p>缺点：内存利用率低</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>&#160; &#160; &#160; &#160;让所有存活的对象都向一端移动，然后直接清楚掉端边界以外的内存。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>&#160; &#160; &#160; &#160;当前商业虚拟机都常用分代收集算法，更具对象的存活周期的不同将内存划分为几块，一般是新生代和老年代，这样就可以根据各个年代的特点采用最适当的<strong>收集算法</strong>。在新生代中，每次都有大批对象死去，只有少量的存活，那就选用复制算法。（复制的内容比较少，复制少量存活对象成本），而老年代中因为对象存活率高，就必须使用标记-清理或者标记-整理。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>&#160; &#160; &#160; &#160;包含的收集器如下：<br><img src="http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg" alt=""></p>
<h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><p>&#160; &#160; &#160; &#160;单线程收集器，垃圾收集时，必须暂停所有工作线程。“Stop The World”。</p>
<p>优势：简单而高效，没有线程切换，在客户端模式是个很好选择。</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>&#160; &#160; &#160; &#160;是Serial的多线程版本（在新生代垃圾回收的时候采用多GC线程），是服务器模式下首选的新生代收集器，目前只有它能与CMS收集器配合工作。但是作为老年代的收集器，却无法和Parallel Scavenge配合工作。</p>
<p>&#160; &#160; &#160; &#160;它在单核环境中绝对不会比serial效果好，多核也不能百分之百比serial好。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-10.png" alt=""></p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>&#160; &#160; &#160; &#160;是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器，特别之处是它注重达到一个可控制的吞吐量，可通过设置参数来完成。</p>
<h3 id="serial-Old"><a href="#serial-Old" class="headerlink" title="serial Old"></a>serial Old</h3><p>&#160; &#160; &#160; &#160;是serial的老年代版本，采用的是标记-整理算法。主要意义是客户端模式下使用。如果使用在服务器模式下，主要有两个用途：搭配Parallel Scavenge使用，或者作为CMS收集器的后备预案。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-9.jpg" alt=""></p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>&#160; &#160; &#160; &#160;之前新生代 Parallel Scavenge很尴尬，因为只能喝serial old组，被单线程所拖累。知道Parallel Old出现，吞吐量优先收集器终于有了比较名副其实的应用组合。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-11.jpg" alt=""></p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>&#160; &#160; &#160; &#160;是一种以获取最短回收停顿时间为目标的收集器。目前很多一部分的Java应用都集中在服务器上，尤其注重响应速度，希望系统停顿的时间越短越好。CMS就非常符合这个要求。</p>
<p>&#160; &#160; &#160; &#160;基于标记-清除的，但是改进了分以下四步：</p>
<ol>
<li>初识标记；仍需要暂停其他线程，仅仅是标记一下GC Roots能直接关联的对象，速度很快。</li>
<li>并发标记；进行GC Roots Tracing过程</li>
<li>重新标记；仍需要暂停其他线程，修正并发标记期间，因用户程序继续运行而导致的一部分改变，会比👨‍🍳标记消耗时间长一些，比并发标记时间短。</li>
<li>并发清除；消耗时间也较长。</li>
</ol>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-12.jpg" alt=""></p>
<h4 id="CMS-优缺点"><a href="#CMS-优缺点" class="headerlink" title="CMS 优缺点"></a>CMS 优缺点</h4><p>&#160; &#160; &#160; &#160;CMS的优点很明显：并发收集、低停顿（由于进行垃圾收集的时间主要耗在并发标记与并发清除这两个过程，虽然初始标记和重新标记仍然需要暂停用户线程，但是从总体上看，这部分占用的时间相比其他两个步骤很小，所以可以认为是低停顿的）。</p>
<p>&#160; &#160; &#160; &#160;尽管如此，CMS收集器的缺点也是很明显的：</p>
<p>&#160; &#160; &#160; &#160;1.对CPU资源太敏感，这点可以这么理解，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分CPU资源，导致程序的响应速度变慢。（增量式并发收集器i-CMS）</p>
<p>&#160; &#160; &#160; &#160;2.CMS收集器无法处理浮动垃圾。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”。（调高-XX：CMSInitiatingOccupancyFraction参数，太高又会造成CMF失败，后备预案就是采用Serial收集器对老年代进行，反而效率会降低）。</p>
<p>&#160; &#160; &#160; &#160;3.由于CMS收集器是基于“标记-清除”算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存,那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次Full GC（这个后面还会提到）这个问题的解决是通过控制参数-XX:+UseCMSCompactAtFullCollection，用于在CMS垃圾收集器顶不住要进行FullGC的时候开启空间碎片的合并整理过程。相应停顿也不得不变长。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>&#160; &#160; &#160; &#160;G1时当前收集器技术中最前沿的成果。相比之前的CMS收集器又两个改进：</p>
<ol>
<li>基于标记-整理算法实现，也就是说不会产生碎片。</li>
<li>精确的控制停顿，在M毫秒哪，收集时间不超过N毫秒，这几乎已经时实时java（RTSJ）的垃圾收集器特征了。</li>
</ol>
<p>&#160; &#160; &#160; &#160;将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域厘米的垃圾堆积程度，后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域，这就是Garbage First的由来。保证有效时间内获得更高的收集效率。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>&#160; &#160; &#160; &#160;Java技术体系中所提倡的自动内存管理最终归结为自动化解决了两个问题：给内存分配对象以及回收分配给对象的内存。接下来再来说说内存分配，往大方向讲，就是在堆上分配。<br>根据设置参数和收集器的使用组合不同，内存分配机制可能不同，但是我们讲述一般性规则，分析之前先看看两种GC：</p>
<ol>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，比较频繁，回收速度也快。</li>
<li>老年代GC （Full GC／Major GC）：发生在老年代的GC，经常伴随着至少一次Minor GC，但不是绝对，速度较慢，。</li>
</ol>
<h3 id="对象优先在Eden中分配"><a href="#对象优先在Eden中分配" class="headerlink" title="对象优先在Eden中分配"></a>对象优先在Eden中分配</h3><p>&#160; &#160; &#160; &#160;大多数情况下，对象优先在新生代Eden区中分配。当Eden没有足够空间的时候，会发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>&#160; &#160; &#160; &#160;需要大量连续空间的Java对象，很长的字符串及数组等，所以程序中不要写短命大对象。（不进入Eden和Survivor时因为他们采用复制算法）。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>&#160; &#160; &#160; &#160;虚拟机给每一个对象一个年龄计数器，默认15岁。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>&#160; &#160; &#160; &#160;如果Survivor空间中相同年龄所以对象总和大于空间的一半，年龄大于等于该年龄的进入老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>&#160; &#160; &#160; &#160;发生 Minor GC时，虚拟机会检测晋升到老年代的空间是否够，如果不够就发起一次Full GC，如果小于，如果参数HannlePromotionFailure设置允许担保失败，就只会进行Minor GC；</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本次介绍了垃圾收集算法和多种收集器，以及自动内存分配的一些机制。内存回收与垃圾收集在很多时候都是影响系统性能、并发俄力的主要因素之一，虚拟机提供了多种不同收集器与大量调节参数。必须要了解每个具体收集器行为、优点缺点。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之垃圾回收机制（二）&quot;&gt;&lt;a href=&quot;#JVM之垃圾回收机制（二）&quot; class=&quot;headerlink&quot; title=&quot;JVM之垃圾回收机制（二）&quot;&gt;&lt;/a&gt;JVM之垃圾回收机制（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，&lt;font color=red&gt;我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器与内存分配策略" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>OOM异常实战</title>
    <link href="http://yoursite.com/2017/02/18/OOM%E5%BC%82%E5%B8%B8%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2017/02/18/OOM异常实战/</id>
    <published>2017-02-18T08:27:03.000Z</published>
    <updated>2017-05-09T02:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOM异常实战"><a href="#OOM异常实战" class="headerlink" title="OOM异常实战"></a>OOM异常实战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。</p>
<a id="more"></a>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>&#160; &#160; &#160; &#160;有几个重要参数设置如下：</p>
<ol>
<li><p>-Xms  堆大小的最小值设置参数</p>
</li>
<li><p>-Xmx  堆的大小最大值，如果设置为最小值一样，则不允许自动扩展。</p>
</li>
<li><p>-XX：+HeapDumpOnOutOfMemoryError  让内存溢出时Dump出当前内存堆转储快照。</p>
</li>
</ol>
<h3 id="模拟产生方法"><a href="#模拟产生方法" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制回收这些对象，就能模拟抛出OOM异常的情景。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&#160; &#160; &#160; &#160;<br>使用内存映像分析工具：Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，即要搞明白是内存泄漏还是内存溢出。 </p>
<ol>
<li>内存泄漏导致的OOM：new出来的很多对象已经不需要了，但仍然有引用指向，所以垃圾回收机制无法回收。 </li>
<li>内存溢出：new出来的对象都是需要的，但堆内存太小装不下了。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;<font color="red">如果是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。找到泄漏对象是通过怎样的路径与GC Roots发生关联，然后导致垃圾回收机制无法自动回收的。如果不存在内存泄漏，也就是所有的对象都必须存在，这时候就调大堆内存。</font></p>
<h2 id="虚拟机栈和本地方法溢出"><a href="#虚拟机栈和本地方法溢出" class="headerlink" title="虚拟机栈和本地方法溢出"></a>虚拟机栈和本地方法溢出</h2><p>&#160; &#160; &#160; &#160;在hotspot中不区分虚拟机和本地方法栈，因此对于hotspot来说，-Xoss参数存在但是无效，栈容量只由-Xss参数决定。</p>
<p>&#160; &#160; &#160; &#160;书上的实验结果表明；</p>
<ol>
<li>在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。</li>
<li>不限于单线程可以模拟出OOM，但是这种产生的内存溢出与栈空间足够大不存在联系，而且越大反而更容易产生内存溢出。原因：<font color="red">内存有限，每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程的时候就越容易把剩下的内存耗尽。</font></li>
<li>所以在多线程开发中特别注意，StackOverflowError有错误堆栈可以阅读，相对排查简单一些。大多数情况下达到1000～2000完全没有问题，对于正常的递归大多数情况下完全够用了。<font color="red">如果是多线程导致内存溢出的话，就只能减少最大堆或者栈的容量来获得更多的线程。</font></li>
</ol>
<h2 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h2><h3 id="模拟产生方法-1"><a href="#模拟产生方法-1" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果要向运行时内存中添加内容，最简单的方式是使用string.intern（）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：PermSize        &#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：MaxPermSize。溢出后提示信息是PermGen space。</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>&#160; &#160; &#160; &#160;方法区存放class信息，比如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<h3 id="模拟产生方法-2"><a href="#模拟产生方法-2" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;产生许多类区填满方法区，直到溢出。还可以反射和动态代理，还可以用CGLIB直接操作字符码，生成动态类。（框架中精彩需要对类进行增强，都会使用到CGLIB，增强的类越多，就需要越大的方法区保证动态生成的class可以加载入内存）。</p>
<p>&#160; &#160; &#160; &#160;方法区溢出也是常见的内存溢出，一个类如果要被垃圾收集器回收掉条件是十分苛刻的。在动态生成大量Class文件的应用中，需要特别注意类的回收状况。常见的还有JSP应用。</p>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>-XX：MaxDirectMemorySize，如果不指定默认和堆一样大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OOM异常实战&quot;&gt;&lt;a href=&quot;#OOM异常实战&quot; class=&quot;headerlink&quot; title=&quot;OOM异常实战&quot;&gt;&lt;/a&gt;OOM异常实战&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM进阶" scheme="http://yoursite.com/categories/JVM%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="OOM异常" scheme="http://yoursite.com/tags/OOM%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（一）</title>
    <link href="http://yoursite.com/2017/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/15/Java虚拟机（一）/</id>
    <published>2017-02-15T03:09:08.000Z</published>
    <updated>2017-05-08T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之自动内存管理机制（一）"><a href="#JVM之自动内存管理机制（一）" class="headerlink" title="JVM之自动内存管理机制（一）"></a>JVM之自动内存管理机制（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这段时间准备整理下JVM的知识，了解Java就必须了解java虚拟机的特性，本节先从Java的自动内存管理机制来讲起，有一句话：<font color="red">Java与C++之间有一堵由内存动态分配和垃圾手机技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</font></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&#160; &#160; &#160; &#160;在c和c++中的内存管理领域，程序员拥有最高权力的皇帝，拥有每一个对象的所有权，又担负着每一个对象生命开始到结束的责任。对于java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new对象配对delete／free代码，而且不太容易出现内存泄漏和溢出。正是因为这样，Java程序员没有了掌控权，排除问题的时候将是异常艰难的工作。了解内存的各个区域，是翻越这个高墙的第一步。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>&#160; &#160; &#160; &#160;虚拟机在执行java程序的时候会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途、创建和销毁的时间。如下图所示：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://dl.iteye.com/upload/picture/pic/115264/4991b17e-a8b4-3d0a-a316-4651bb23da5e.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol>
<li>是一个较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器工作时就是通过改变这个计数起的值来选取下一条需要执行的字节码指令。</li>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能都依赖计算器。</li>
<li>多线程时通过线程轮流切换并分配处理器执行时间的方式来实现的。</li>
<li>由于在任何一个确定的时刻，一个处理器只能处理一个线程，所以每个线程应该需要一个独立的程序计数器，所以它被称为<font color="red">线程私有。</font></li>
<li>如果正在执行native方法，程序计数器为空。</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ol>
<li>也是线程私有，生命周期和线程一样。</li>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法一行的时候都会产生一个栈帧，它用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法调用直到完成就对应一个栈帧在虚拟机栈入栈道出栈的过程</li>
<li>局部变量表存放了编译器可知的各种数据类型，包括基本类型和引用类型（这里只是一个地址）和retrunAddress类型（指向一条字节码指令的地址）。</li>
<li>在这个区域定义了两个异常：StackOverflowError异常，栈深度大于虚拟机所允许的栈深度，栈溢出，和OutOfMemoryError，即OOM，表示动态扩展的虚拟机无法申请到足够内存时会抛出的异常。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&#160; &#160; &#160; &#160;其实只不过是区别于虚拟机栈所执行方法的不同，虚拟机栈执行Java方法，本地方法栈执行native方法。比如hotspot虚拟机就把本地方法栈和虚拟机合二为一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ol>
<li>是虚拟机所管理的内存中的最大一块，Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。</li>
<li>存放的都是对象的实例，几乎所有的对象实例都在这里分配内存。随着及时动态编译器jit的发展和逃逸分析技术的逐渐成熟，所有的对象都分配在堆上也不是那么绝对。</li>
<li>Java堆事垃圾回收的主要区域，也被称为GC堆。垃圾回收一般采用分代收集算法，堆中细分的话可分：新生代、老生代或者、Eden、From Survivor、To Survivor等。</li>
<li>线程共享的Java堆可能划分出多个线程私有的分配缓冲区，不过存放内容都是对象，进一步划分事为了更好的回收对象。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>和Java堆一样，是各个线程共享的区域，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是堆的一个逻辑部分，但是别名NonHeap，非堆。</li>
<li>垃圾收集行为在此区域较少发生，但并非永久代，对常量池的回收和类的卸载。</li>
<li>此区域无法满足内存分配时，会抛出OOM异常。</li>
<li>运行时常量池时方法区的一部分，编译期已经确定的字面量和符号引用，类加载完之后就存放到方法区的运行时常量池中。</li>
<li>不一定都在编译的时候放入常量池，比如string的intern（）方法，可把新的常量放入池中。常量池也会报OOM异常。</li>
</ol>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ol>
<li>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范汇总的内存区域，但是被频繁使用，而且可能导致OOM异常，比如NIO，引用了一种基于通道与缓冲区的I／O方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能显著的提高性能，因为避免了在Java堆和native堆中来回复制数据。</li>
<li>显然直接内存不会受到堆大小的限制，但是内存都收到系统内存限制。也可能出现OOM。</li>
</ol>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>&#160; &#160; &#160; &#160;我们分析一下下面这个简单代码的运行过程：</p>
<pre><code>Object obj=new Object();
</code></pre><p>&#160; &#160; &#160; &#160;这句代码中，Object obj 这部分的语义将会反映到java栈的本地变量表中，作为一个ref引用类型数据出现，而new Object（）这部分语义反映到堆中，形成一块存储了object类型所有实例数据值的结构内存，具体类型以及虚拟机实现的对象内存分布不同。另外，对象类型、父类、实现的接口、方法等信息存储在方法区中，保证能查找到对象类型数据的地址信息。</p>
<p>&#160; &#160; &#160; &#160;主流的访问方式有两种：</p>
<ol>
<li>使用句柄方式，堆中还会划分出一个内存来作为句柄池，ref中存储的就是对象的句柄地址，句柄中又包含对象实例和对象类型的指针。好处是存储的是稳定的地址，在对象移动时只改变句柄中的，不用改变ref的。</li>
<li>使用直接指针访问方式，ref中直接存储就是对象地址。最大好处就是速度更快，节省了一次指针定位的时间。hotspot就是采用这种。</li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之自动内存管理机制（一）&quot;&gt;&lt;a href=&quot;#JVM之自动内存管理机制（一）&quot; class=&quot;headerlink&quot; title=&quot;JVM之自动内存管理机制（一）&quot;&gt;&lt;/a&gt;JVM之自动内存管理机制（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这段时间准备整理下JVM的知识，了解Java就必须了解java虚拟机的特性，本节先从Java的自动内存管理机制来讲起，有一句话：&lt;font color=red&gt;Java与C++之间有一堵由内存动态分配和垃圾手机技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="自动内存管理机制" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（二）</title>
    <link href="http://yoursite.com/2017/02/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/10/Java基础之面向对象（二）/</id>
    <published>2017-02-10T07:25:36.000Z</published>
    <updated>2017-05-08T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（二）"><a href="#Java面向对象特性（二）" class="headerlink" title="Java面向对象特性（二）"></a>Java面向对象特性（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;本篇继续讲面向对象特性，自动装箱和拆箱，抽象和接口，内部类和lambda表达式，枚举类型等方面。</p>
  <a id="more"></a>
<h2 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h2><p>&#160; &#160; &#160; &#160;JDK 1.5之前，Java有8个基本数据类型不能当前Object类型，之后就才用自动装箱和拆箱，可以把一个基本数据类型直接赋值给包装类变量，也可以把包装类对象直接复制给一个对应的基本数据类型。</p>
<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><p>&#160; &#160; &#160; &#160;用static关键字修饰的成员就是类成员，static语义代表的是修饰的对象属于整个类而不属于任何实例。</p>
<p>&#160; &#160; &#160; &#160;Java中只能包括五种：成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）、以static修饰的成员就是类成员，他能修饰除构造器之外的其他四种。</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>&#160; &#160; &#160; &#160;在一些特殊场景下，要求不允许自由创建该类的对象，而只允许为该类创建一个对象，为了避免该类被自由创建，类的构造器使用private修饰，从而把该类的所有构造器隐藏起来。但是还要有一个public方法作为该类的访问点，用于创建该类的对象，且该方法必须使用static修饰，除此之外，该类还不许知道已经缓存过已经创建的对象，否则该类无法知道是否创建过该对象。下面就手写代码实现一个单例类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;但是这也只是懒汉，单线程情况，还有几种写法参考博客：<a href="https://www.oschina.net/code/snippet_107039_6062" target="_blank" rel="external">单例的5种写法</a>。</p>
<h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><p>&#160; &#160; &#160; &#160;final关键字可以修饰类、变量和方法，用于它修饰的类，方法和变量不可变，类似C#中的sealed。修饰变量包括成员变量和局部变量和形参。准确说是一旦赋类初始值就不能被改变。final还可以完成C中宏定义的类似功能。</p>
<h3 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h3><p>&#160; &#160; &#160; &#160;final修饰的成员变量必须由程序员显式的指定初始值。</p>
<h3 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3><p>&#160; &#160; &#160; &#160; 系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。但是用final修饰局部变量时，既可以在定义时，指定默认初始值，也可以不指定。</p>
<h3 id="final修饰基本变量和引用变量区别"><a href="#final修饰基本变量和引用变量区别" class="headerlink" title="final修饰基本变量和引用变量区别"></a>final修饰基本变量和引用变量区别</h3><p>&#160; &#160; &#160; &#160;当使用final修饰基本变量时，不能对基本变量类型进行重新赋值，但对引用来说，仅仅是一个引用地址，final只能保证引用类型变量指定的地址不会改变，一直引用一个对象，但这个对象完全可以发生改变。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>&#160; &#160; &#160; &#160;不想子类重写的可以用final修饰，比如Object中的getClass（）方法。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&#160; &#160; &#160; &#160;final类不能使用子类，比如Math类就是。保证不能被继承。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>&#160; &#160; &#160; &#160;当编写一个类时候，常常会给类定义一些方法，比如形状类Shape，应该提供一个计算周长的方法，但是Shape类型不同计算周长方式不同，这时我们可以使用抽象方法，只有方法签名，没有方法实现。</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ol>
<li>都必须使用abstract修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，<font color="red">无法使用new来调用构造器实例对象，即使不包含抽象方法。</font></li>
<li>抽象类可以包含成员变量、方法、构造器、初始化块、内部类5个成分。主要作用是被其子类调用。</li>
<li>含有抽象方法的类：包括直接定义来一个抽象方法，继承一个抽象父类，但没有完全实现父类包含的抽象方法，或者实现了一个接口但没有完全实现接口包含的抽象方法这三种情况）只能被定义为抽象类。</li>
<li>不能用来修饰成员变量、局部变量、构造器。</li>
<li>static和abstract不同时修饰一个方法，即没有所谓的类静态抽象方法。但也不是绝对互斥，它们可以修饰内部类。</li>
<li>private和abstract不同时修饰方法。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&#160; &#160; &#160; &#160;在Java8中对接口进行了改进，允许接口中定义默认方法，默认方法可以提供方法实现。默认方法必须使用default修饰，且不能被static修饰。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&#160; &#160; &#160; &#160;接口是从多个相似类中抽象出来的规范，规范了它实现类的基本行为规范。接口使用interface关键字。仿佛默认使用public修饰。</p>
<p>&#160; &#160; &#160; &#160;Java8中允许接口中定义类方法，必须使用statci修饰，该方法可以使用接口来调用。</p>
<p>&#160; &#160; &#160; &#160;接口成员默认使用public static final修饰。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>接口支持多继承；</li>
<li>接口不能创建实例；</li>
<li>接口的实现类 implents；实现类可实现多个接口。</li>
</ol>
<h2 id="抽象和接口的比较"><a href="#抽象和接口的比较" class="headerlink" title="抽象和接口的比较"></a>抽象和接口的比较</h2><p>&#160; &#160; &#160; &#160;一般接口来控制行为规范，抽象类用来定型。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>参考这篇博客：<a href="http://www.cnblogs.com/yongjiapei/p/5494894.html" target="_blank" rel="external">抽象和接口的区别</a>。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="实现简单工厂模式"><a href="#实现简单工厂模式" class="headerlink" title="实现简单工厂模式"></a>实现简单工厂模式</h3><p><a href="http://www.cnblogs.com/toutou/p/4899388.html" target="_blank" rel="external">详解工厂模式三种类型</a></p>
<h3 id="实现命令模式"><a href="#实现命令模式" class="headerlink" title="实现命令模式"></a>实现命令模式</h3><p><a href="http://blog.csdn.net/jason0539/article/details/45110355" target="_blank" rel="external">Java命令模式实现</a></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><ol>
<li>非静态内部类可以访问外部private成员。</li>
<li>优先在局部变量中寻找。</li>
<li>外部不能访问非静态内部类的private成员。</li>
<li>非静态内部类中不能定义静态成员。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>静态内部类中可以包含静态、非静态成员都可以。</li>
<li>静态类不能访问外部成员，只能是访问静态成员。</li>
<li>静态内部类是外部类的一个静态成员，因此外部类的所有成员可以使用静态内部类来定义，创建对象，但是不能直接访问静态内部类的成员。</li>
<li>接口中也能定义内部类，接口中只能是静态内部类，默认使用public static。</li>
</ol>
<h2 id="内部类的使用"><a href="#内部类的使用" class="headerlink" title="内部类的使用"></a>内部类的使用</h2><ol>
<li>外部类内部使用内部类：和普通类没有太大区别，唯一区别是：不要在外部类中的静态成员中使用非静态的内部类。</li>
<li>在外部类以外使用非静态内部类：如果希望被访问，不能使用private。</li>
<li>外部类以外访问静态内部类，无须实例外部类。</li>
<li>局部内部类，在方法里，只能在方法内使用。</li>
</ol>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>&#160; &#160; &#160; &#160;适合创建那种只需要一次使用的类，类如命令模式中的command对象。匿名内部类必须继承一个父类或实现一个接口，但最多继承一个父类或实现一个接口。不允许为抽象类，不能定义构造器，因为没有类名，但可以定义初始化块来完成构造器要完成的事情。</p>
<p>&#160; &#160; &#160; &#160;在Java8之前，Java要求局部内部类、匿名内部类访问的局部变量必须使用final修饰，从Java8开始这个限制被取消了，Java8更加智能，自动添加final。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html" target="_blank" rel="external">匿名内部类总结</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>&#160; &#160; &#160; &#160;允许用更简单的代码来创建只有一个抽象方法的接口，即函数式接口。lambda表达式完全可用于简化创建匿名内部类对象。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>&#160; &#160; &#160; &#160;早期会用简单的静态变量来表示枚举，但是类型不安全，没有命名空间，意义不明确，后来用类来封装，但是额外要写代码，JDK1.5之后增加了对枚举类的支持。enum。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/oumyye/p/4232532.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（二）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（二）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（二）&quot;&gt;&lt;/a&gt;Java面向对象特性（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇继续讲面向对象特性，自动装箱和拆箱，抽象和接口，内部类和lambda表达式，枚举类型等方面。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（一）</title>
    <link href="http://yoursite.com/2017/02/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/08/Java基础之面向对象（一）/</id>
    <published>2017-02-08T04:38:25.000Z</published>
    <updated>2017-05-07T07:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（一）"><a href="#Java面向对象特性（一）" class="headerlink" title="Java面向对象特性（一）"></a>Java面向对象特性（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。</p>
  <a id="more"></a>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>&#160; &#160; &#160; &#160;区分类和对象，由类实例出对象，怎么去定义一个类，怎么通过类的构造器实例一个对象。类中有属性和方法。方法有构造方法和普通方法。属性有成员变量和局部变量。构造器没有返回值，返回值时隐式的。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>&#160; &#160; &#160; &#160;如果没有构造器，会默认提供一个无参数的构造器，构造器最大的用处是在创建对象时执行，创建一个对象的时候会执行初始化：所有基本类型0，布尔为false，引用类型为null。构造器也不是完全负责创建Java对象，new的时候已经开辟了内存空间，只不过智能字啊构造器中通过this使用，构造器用来返回一个对象，通常还会赋值给一个引用变量。</p>
<p>&#160; &#160; &#160; &#160;构造器也可以像方法一样重载。</p>
<h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>&#160; &#160; &#160; &#160;方法在逻辑上要么属于类，要么属于对象。方法是类或对象的行为特征的抽象。类似传统结构化程序中的函数。</p>
<p>&#160; &#160; &#160; &#160;方法的参数可以指定个数，也可以可变个数，就是当成数组传入。参数传递机制有值传递和引用传递。基本类型是值传递，引用类型是引用传递。</p>
<p>&#160; &#160; &#160; &#160;方法体内调用他自己，该方法就是递归方法。包含了一种隐式的循环，所以理论上递归都可以转为循环。</p>
<p>&#160; &#160; &#160; &#160;类中方法是可以重载的，就是允许方法名一样，但是参数不一样。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&#160; &#160; &#160; &#160;类中的变量分为成员变量和局部变量，成员变量不在方法体内，分为静态和非静态的，即类成员和实力成员变量，而局部变量一般包括形参、方法的局部变量（定义在方法内）、代码块的局部变量（在代码块内，例如for循环内部）。</p>
<p>&#160; &#160; &#160; &#160;这些的不同必然导致了变量的访问方式、作用范围和生命周期等方面必然有不同。</p>
<p>&#160; &#160; &#160; &#160;局部变量必须显式的初始化才能使用，而成员变量类加载的时候已经赋了初值。局部变量不属于任何实例或者类，他在方法的栈内存中，往往是基本类型和对象的引用。方法执行完就释放。</p>
<p>&#160; &#160; &#160; &#160;了解这些之后我们要合适选择变量类型。准确控制变量的作用域。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>&#160; &#160; &#160; &#160;它指将对象的状态信息部分隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作和访问。具体该怎么实现呢，适用访问控制符。</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>&#160; &#160; &#160; &#160;有下面四种private、default（friendly）、protected、public四种，比较如下图：</p>
<p><img src="http://img.blog.csdn.net/20160908104619224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>&#160; &#160; &#160; &#160;有这三个要掌握：package、import、import static；Java默认导入java.lang包下的所有类。下面列出常用包：</p>
<p> <img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E5%8C%85.png" alt=""></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&#160; &#160; &#160; &#160;Java是单继承多接口，用关键字extends实现。子类继承负累所有成员变量和方法，值得指出的是：子类不能获得父类的构造器。</p>
<h3 id="重写（覆盖）父类方法"><a href="#重写（覆盖）父类方法" class="headerlink" title="重写（覆盖）父类方法"></a>重写（覆盖）父类方法</h3><p>&#160; &#160; &#160; &#160;override，遵守两同两小一大原则：方法名、参数相同；子类返回值类型应该比父类更小或者相等、子类抛出的异常也应该比父类更小或者相等；子类方法的访问权限应该比父类更大或者相等。而且要么都是类方法，要么都是实例方法。</p>
<h3 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h3><pre><code>super....//使用父类方法或属性
this....// 使用类本身方法或属性
</code></pre><h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><p>&#160; &#160; &#160; &#160;从运行过程上看，创建任何对象时总是从该类所在继承树的最顶层类的构造器开始执行，然后依次向下执行，最后才执行本来的构造器。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>&#160; &#160; &#160; &#160;Java引用变量有两个类型，一个是编译时类型，一个时运行时类型。编译类型由声明该变量的类型决定，运行时类型由实际赋值给变量的类型决定，如果出现不一致，就可能出现所谓的多态。例如：</p>
<pre><code>SuperClass base=new SubClass();
</code></pre><p>&#160; &#160; &#160; &#160;因为子类是一个特殊的父类，因此允许把一个子类对象直接赋值给一个父类的引用类型。无须任何类型转换，精确的说时向上转型，向上转型由系统自动完成。但是编译时父类对象无法调用子类方法（可以利用反射来执行该方法）。</p>
<h2 id="强制类型转换和instanceof-运算符"><a href="#强制类型转换和instanceof-运算符" class="headerlink" title="强制类型转换和instanceof 运算符"></a>强制类型转换和instanceof 运算符</h2><pre><code>double d=113.4
long l=(long)d;
Objext hello=&quot;hello&quot;;
if(hello instanceof Object){
....
}
if(hello instanceof String){
....
}
</code></pre><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>&#160; &#160; &#160; &#160;继承是实现类复用的重要手段，但继承带来一个最大的坏处：破坏了封装，相比之下，组合也是实现类复用的重要方式。</p>
<p>&#160; &#160; &#160; &#160;继承在高可用的同时，暴漏了父类的实现细节，且子类还可以任意篡改，所以父类不想子类改变的属性方法应该使用private修饰符，还可以通过final修饰符控制不让子类改变。</p>
<p>&#160; &#160; &#160; &#160;被final修饰的类时不可变的，不能当作父类，如String。</p>
<h2 id="初识化块"><a href="#初识化块" class="headerlink" title="初识化块"></a>初识化块</h2><p>&#160; &#160; &#160; &#160;初始化块是类出现的第四种成员，前面依次由成员变量、方法和构造器，一个类里可以有多个初始化块。初始化块的修饰符只能是static，而且创建对象时，总是先执行初始化块，按出现顺序在执行构造器。</p>
<p>&#160; &#160; &#160; &#160;从某种程度上看，初始化块是构造器的补充。初始化块总是在构造器执行之前执行，系统通用可食用初始化块啦进行对象的初始化操作。</p>
<p>&#160; &#160; &#160; &#160;静态初始化块：在类加载的时候执行，而不是像之前那种在对象加载的时候执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本章主要介绍了Java面向对象的基本知识，包括如何定义类，如何为类成员添加成员变量、方法，以及如何创建类的对象。深入分析对象和引用变量之间的关系，方法的参数传递机制、重载，访问控制符等，三种面向对象特性的分析。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（一）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（一）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（一）&quot;&gt;&lt;/a&gt;Java面向对象特性（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（五）</title>
    <link href="http://yoursite.com/2017/02/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/05/深入理解mysql（五）/</id>
    <published>2017-02-05T11:35:48.000Z</published>
    <updated>2017-05-07T03:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（五）"><a href="#mysql学习笔记（五）" class="headerlink" title="mysql学习笔记（五）"></a>mysql学习笔记（五）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。</p>
  <a id="more"></a>
<h2 id="sql语句的技巧"><a href="#sql语句的技巧" class="headerlink" title="sql语句的技巧"></a>sql语句的技巧</h2><h3 id="group-by和having"><a href="#group-by和having" class="headerlink" title="group by和having"></a>group by和having</h3><p>&#160; &#160; &#160; &#160;在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度.例子如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""></p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""><br>&#160; &#160; &#160; &#160;<font color="red">在group by 后面增加 order by null 就可以防止排序.</font></p>
<p>tips：mysql中group by having 用法需要注意的事项: </p>
<ol>
<li><p>GROUP BY：<br>group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by后面。<br>比如 select name,sum(point) from table_name<br>这样sql语句会报错，必须写成:<br>select name,sum(point) from table_name GROUP BY name </p>
</li>
<li><p>HAVING<br>把 HAVING 加入 SQL 的原因是，WHERE 无法应用于合计函数，而如果没有 HAVING，就无法测试结果条件。<br>select name,sum(point)<br>from table_name GROUP BY name<br>HAVING sum(point)&gt;1000 </p>
</li>
<li><p>having通常和group by联合使用.</p>
</li>
</ol>
<p>参考连接：<a href="http://blog.csdn.net/bingogirl/article/details/52559302" target="_blank" rel="external">GROUP BY和HAVING</a></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>&#160; &#160; &#160; &#160;有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p>
<pre><code>select * from dept, emp where dept.deptno=emp.deptno; //简单处理方式

select * from dept left join emp on dept.deptno=emp.deptno; //左外连接，效果更佳！
</code></pre><p>参考这篇博客：<a href="http://www.cnblogs.com/BeginMan/p/3754322.html" target="_blank" rel="external">mysql三种连接查询总结和性能分析</a></p>
<h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p> 参考这篇博文：<a href="http://www.cnblogs.com/glory-jzx/archive/2012/07/19/2599215.html" target="_blank" rel="external">exists用法</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>&#160; &#160; &#160; &#160;这里放几个别人整理好的sql优化，从细节上我们要把握。</p>
<ol>
<li><a href="http://www.cnblogs.com/ATree/archive/2011/02/13/sql_optimize_1.html" target="_blank" rel="external">优化sql查询</a>。</li>
</ol>
<ol>
<li><a href="http://www.jb51.net/article/39221.htm" target="_blank" rel="external">sql优化常用的30的技巧</a>。</li>
</ol>
<h2 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h2><ol>
<li><p>myisam 存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。（要定期碎片整理，因为删除了数据，MYD文件不会变小，整理可用optimize table XXX）。</p>
</li>
<li><p>INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p>
</li>
</ol>
<ol>
<li>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. 重启mysql就没有了。。。没有持久化机制，不像redis。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>&#160; &#160; &#160; &#160;下面从几个方面来比较几个存储引擎。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt=""></p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>&#160; &#160; &#160; &#160;<a href="http://www.cnblogs.com/100thMountain/p/4692008.html" target="_blank" rel="external">mysql字段类型选择</a></p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><p>&#160; &#160; &#160; &#160;分水平分表和垂直分表。5.1版本之后才用分区。</p>
<p>&#160; &#160; &#160; &#160;<a href="http://www.2cto.com/database/201503/380348.html" target="_blank" rel="external">mysql分表分区详解</a></p>
<h2 id="读写分离、负载均衡、主从复制"><a href="#读写分离、负载均衡、主从复制" class="headerlink" title="读写分离、负载均衡、主从复制"></a>读写分离、负载均衡、主从复制</h2><p>&#160; &#160; &#160; &#160;这些我们在以后分布式系统构建中在深入学习。</p>
<p><img src="http://images2015.cnblogs.com/blog/47685/201606/47685-20160605035114867-448644269.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们就分项的讲诉了许多的优化策略和原理方法，当然并不是全部。要记住这些方法，随时使用。可以参考这篇博文：<a href="http://blog.csdn.net/zls986992484/article/details/52860496" target="_blank" rel="external">mysql优化详解</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（五）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（五）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（五）&quot;&gt;&lt;/a&gt;mysql学习笔记（五）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（四）</title>
    <link href="http://yoursite.com/2017/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/22/深入理解mysql（四）/</id>
    <published>2017-01-22T12:34:17.000Z</published>
    <updated>2017-05-06T12:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（四）"><a href="#mysql学习笔记（四）" class="headerlink" title="mysql学习笔记（四）"></a>mysql学习笔记（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。</p>
  <a id="more"></a>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>&#160; &#160; &#160; &#160;创建索引可以大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="适合建立索引的情况"><a href="#适合建立索引的情况" class="headerlink" title="适合建立索引的情况"></a>适合建立索引的情况</h2><p>一般来说，应该在这些列上创建索引：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h2 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h2><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">此处为参考链接</a>。</p>
<h2 id="索引的使用分析"><a href="#索引的使用分析" class="headerlink" title="索引的使用分析"></a>索引的使用分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>&#160; &#160; &#160; &#160;下图说明利用这个指令出现的每项及其含义：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/explain.png" alt=""></p>
<h3 id="使用索引的几个注意事项"><a href="#使用索引的几个注意事项" class="headerlink" title="使用索引的几个注意事项"></a>使用索引的几个注意事项</h3><p>&#160; &#160; &#160; &#160;我们把dept这张表的deptno列设为主键，然后在把dname和loc列设为复合索引。代码如下：</p>
<pre><code>//添加主键
alter table dept add primary key(deptno);
//  dname 左边的列,loc就是右边的列
alter table dept add index my_ind (dname,loc); 
</code></pre><ol>
<li>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<pre><code>explain select * from dept where loc=&apos;aaa&apos;\G；//此处就不会使用到索引
</code></pre></li>
</ol>
<ol>
<li><p>对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引,‘aaa%’ 会使用到索引。</p>
<p> explain select * from dept where dname like ‘%aaa’\G</p>
<p> 不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 _这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</p>
<p>这两个语句执行比较就可以等到结果。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。情况特殊，比如空表或者记录只有一条的时候。</p>
</li>
</ol>
<h3 id="查询索引使用情况"><a href="#查询索引使用情况" class="headerlink" title="查询索引使用情况"></a>查询索引使用情况</h3><p>&#160; &#160; &#160; &#160;如何查看索引使用的情况，就像看缓存命中率一样:</p>
<pre><code>show status like ‘Handler_read%’;
</code></pre><p>tips：</p>
<pre><code>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。

handler_read_rnd_next:这个值越高，说明查询低效。
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（四）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（四）&quot;&gt;&lt;/a&gt;mysql学习笔记（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（三）</title>
    <link href="http://yoursite.com/2017/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/18/深入理解mysql（三）/</id>
    <published>2017-01-18T09:26:32.000Z</published>
    <updated>2017-05-06T12:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（三）"><a href="#mysql学习笔记（三）" class="headerlink" title="mysql学习笔记（三）"></a>mysql学习笔记（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。<br>  <a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">索引能使查询变快的原理</font>：先建了一个索引文件，就是MYI文件，然后建立查找二叉树（也叫B树，二叉搜索树，二叉排序树）。利用了二叉树算法，使搜索性能逼近二分查找，但是他比连续内存空间的二分查找优点是，插入和删除不需要移动大量数据，通常是常数开销。记录下了对应索引数值的物理位置，所以数据库换了路径，索引也失效了。</p>
<p>&#160; &#160; &#160; &#160;学会用并利用explain来分析语句。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png" alt=""></p>
<h2 id="建立适当的索引"><a href="#建立适当的索引" class="headerlink" title="建立适当的索引"></a>建立适当的索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>&#160; &#160; &#160; &#160;当一张表，把某个列设为主键的时候，则该列就是主键索引。主键不能为null且不允许重复。</p>
<pre><code>create table aaa
(id int unsigned primary key auto_increment ,
name varchar(32) not null defaul ‘’);
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>&#160; &#160; &#160; &#160;这是id 列就是主键索引。</p>
<p>&#160; &#160; &#160; &#160;如果你创建表时，没有指定主键索引，也可以在创建表后，在添加指令:</p>
<pre><code>alter table 表名 add primary key (列名);
</code></pre><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;举例:</p>
<pre><code>create table bbb (id int , name varchar(32) not null default ‘’);

alter table bbb add primary key (id);
</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;添加之后发现库文件MYI文件变大。我们在我们测试样本的emp库建立主键索引，且前后查询对比如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.85 sec)</div><div class="line"></div><div class="line">mysql&gt; alter table emp add primary key(empno);</div><div class="line">Query OK, 4000000 rows affected (9.47 sec)</div><div class="line">Records: 4000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;发现时间明显变少，这就是主键索引的作用，按主键单位时间定为到准确位置，而不是从头开始找。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>&#160; &#160; &#160; &#160;一般来说，普通索引的创建，是先创建表，然后在创建普通索引。</p>
<p>&#160; &#160; &#160; &#160;比如:</p>
<pre><code>//先建表
create table ccc(
id int unsigned,
name varchar(32)
)
//添加索引
create index 索引名 on 表 (列1,列名2);
</code></pre><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><p>&#160; &#160; &#160; &#160;全文索引，主要是在很针对文件、文本的检索、比如文章，全文索引仅针对MyISAM有用。我们在测试样本temp库中创建下表，并插入测试数据如下：</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; CREATE TABLE articles (
    -&gt;        id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&gt;        title VARCHAR(200),
    -&gt;        body TEXT,
    -&gt;        FULLTEXT (title,body)
    -&gt;      )engine=myisam charset utf8;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO articles (title,body) VALUES
    -&gt;      (&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),
    -&gt;      (&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),
    -&gt;      (&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),
        -&gt;      (&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),
    -&gt;      (&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),
    -&gt;      (&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0
</code></pre><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>然后使用下面命令看是否成功,其中\G代表按行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;使用explain来分析一个错误使用全文索引的语句。</p>
<pre><code>mysql&gt; explain select * from articles where body like &quot;%mysql%&quot;\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
         type: ALL
possible_keys: NULL
      key: NULL
  key_len: NULL
      ref: NULL
     rows: 6
 filtered: 16.67
    Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>可看到possible_keys: NULL，key: NULL，说明没用到，下面例子就看到使用到了title。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><font color="red">正确的用法：WHERE  MATCH(title,body) against(‘database’);</font>


<pre><code>mysql&gt; explain select * from articles where match(title,body)     against(&apos;database&apos;)\G; 
*************************** 1. row ***************************
       id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
     type: fulltext
possible_keys: title
          key: title
      key_len: 0
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>&#160; &#160; &#160; &#160;说明：</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</li>
<li>使用方法是 match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select match(title,body) against(&apos;a&apos;) from articles;</div><div class="line">+--------------------------------+</div><div class="line">| match(title,body) against(&apos;a&apos;) |</div><div class="line">+--------------------------------+</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">+--------------------------------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>&#160; &#160; &#160; &#160;当表的某列被指定为unique约束时，这列就是一个唯一索引。按照以下方式建表，name列就是唯一索引。<font color="red">唯一索引允许为空，而且允许多个。</font></p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; create table ddd(id int primary key auto_increment , name varchar(32)     unique);
Query OK, 0 rows affected (0.02 sec)
</code></pre><h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;在创建表后，再去创建唯一索引，见如下指令：</p>
<pre><code>create table eee(id int primary key auto_increment, name varchar(32));

create unique index 索引名  on 表名 (列表..);
</code></pre><h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><p>desc 表名 【该方法的缺点是：　不能够显示索引名.】</p>
<p>show index(es) from 表名</p>
<p>show keys from 表名</p>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; desc articles</div><div class="line">    -&gt; ;</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| Field | Type             | Null | Key | Default | Extra          |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| title | varchar(200)     | YES  | MUL | NULL    |                |</div><div class="line">| body  | text             | YES  |     | NULL    |                |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show keys from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>alter table 表名 drop index 索引名; </p>
<p>如果删除主键索引。</p>
<p>alter table 表名 drop primary key </p>
<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p>先删除再重新创建。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节介绍的如何操作索引和索引能加快查询的原理。下篇我们看看怎么去分析索引的性能，比如explain用法，然后我们该怎么去适用索引最恰当。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（三）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（三）&quot;&gt;&lt;/a&gt;mysql学习笔记（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。&lt;br&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（二）</title>
    <link href="http://yoursite.com/2017/01/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/01/12/深入理解mysql（二）优化/</id>
    <published>2017-01-12T05:44:47.000Z</published>
    <updated>2017-05-05T09:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（二）"><a href="#mysql学习笔记（二）" class="headerlink" title="mysql学习笔记（二）"></a>mysql学习笔记（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。</p>
  <a id="more"></a>
<h2 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h2><p>对mysql优化时一个综合性的技术，主要包括：</p>
<ol>
<li><p>表的设计合理化(符合3NF)</p>
</li>
<li><p>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]</p>
</li>
<li>分表技术(水平分割、垂直分割)</li>
<li>读写[写: update/delete/add]分离</li>
<li>存储过程 [模块化编程，可以提高速度]</li>
<li>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]</li>
<li>mysql服务器硬件升级</li>
<li>定时的去清除不需要的数据,定时进行碎片整理(MyISAM) </li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF</p>
<p>&#160; &#160; &#160; &#160;1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p>
<p>&#160; &#160; &#160; &#160;2NF: 表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现。</p>
<p>&#160; &#160; &#160; &#160;3NF: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足3NF:</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/3NF.png" alt=""></p>
<p>需要修改成以下，消除依赖：<br><img src="http://opb7t58xj.bkt.clouddn.com/3NF2.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;反3NF : 但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 </p>
<p>案例 ：<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8F%8D3NF.png" alt=""></p>
<h3 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h3><p>&#160; &#160; &#160; &#160;查看mysql配置参数。我的运行环境是Mac，mysql5.7.18，如下图：<br><img src="http://opb7t58xj.bkt.clouddn.com/showstatus.png" alt=""><br>从图中可知，有356个变量，其中我们需要熟悉一部分，知道它代表的意义，可用下面指令查具体的：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/show%20like.png" alt=""></p>
<p>注意：这里结束符非常重要，区分中英文符号，是结束一条命令的标志。。。。。存储过程中还要改。因为存储过程中就有分号。</p>
<p>这里放两个链接：<a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">mysql 命令大全</a>，<a href="http://blog.itpub.net/15480802/viewspace-764968/" target="_blank" rel="external">mysql较为重要的状态变量</a>。</p>
<p>&#160; &#160; &#160; &#160;那我们如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)，比如首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)。实现如下：</p>
<p><em>show status</em></p>
<ol>
<li><p>常用的:<br>show status like ‘uptime’ ;<br>show  stauts like ‘com_select’  show stauts like ‘com_insert’ …类推 update  delete</p>
</li>
<li><p>show [session|global] status like …. 如果你不写  [session|global] 默认是session 会话，指取出当前窗口的执行，如果你想看所有(从mysql 启动到现在，则应该 global)</p>
</li>
<li><p>show status like ‘connections’; </p>
</li>
<li><p>show status like ‘slow_queries’;//显示慢查询次数</p>
</li>
</ol>
<h3 id="压力测试脚本生成"><a href="#压力测试脚本生成" class="headerlink" title="压力测试脚本生成"></a>压力测试脚本生成</h3><p>&#160; &#160; &#160; &#160;如何去定位慢查询呢，我们想还原一个场景，那我们就要构建一个大表(400 万)，我们采用存储过程构建，默认情况下，mysql认为10秒才是一个慢查询.所以我们要修改mysql的慢查询时间.使用以下命令：</p>
<p>show variables like ‘long_query_time’ ; //可以显示当前慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/60AEBD45-4A1C-4709-90F9-04324FBB4197.png" alt=""></p>
<p>set long_query_time=1 ;//可以修改慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/manchaxun.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;而且我们构建的大表中记录是有要求的,为了满足真实性，我们采取了随机生成的方法 ，使记录不同从而使测试效果和真实的相差不大。存储过程源码我放在了GitHub上，地址如下，无耻的求个star或者fork：<a href="https://github.com/wustzoujing/BetterMysqlTestDemo" target="_blank" rel="external">wustzoujing/BetterMysqlTestDemo</a>；简要的记录下我的执行过程；<br>首先写了两个随机函数，产生指定长度的两个字符串或者数字。其中rand_string()执行结果如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;上图可以知道：其中dual是亚元表，就是空表，已经随机生成了6位字符串。接下来看看存储过程执行成功如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/cunshuguochen.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;最后我们调用存储过程，执行几分钟后，看下结果，已经插入成功。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/shuju.png" alt=""></p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>这时我们已经有慢查询的次数了，就是插入数据这条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;long_query_time&apos;</div><div class="line"></div><div class="line">    -&gt; ;</div><div class="line">    </div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| Variable_name   | Value    |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| long_query_time | 1.000000 |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;然后我们需要开启慢查询日志（不同操作系统不同设置方式和文件路径，百度应该有很多），然后重启mysql，上面就会记录着我们的慢查询语句是什么。如下图，这是我的结果。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-05%20%E4%B8%8B%E5%8D%885.16.25.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们主要是形成测试样本，利用慢查询工具，这只是一个例子，还有很多命令方法工具帮助我们来找出问题，可以参考手册来。下篇博客讲讲发现问题了，我们如何优化。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（二）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（二）&quot;&gt;&lt;/a&gt;mysql学习笔记（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（一）</title>
    <link href="http://yoursite.com/2017/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/08/深入理解mysql（一）/</id>
    <published>2017-01-08T13:44:47.000Z</published>
    <updated>2017-05-05T05:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（一）"><a href="#mysql学习笔记（一）" class="headerlink" title="mysql学习笔记（一）"></a>mysql学习笔记（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。</p>
  <a id="more"></a>
<h2 id="数据库的种类"><a href="#数据库的种类" class="headerlink" title="数据库的种类"></a>数据库的种类</h2><ol>
<li>对象数据库 应用领域：地理信息系统、科学与统计数据库、多媒体系统、XML文档仓库。</li>
<li>对象关系数据库 了解一下</li>
<li>关系数据库，例如mysql、oracle、sql server、db2等。我们以mysql为例深入了解关系数据库。</li>
<li>介于关系数据库与非关系数据库之间的MongoDB和完全的非关系数据库NoSql的Redis。Redis是我们了解的重点。</li>
</ol>
<h2 id="mysql数据库系统"><a href="#mysql数据库系统" class="headerlink" title="mysql数据库系统"></a>mysql数据库系统</h2><p>&#160; &#160; &#160; &#160;mysql由SQL接口、解析器、查询优化器、查询缓存（缓存和缓冲区）、存储引擎等几个子系统构成。</p>
<p><img src="http://img1.51cto.com/attachment/201308/111054362.png?_=3641983" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中还有几个部分解释如下：</p>
<p>connectors：与其他编程语言中的sql 语句进行交互，如php、java等；</p>
<p>Management Serveices &amp; Utilities：系统管理和控制工具；</p>
<p>Connection Pool (连接池)：管理缓冲用户连接，线程处理等需要缓存的需求。下面我们一个一个的来了解。</p>
<h3 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h3><p>&#160; &#160; &#160; &#160;SQL提供了从用户接收命令并把结果返回给用户的机制。关系数据库大都支持SQL标准，基本语句都类似，比如常规的CURD操作，sql server和mysql就差不多。mysql是一个多线程应用，它为每一个连接创建一个线程，每个线程执行都独立于其他线程。接收到SQL命令，解析各个部分存入一个类结构，查询结果通过有关数据写到网络通信协议上传输给客户端。</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器使用Lex和YACC实现，它能够把一条SQL语句分解为命令字、选项和参数等一系列最基本的语法元素，并将这些存入一个Lex类的结构中，后面查询步骤都会使用这个。规则使用Lex和YACC编写，在使用Bison编译成一个词法解析器。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>&#160; &#160; &#160; &#160;查询优化策略有很多，也可以设计优化算法，高阶程序员也可以自己写查询优化器代替mysql默认的。sql server使用的查询优化策略是基于开销的，根据一系列等价规则为给定查询生成一系列查询评估计划，然后根据关于执行这个查询所需要的关系和操作性能指标数据中选出开销最小的。mysql是混合使用多种优化技术的数据库系统，围绕着选取-投影-联结策略而设计出来的，从整体上能保证生成好的，但不能保证生成最好的查询语句。属于启发式查询优化机制。</p>
<p>&#160; &#160; &#160; &#160;具体的 <strong>选取-投影-联结</strong> 策略 ：即先更具有关的限制条件进行选取（select操作）以减少要处理的元组个数，再进行投影以减少被选取元组里的属性字段的个数，最后根据联结条件生成最终的查询结果。</p>
<ol>
<li>通过计算where子句里的表达式来横向排除多余的数据。</li>
<li>只保留在属性清单里面列出来的，以及在最后执行连接子句时还需要用到的属性字段，其他数据全部排除。</li>
<li>根据联结条件生成最终的查询结果。</li>
</ol>
<p>&#160; &#160; &#160; &#160;优化的第一步检查有关的表是否存在以及用户的访问权限。发现错误返回出错信息并把控制器交给线程管理器，也就是负责监听请求的listener，一旦找到了正确的表，就打开并应用适当的并发控制。<br>&#160; &#160; &#160; &#160;所有的维护和初识化任务完成后，优化器将利用Lex结构对命令中where条件进行处理，其结果作为临时表返回后续步骤做一步处理。如果查询命令里面有UNION操作法，优化器将以循环方式执行完所有的select操作之后再进行下一步。<br>&#160; &#160; &#160; &#160;优化器下一步时执行投影操作。这一步中间结果保存在临时表中且只保存指定列。最后检查Lex结构是否含有Join条件；如果有，调用join优化方法。</p>
<p>&#160; &#160; &#160; &#160;优化内容：对条件表达式进行简化和求值，消除死分支或恒真恒假条件。总之，在执行联结操作之前，优化器会尽量减小查询命令里的条件。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>&#160; &#160; &#160; &#160;查询的具体执行是由一组库方法实现，每种方法复制一种特点操作，例如CRUD。方法都有一个线程对象参数，可以让那些方法直接找到合线程访问相关的内部查询结构，加快执行速度。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>&#160; &#160; &#160; &#160;查询缓存，包括查询语句解析结果和查询结果本身。把频率最高的数据放在内存中能够快速的访问来加快。速度。mysql把数据封装成某个结构（不同对象缓存，用来封装的结构不同），再把数据保存为一个链表。缓存友表缓存（为了减少打开读取和关闭表，frm文件）、记录缓存（减少数据读写频率）、键缓存（缓存各索引的热度）、权限缓存（授权信息，存为先进后出的散列表）、主机名缓存（用栈）、其他类似联结缓存。缓存有自己的监控机制，利用LRU最近最少使用页面靠换策略。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>&#160; &#160; &#160; &#160;这个是重要的一环，也是mysql最佳功能之一。数据库使用者可以根据需求选择不同的存储引擎，存储引擎是关键的一部，也是数据库管理系统最底层的一个，直接与数据库文件进行交互，也就是对数据库进行IO操作。下面介绍mysql提供的一些存储引擎。</p>
<ol>
<li>MyISAM 是默认的存储引擎，它在ISAM上增加了一些新的缓存和索引机制。为了提高访问速度，这类表还普遍使用了数据压缩和索引优化技术。<font color="red">此外还准备了表级的锁定机制。所以适合检索读性能。</font></li>
<li>InnoDB 几乎总是用在需要支持事务的应用程序。支持ACID，InnoDB所有索引采用B-树结构，放在叶子节点里。改进了并发控制，提供行级的锁定。所以对频繁更新，添加，删除等类型数据库是首选存储引擎。</li>
<li>BDB提供页面即的锁。支持散列表、B-树。</li>
<li>内存存储引擎。HEAP表。</li>
<li>合并存储引擎。安装特定规则分成很多小表去存储一个大表，搜索的时候可以去搜索特定的小表而不是搜索体积庞大的大表。但是缺点是：只能用相同的myisam表，不允许替换操作，与普通表相比，使用索引访问效率要低。</li>
<li>档案。把大量数据保存为压缩格式，适合存放和检索那些不需要频繁更新的档案性或历史积累数据。比如系统日志。</li>
<li>联合存储引擎。适合用在分布式环境</li>
<li>群集／NDB 。 在一个高可用性和高性能的环境中使用多个mysql服务器提供数据库服务。</li>
<li>其他的包括：CSV、黑洞、定制的。</li>
</ol>
<p>##小结<br>&#160; &#160; &#160; &#160;了解了一下数据库的类型，和mysql的组成，对RDBS的设计有了大致的了解，那么后面将对在此基础上对mysql优化进行一个深度的学习和总结，并找demo来实战。下面对SQL 语句执行过程进行说明：</p>
<p>   &#160; &#160; &#160; &#160;数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。那么Mysql接受到SQL语句后，又是如何处理的呢？</p>
<p>   &#160; &#160; &#160; &#160;首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices&amp;Utilities）管理。当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：</p>
<ol>
<li><p>由SQL接口丢给后面的解释器（Parser），上面已经说到，解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。</p>
</li>
<li><p>解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。</p>
</li>
<li><p>确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。</p>
</li>
<li><p>这里有几点需要注意：</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;(1)如何缓存查询数据？</p>
<p>&#160; &#160; &#160; &#160;存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。</p>
<p>&#160; &#160; &#160; &#160;(2)buffer与cache的区别？</p>
<p>&#160; &#160; &#160; &#160;从上面的图可以看到，缓存那里实际上有buffer和cache两个，那它们之间是否有什么不同呢？简单的说就是，buffer是写缓存，cache是读缓存。</p>
<p>&#160; &#160; &#160; &#160;(3)如何判断缓存中是否已缓存需要的数据</p>
<p>&#160; &#160; &#160; &#160;这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那么缓存的优势又在哪里？？</p>
<p>&#160; &#160; &#160; &#160;实际上，并非如此，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。</p>
<p>链接参考：<a href="http://pmghong.blog.51cto.com/3221425/1281970" target="_blank" rel="external">mysql原理</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（一）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（一）&quot;&gt;&lt;/a&gt;mysql学习笔记（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（四）</title>
    <link href="http://yoursite.com/2017/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/03/计算机网络学习笔记（四）/</id>
    <published>2017-01-03T10:33:32.000Z</published>
    <updated>2017-05-04T13:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-应用层（四）"><a href="#计算机网络-应用层（四）" class="headerlink" title="计算机网络-应用层（四）"></a>计算机网络-应用层（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;前面已经详细的讨论了计算机网络提供通信服务的过程。接下来讨论这些通信服务是如何提供给应用进程来使用的。每个应用层协议是为了解决某一类应用问题，问题的解决往往是通过位于不同主机的多个应用进程之间的通信和协同工作来完成的。应用层的协议许多都是基于客户服务器方式。即使是对等通信，实质也是一种特殊的客户服务器方式。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7.jpg" alt=""></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><h4 id="DNS的由来"><a href="#DNS的由来" class="headerlink" title="DNS的由来"></a>DNS的由来</h4><p>&#160; &#160; &#160; &#160;DNS是因特网使用的命名系统，用来把便于使用的机器名字转换成IP地址。其实就是名字系统，之所以加上域，是因为命名系统中使用了很多的域。也不适合直接就使用域名系统，因为使用者方便了，机器处理起来就麻烦了，但是机器处理IP就比较方便，固定长度。</p>
<p>&#160; &#160; &#160; &#160;DNS被设计成为一个联机分布式数据库系统，并采用客户端服务器方式，大多数名字在本地进行解析，仅少量的需要在因特网上涌现，所以效率很高。</p>
<p>&#160; &#160; &#160; &#160;域名到IP地址的解析过程的要点如下：当某一个应用程序要把主机名解析为IP地址，该应用进程就跳用解析程序，并称为一个DNS客户，把待解析的域名放在DNS请求报文中，以 <strong>UDP</strong> 用户数据报方式发给本地域名服务器，本地域名服务器在查找域名后，把对应的ip地址放在回答报文中，应用程序获得目的主机的IP地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS中的另一个客户，向其他域名服务器发送查询请求。</p>
<h4 id="DNS的结构"><a href="#DNS的结构" class="headerlink" title="DNS的结构"></a>DNS的结构</h4><p>&#160; &#160; &#160; &#160;mail.cctv.com中mail、cctv、com分别为三级域名、二级域名、顶级域名。每个不要超过63个字符，其实最好不要超过12个方便记忆。不区分大小写，总共不超过255个。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493828954099&amp;di=d72c9e6fbec5a560b82ad6cce92d2359&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.eeing.com%2FUploadFile%2F20137810550682.jpg" alt=""></p>
<h3 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><h4 id="FTP和NFS"><a href="#FTP和NFS" class="headerlink" title="FTP和NFS"></a>FTP和NFS</h4><p>&#160; &#160; &#160; &#160;FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有的存取权限，它屏蔽了各计算机系统的细节，因而适合在于异构网络中任意计算机之间传送文件。分别有基于TCP和UDP的FTP，这是文件共享协议中的一大类，即复制整个文件；另外一类是联机访问，意味着允许多个程序同时对一个文件进行存取。和数据库系统不同的是用户不需要调用一个特殊的客户进程，而是由操作系统提供对原地共享文件进行访问的服务。</p>
<p>&#160; &#160; &#160; &#160;FTP主要功能是消除或减少在不同操作系统下处理文件的不兼容性。</p>
<p>&#160; &#160; &#160; &#160;FTP并非对所有数据传输都是最佳的，例如计算机A上运行的应用程序要在原地计算机B的很大一个文件末尾添加一行信息，使用FTP来回传很花时间。这时NFS网络文件系统就起作用了，NFS允许应用进程打开一个原地文件，并能在该文件的特定位置开始读写数据，在网络上传送的只是少量的修改数据。</p>
<h4 id="TFTP简单文件传送协议"><a href="#TFTP简单文件传送协议" class="headerlink" title="TFTP简单文件传送协议"></a>TFTP简单文件传送协议</h4><p>&#160; &#160; &#160; &#160;属于TCP／IP协议族，很小但是抑郁实现的文件传送协议。使用UDP协议，工作模式很像停止等待协议。端口号为69.</p>
<h4 id="远程终端协议-TELENT"><a href="#远程终端协议-TELENT" class="headerlink" title="远程终端协议 TELENT"></a>远程终端协议 TELENT</h4><p>&#160; &#160; &#160; &#160;用户用TELENT就可以在所在地使用TCP连接注册到远地的另一个主机上。其中有NVT网络虚拟终端，屏蔽了操作系统的差异。port：23</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>&#160; &#160; &#160; &#160;万维网是一个大规模联机式的信息储藏所，英文简称Web，万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，主动按序获取丰富的信息。1993年第一个图形界面的浏览器开发成功，叫做Mosaic，万维网是一个分布式的超媒体系统，它是超文本系统的扩展，就是所有网站的集合，用浏览器来访问其他站点的网站。万维网要解决的问题如下：</p>
<ol>
<li>怎么标志分布在整个因特网上的万维网文档？</li>
<li>用什么用的协议来实现万维网上各种链接？</li>
<li>怎样使用不同作战创作的不同风格的万维网文档都能在因特网上的各种主机上显示出来，同时使用户清楚知道什么地方存在着链接？</li>
<li>怎样使用户能够很方便的找到所需的信息？</li>
</ol>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>&#160; &#160; &#160; &#160;为了解决第一个问题，万维网使用统一资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内唯一标识符。</p>
<p>&#160; &#160; &#160; &#160;为了解决第二个问题，我们采用HTTP超文本传送协议，是一个应用层协议，使用TCP链接进行可靠的传送。</p>
<p>&#160; &#160; &#160; &#160;为了解决第三个问题，万维网使用HTML超文本标记语言，使设计者很方便地使用链接从本页面的某处链接到因特网的任何一个万维网页面</p>
<p>&#160; &#160; &#160; &#160;第四个问题，搜索工具应运而生，帮助我们在万维网上查找自己所需的信息。</p>
<p>&#160; &#160; &#160; &#160;下面看看在此实现思路基础上的具体的实现方式。</p>
<h4 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h4><p>&#160; &#160; &#160; &#160;一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。其中协议一般是http、https、ftp等，主机是域名，或者主机的外网ip，端口和路径有时可以省略。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>&#160; &#160; &#160; &#160;HTTP协议定义了浏览器即万维网客户进程怎么样向万维网服务器请求万维网文档，以及服务器怎么样把文档传送给浏览器。HTTP是面向事务的应用层协议。通常基于TCP协议的，每个万维网网点都有一个服务器进程，不断监听TCP的端口80，以便发现是否有浏览器向他发出连接请求。一旦监听到建立TCP连接，通信结束后释放。交互必须遵循HTTP，它规定每次交互都由一个ASCII码串构成的请求和一个类MIME的响应。</p>
<p>tips：浏览器敲入百度网址到响应的过程。</p>
<h5 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h5><p>&#160; &#160; &#160; &#160;参考这篇博文：<a href="http://blog.csdn.net/zhangliang_571/article/details/23508953" target="_blank" rel="external">http请求报文和响应报文</a>。请求报文中请求方法Get和Post的区别，区别如下列出，响应报文中状态行有200 OK，404等等。这些参考博文，写的很好，分析清楚。</p>
<h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><p>1.提交方式</p>
<p>&#160; &#160; &#160; &#160;GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>  &#160; &#160; &#160; &#160;POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>  &#160; &#160; &#160; &#160;因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p>2.传输数据的大小：</p>
<p>   &#160; &#160; &#160; &#160;首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>
<p>   &#160; &#160; &#160; &#160;GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>   &#160; &#160; &#160; &#160;因此对于GET提交时，传输数据就会受到URL长度的限制。</p>
<p>   &#160; &#160; &#160; &#160;POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3.安全性：</p>
<p>&#160; &#160; &#160; &#160;POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>
<h6 id="常见响应"><a href="#常见响应" class="headerlink" title="常见响应"></a>常见响应</h6><p>200 OK：客户端请求成功。</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
<p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
<p>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</p>
<p>500 Internal Server Error：服务器发生不可预期的错误。</p>
<p>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>&#160; &#160; &#160; &#160;分为静态html和动态html还有活动万维网文档。静态文档是固定的html，只用于显示。</p>
<p>&#160; &#160; &#160; &#160;动态文档就是指是文档内容在浏览器访问万维网时才由应用程序动态创建。所以我们需要增加一个应用程序来处理浏览器发来的数据，并动态创建文档。还要增加一个机制，用来使万维网服务器将浏览器发来的数据传送给这个应用程序，这个就叫做通用网关接口CGI。后来称为CGI程序，可以是使用Perl、REXX，JS，C，C++等语言，脚本语言和编程语言都有，为了方便找到CGI程序，都放在cgi／bin目录下。</p>
<p>&#160; &#160; &#160; &#160;后来动态文档也不能满足了，因为动态文档一旦建立，它所包含的信息内容页固定下来了，像动画这类的效果也无法提供，后来出现服务器推送，服务器不断运行和动态文档相关联的应用，定期更新信息，缺点是为了满足很多客户的请求，服务器就要运行很多推送程序。太多导致带宽不够，网络延时也很大。另一种就是活动文档技术，每当浏览器请求一个活动文档，服务器就返回一段程序副本，使程序在浏览器端进行，像Java的applet应用，html中嵌入一个java小程序。</p>
<h4 id="信息检索系统"><a href="#信息检索系统" class="headerlink" title="信息检索系统"></a>信息检索系统</h4><p>&#160; &#160; &#160; &#160;搜索引擎，全文检索与分类目录搜索。垂直搜索引擎，元搜索引擎。</p>
<p>&#160; &#160; &#160; &#160;谷歌搜索核心技术就是PageRank，最搜索出来的结果按重要性进行排序。Google 论文老三篇 GFS, MapReduce, BigTable 不再赘述，近年 Google 在这些方面的研发和进步没有停滞甚至在加快。当然百度也在努力追赶，百度不仅使用 Hadoop, 而且基于 Hadoop 做了大量改进和扩展，并贡献回 Hadoop 开源社区。后面准备进行一些爬虫的实践。</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="SMTP、POP3、IMAP"><a href="#SMTP、POP3、IMAP" class="headerlink" title="SMTP、POP3、IMAP"></a>SMTP、POP3、IMAP</h4><p>&#160; &#160; &#160; &#160;简单邮件传送协议，只能传送可打印的7位ASCII码邮件，后来又出现MIME通用互联网邮件扩充，后来还进行了修订。</p>
<p>&#160; &#160; &#160; &#160;电子邮件系统应该具有三个重要的组成构件，用户代理，邮件服务器，以及邮件发送协议。区别：IMAP在服务器保存副本。参考博文：<a href="http://blog.csdn.net/ladybai/article/details/509882050" target="_blank" rel="external">电子邮件协议之SMTP、POP3和IMAP</a>。</p>
<h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><p>&#160; &#160; &#160; &#160;基于UDP，为了把协议软件做成通用的和便于移植，协议软件的编写者不会把所有细节都固定在源代码中。相反会把协议软件参数化。前身是BOOTP引导程序协议，需要人工参与，DHCP是即插即用，对服务器和客户端都适用。</p>
<h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><p>被管对象上运行的SNMP服务器不断监听来自管理站的SNMP客户端请求，一旦发现立即返回管理站所需信息，或者执行某个动作。</p>
<h3 id="跨越网络的应用进程通信"><a href="#跨越网络的应用进程通信" class="headerlink" title="跨越网络的应用进程通信"></a>跨越网络的应用进程通信</h3><p>当很多的应用层协议还不能满足我们的需求，于是开放了相关的系统调用和应用程序编程接口，即网络socket编程。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-应用层（四）&quot;&gt;&lt;a href=&quot;#计算机网络-应用层（四）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-应用层（四）&quot;&gt;&lt;/a&gt;计算机网络-应用层（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;前面已经详细的讨论了计算机网络提供通信服务的过程。接下来讨论这些通信服务是如何提供给应用进程来使用的。每个应用层协议是为了解决某一类应用问题，问题的解决往往是通过位于不同主机的多个应用进程之间的通信和协同工作来完成的。应用层的协议许多都是基于客户服务器方式。即使是对等通信，实质也是一种特殊的客户服务器方式。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（三）</title>
    <link href="http://yoursite.com/2016/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/22/计算机网络学习笔记（三）/</id>
    <published>2016-12-22T00:09:00.000Z</published>
    <updated>2017-05-10T02:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-运输层（三）"><a href="#计算机网络-运输层（三）" class="headerlink" title="计算机网络-运输层（三）"></a>计算机网络-运输层（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;运输层是整个网络体系结构中的关键层次。TCP／IP体系中运输层最重要的两个协议：UDP和TCP。运输层是在主机的协议栈中的，TCP是保证可靠的交付，UDP是尽最大努力的交付。重点是TCP的各种机制是如何保证可靠交付，在面向连接的可靠服务、流量控制、拥塞控制等方面作出了何种的努力，以及TCP连接的三次握手和断开连接的四次挥手以及为什么这样设计。本节篇幅很长，多图，内容很关键。</p>
  <a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>&#160; &#160; &#160; &#160;从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它是面向通信部分的最高层，也是用户功能的最低层。当网络的边缘部分的两个主机利用网络的核心部分的功能进行端到端的通信时，<font color="red">只有主机的协议栈才有运输层</font>，而网络核心部分中的路由器在转发分组的时候都只用到了下三层的功能。<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;从上图可知：从IP层来说，通信的是主机，但是两个主机之间通信的说法还不够清楚，这是因为，真正进行通信的实体是两个主机上的进程，从运输层来看并不是主机而是主机上的进程。</p>
<p>&#160; &#160; &#160; &#160;运输层提供应用进程之间的逻辑通信。意思是：运输层之间的通信好像是沿着水平方向传送数据，但实际并没有物理连接。数据在多个层次之间传送。（网络层是主机之间的逻辑通信），如之前所讲运输层还进行差错检测等，运输层向高层屏蔽了下面网络核心的细节，它使应用进程看见的好像是两个运输实体之间一条端到端的逻辑通信，当然运输层协议不同对上层的表现也很大不同。</p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><h4 id="概述和相关应用"><a href="#概述和相关应用" class="headerlink" title="概述和相关应用"></a>概述和相关应用</h4><p>&#160; &#160; &#160; &#160;运输层的两个主要协议：用户数据报协议UDP和传输控制协议TCP。UDP面向无连接，不提供可靠交付，但是却是一种最有效的工作方式。TCP提供面向连接的，可靠的服务。TCP不提供多播服务，依赖额外的开销进行，确认、流量控制、计时器、连接管理等，协议数据单元的首部变大，也占用了很多处理机资源。下面给出两种协议在应用层的相关应用。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%BA%94%E7%94%A8.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;两者之间的区别如下：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20151018103115179" alt=""></p>
<h4 id="端口的由来"><a href="#端口的由来" class="headerlink" title="端口的由来"></a>端口的由来</h4><p>&#160; &#160; &#160; &#160;运输层和应用层采用了复用和分用，应用层所有的应用进程都可以利用运输层传到IP层，运输层从IP层收到数据后在指定某个进程交付通信。现在重点是给每个应用进程赋予一个非常明确的标志。然而不同的操作系统有不同的进程标识符（一个不大的整数），所以TCP／IP体系对进程统一标志。即使是这样，还存在问题，比如要和因特网上的某个邮件服务器通信，我在不知道对方的进程没法完成通信，显然是不科学的，解决方法是：<font color="red">在运输层使用<em>协议端口号</em>，虽然说通信终点是应用进程，但是我们只用把数据送到指定端口，剩下来的工作交给TCP去完成。</font>常见的端口号如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7.jpg" alt=""></p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.无连接，减小了开销和时延。</p>
<p>2.最大努力交付，不保证可靠交付，不需要维持复杂的状态连接表。</p>
<p>3.面向报文，对于应用层的报文，只添加首部，保留边界，一次性交付，所以应用程序要选择合适大小的报文，太长或太短都会降低IP层效率，长了会分片，短了首部相对就太长。</p>
<p>4.没有拥塞控制，支持一对一，一对多，多对多的交互通信，首部开销小。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/UDP.png" alt=""></p>
<h5 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h5><p>&#160; &#160; &#160; &#160;UDP首部较为简单，包含四个部分，其中伪首部是计算检验和时临时添加，并不向上或向下传递，如下图：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png" alt=""></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.面向连接。先建立连接在通信，最后释放连接。就像打电话一样。</p>
<p>2.连接只能是一对一点对点。</p>
<p>3.提供可靠交付，无差错、不丢失、不重复、按序到达。</p>
<p>4.全双工通信，双方任何时候都能发送，两端都设有发送和接收缓存。</p>
<p>5.面向字节流。TCP并不知道所传数据的含义，统一当成无结构的字节流，存在发送方发送10个数据块，接收方只用了4个数据块就把收到的字节流交付给应用层。当然接收方的应用程序必须有能力识别收到的字节流并还原成应用层数据。</p>
<h4 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h4><h5 id="停止等待协议–应用：ARQ自动重传请求"><a href="#停止等待协议–应用：ARQ自动重传请求" class="headerlink" title="停止等待协议–应用：ARQ自动重传请求"></a>停止等待协议–应用：ARQ自动重传请求</h5><p>&#160; &#160; &#160; &#160;每发送完一个分组就停止发送，等待对方确认，收到确认在发送下一个分组。</p>
<p>&#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;如果出现差错，就要<font color="red">超时重传</font>，为了实现这一功能，需要做以下工作：</p>
<p>&#160; &#160; &#160; &#160;1.设计超时计时器，且超时时间比平均往返时间更长。（超时时间设定是个复杂问题）</p>
<p>&#160; &#160; &#160; &#160;2.必须保留已发送分组的副本。</p>
<p>&#160; &#160; &#160; &#160;3.对发送的分组编号，才知道哪个没发送成功。</p>
<p>&#160; &#160; &#160; &#160;4.确认丢失和确认迟到。也许超时之后，接收方还是收到了，这时候就会丢弃重复的分组，进行确认，分为确认丢失和确认迟到，所以说，发送方总是会收到确认，如果总是收不到说明通信线路太差不能通信。</p>
<h5 id="TCP首部格式（重点）"><a href="#TCP首部格式（重点）" class="headerlink" title="TCP首部格式（重点）"></a><font color="red">TCP首部格式（重点）</font></h5><p>&#160; &#160; &#160; &#160;虽然TCP是面向字节流的，但是TCP传送的数据单元却是报文段。20+4N的格式，20是固定的，根据需要以4N字节增加。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/TCP%E9%A6%96%E9%83%A8.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;</p>
<ol>
<li><p>源端口和目的端口，各占2个字节，分别写入源端口号和目的端口号。</p>
</li>
<li><p>序号 占4个字节，范围时0到2^32-1，采用mod 2^32运算。</p>
</li>
<li><p>确认号 期望收到对方下一个报文段的第一个数据字节的序号。</p>
</li>
<li><p>数据偏移  占4位，指定TCP报文段的首部长度，4位二进制最大时十进制15，以4歌字节为计算单位，所以，首部最大长度时60，即选项长度最大60。</p>
</li>
<li><p>保留为今后使用，预留字段6位，目前为0。</p>
</li>
<li><p>紧急URG URG为1则高优先级传送，而不需要排队，和紧急指针配合使用。</p>
</li>
<li>确认ACK 仅等于1才有效，确认连接后所有传送的报文段都必须把ACK置为1。</li>
<li>推送 PSH 希望立即收到对方响应，这时要把PSH置为1，立即创建报文传出去，接收方不在进入缓存而直接进入应用进程。但很少使用。</li>
<li>复位RST 当RST=1时，表明TCP连接出现严重差错需要立即释放。</li>
<li>同步SYN 当SYN=1而ACK=0时表明这是一个连接请求，SYN置为1表示这是一个连接请求或者连接接受报文。</li>
<li>终止FIN 用来释放一个连接。置为1时释放连接。</li>
<li>窗口 占2个字节，所以窗口值是0到2^16-1之间的整数，窗口值作为接收方让发送方设置其发送窗口的依据。表明现在允许对方发送的数据量，动态变化。</li>
<li>检验和 2个字节，检验的范围包括首部和数据这两部分。同样和UDP一样要加上12个字节的伪首部，伪首部的协议号17修改为6（TCP的协议号），长度字段，如果使用ipv6相应地方也要改变。</li>
<li>紧急指针 2个字节，仅在URG=1才有意义，指定本报文段中的紧急数据所在位置。</li>
<li>选项 长度可变，最多40，4个为基本单位。选项中有窗口扩大、时间戳、选择确认等。</li>
</ol>
<h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><ol>
<li><p>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>数据合理分片和排序：<br>UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.<br>tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</p>
</li>
<li><p>流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
</li>
<li><p>拥塞控制：当网络拥塞时，减少数据的发送。</p>
</li>
</ol>
<p>还可以参考这个博客：<a href="http://blog.csdn.net/shawjan/article/details/45117945" target="_blank" rel="external">如何讲清楚TCP的可靠性传输</a>。</p>
<h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><h5 id="为什么使用窗口"><a href="#为什么使用窗口" class="headerlink" title="为什么使用窗口"></a>为什么使用窗口</h5><p>&#160; &#160; &#160; &#160;因为发送端希望在收到确认前，继续发送其它报文段。比如说在收到0号报文的确认前还发出了1-3号的报文，这样提高了信道的利用率。但可以想想，0-4发出去后可能要重传，所以需要一个缓冲区维护这些报文，所以就有了窗口。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190409249-1100672672.png" alt=""></p>
<h5 id="窗口怎么实现"><a href="#窗口怎么实现" class="headerlink" title="窗口怎么实现"></a>窗口怎么实现</h5><h6 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h6><p>&#160; &#160; &#160; &#160;接收窗口”大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。图中，接收窗口是31~50，大小为20。</p>
<ol>
<li>在接收窗口中，黑色的表示已收到的数据，白色的表示未收到的数据。</li>
<li>当收到窗口左边的数据，如27，则丢弃，因为这部分已经交付给主机；</li>
<li>当收到窗口左边的数据，如52，则丢弃，因为还没轮到它；</li>
<li>当收到已收到的窗口中的数据，如32，丢弃；</li>
<li>当收到未收到的窗口中的数据，如35，缓存在窗口中。</li>
</ol>
<p>tips：按序到达的、但尚未被接收应用程序读取的数据和未按序到达的数据</p>
<p>　　<br>　　<img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190456874-770659297.png" alt=""></p>
<h6 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h6><p>发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制，暂时可以理解为swnd= rwnd =20。图中分为四个区段，其中P1到P3是发送窗口。发送窗口以字节为单位。为了方便画图，图中展示得像以报文为单位一样。但这不影响理解。</p>
<p><img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190555749-856898339.png" alt=""></p>
<p>tips：发送应用程序传送给发送方TCP准备发送的数据和TCP已经发送出但尚未收到确认的数据</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>强调以下三点：</p>
<ol>
<li>虽然A的发送窗口是根据B接受窗口设置的，但在同一时刻，A和B的窗口大小并不一定一样，这是因为传送需要一个时延而且是不确定的。发送方A还可能根据当时的网络拥塞减小窗口数值。</li>
<li>对于不按序到达的数据该如何处理，TCP标准并无明确规定，如果接收方一律丢弃，那么管理相对简单，但是对网络资源利用率下降，所以通常是对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到后再交付给上层进程。</li>
<li>TCP要求接收方必须有 <strong>累积确认</strong> 的功能，这样可以减少传输开销。因为只确认收到最后一个分组代表之前的全都正确传输。可以在合适的时候发送确认，不会导致不必要的重传，TCP规定确认推迟时间不超过0.5秒。</li>
</ol>
<h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><p>&#160; &#160; &#160; &#160;TCP采用了一种自适应的算法，它记录RTT，加权平均的RTTs，超时重传时间：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;RTO=RTTs+4*RTTD</p>
<p>&#160; &#160; &#160; &#160;RTTD第一次测量时为RDDs的一半，在使用下式计算甲醛平均的RTTD：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160;RTTD=（1-x）*（旧的加权平均RTTD）+x|RTTs-新的RTT|</p>
<p>&#160; &#160; &#160;&#160;其中x建议为0.25.</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p> &#160; &#160; &#160;&#160;有一种情况可能导致死锁。B向A发送零窗口报文段，然后就有缓存空间了，又向A发送一定长度的报文，但是A收到零窗口报文之后一直等待非零窗口的通知，B传的数据就丢失了，A和B一直都在等待，出现死锁。</p>
<p> &#160; &#160; &#160;&#160;解决：TCP为每个连接设置一个持续计时器。只要连接一方接收到零窗口的通知，就启动，若在设置时间内到期，就发送一个零窗口一个字节的探测报文段，对方给出现在的窗口值。</p>
<p> &#160; &#160; &#160;&#160;合适时间确认的选择：接收方等待一段时间或者等到缓存已有一半空闲空间。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>&#160;&#160;&#160;&#160; 网络资源（链路容量即带宽、交换节点种缓存和处理机）呈现供应不足，整个网络性能就会变坏。吞吐量随着负荷增加而下降。这就是拥塞。</p>
<p>&#160;&#160;&#160;&#160;拥塞控制和流量控制息息相关，但也有一些差别，拥塞控制是防止过多的数据注入到网络导致路由器或者链路的过载，是全局性的把控，流量控制往往只点到点通信量的控制，是端到端的问题。</p>
<p>&#160;&#160;&#160;&#160;几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复等还有相关改进。</p>
<h3 id="TCP连接建立和释放"><a href="#TCP连接建立和释放" class="headerlink" title="TCP连接建立和释放"></a>TCP连接建立和释放</h3><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>&#160;&#160;&#160;所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<img src="http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png" alt=""></p>
<ol>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
</ol>
<ol>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
</ol>
<ol>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ol>
<h4 id="释放连接"><a href="#释放连接" class="headerlink" title="释放连接"></a>释放连接</h4><p>&#160;&#160;&#160;所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<img src="http://opb7t58xj.bkt.clouddn.com/huishou.png" alt=""></p>
<ol>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
</ol>
<ol>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li>
</ol>
<ol>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
</ol>
<ol>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ol>
<p>&#160;&#160;&#160;上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<img src="http://opb7t58xj.bkt.clouddn.com/tongshihuishou.png" alt=""></p>
<font color="red">tips：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</font>

<p>  &#160;&#160;&#160;&#160; 原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<h4 id="为什么需要“三次握手”"><a href="#为什么需要“三次握手”" class="headerlink" title="为什么需要“三次握手”"></a>为什么需要“三次握手”</h4><p> &#160;&#160;&#160;&#160;在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。</p>
<p>   &#160;&#160;&#160;&#160;谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>
<p>参考：1.<a href="http://blog.csdn.net/renzhenhuai/article/details/12105457" target="_blank" rel="external">什么是三次握手和四次挥手</a>。2.<a href="http://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="external">为什么要三次握手和四次挥手</a>。</p>
<h3 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h3><p>&#160; &#160; &#160; &#160;Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>&#160; &#160; &#160; &#160;注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.my.csdn.net/uploads/201204/10/1334044170_5136.jpg" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-运输层（三）&quot;&gt;&lt;a href=&quot;#计算机网络-运输层（三）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-运输层（三）&quot;&gt;&lt;/a&gt;计算机网络-运输层（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;运输层是整个网络体系结构中的关键层次。TCP／IP体系中运输层最重要的两个协议：UDP和TCP。运输层是在主机的协议栈中的，TCP是保证可靠的交付，UDP是尽最大努力的交付。重点是TCP的各种机制是如何保证可靠交付，在面向连接的可靠服务、流量控制、拥塞控制等方面作出了何种的努力，以及TCP连接的三次握手和断开连接的四次挥手以及为什么这样设计。本节篇幅很长，多图，内容很关键。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
