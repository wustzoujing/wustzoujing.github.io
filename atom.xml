<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>街灯晚餐的个人博客</title>
  <subtitle>我的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-22T12:16:58.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次JAVA爬虫之旅</title>
    <link href="http://yoursite.com/2017/05/22/%E4%B8%80%E6%AC%A1JAVA%E7%88%AC%E8%99%AB%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2017/05/22/一次JAVA爬虫之旅/</id>
    <published>2017-05-22T12:14:05.000Z</published>
    <updated>2017-05-22T12:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次JAVA爬虫之旅"><a href="#一次JAVA爬虫之旅" class="headerlink" title="一次JAVA爬虫之旅"></a>一次JAVA爬虫之旅</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;好久就想做一下爬虫，最近终于完成了。爬了知乎用户信息，现在知乎确实正规了好多，各种反爬虫机制，遇到了不少坑，还好都克服了，现在来记录下这个过程，和把结果展示一下。</p>
  <a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一次JAVA爬虫之旅&quot;&gt;&lt;a href=&quot;#一次JAVA爬虫之旅&quot; class=&quot;headerlink&quot; title=&quot;一次JAVA爬虫之旅&quot;&gt;&lt;/a&gt;一次JAVA爬虫之旅&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;好久就想做一下爬虫，最近终于完成了。爬了知乎用户信息，现在知乎确实正规了好多，各种反爬虫机制，遇到了不少坑，还好都克服了，现在来记录下这个过程，和把结果展示一下。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（一）——树</title>
    <link href="http://yoursite.com/2017/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91/"/>
    <id>http://yoursite.com/2017/05/11/数据结构（一）——树/</id>
    <published>2017-05-11T07:51:41.000Z</published>
    <updated>2017-05-22T12:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构（一）——树"><a href="#数据结构（一）——树" class="headerlink" title="数据结构（一）——树"></a>数据结构（一）——树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在数据结构的学习当中，看到后面树，图，散列的时候已经有点难度，理解的较浅，学习完后面的知识，就发现，这些数据结构和经典算法都用在了一些常用工具的实现原理上，所以需要把这些知识总结一下,今天重点说下树。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;在算法题的做题当中就已经学习了简单的数据结构，hashmap中又用到散列，为了理解 TreeMap 的底层实现，必须先介绍排序二叉树和平衡二叉树，然后继续介绍红黑树。平衡二叉树和红黑树又是一种特殊的二叉排序树。二叉排序树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。mysql索引也是b+，b-树的原理。这里总结一下：</p>
<h2 id="二叉排序树／二叉查找树／二叉搜索树／BST"><a href="#二叉排序树／二叉查找树／二叉搜索树／BST" class="headerlink" title="二叉排序树／二叉查找树／二叉搜索树／BST"></a>二叉排序树／二叉查找树／二叉搜索树／BST</h2><p>&#160; &#160; &#160; &#160;标题已经说明它的名称之多，我们先说下排序二叉树特性：</p>
<ol>
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值</li>
</ol>
<ol>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值</li>
</ol>
<ol>
<li>它的左、右子树也分别为排序二叉树</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>&#160; &#160; &#160; &#160;已知一个关键字值为key的结点s，若将其插入到二叉排序树中，只要保证插入后仍符合二叉排序树的定义即可。插入可以用下面的方法进行：</p>
<ol>
<li>若二叉排序树是空树，则key成为二叉排序树的根； </li>
<li>若二叉排序树非空，则将key与二叉排序树的根进行比较。如果key的值等于根结点的值，则停止插入；如果key的值小于根结点的值，则将key插入左子树，如果key的值大于根结点的值，则将key插入右子树。</li>
<li>重复步骤2，直到找到合适的插入位置。</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>&#160; &#160; &#160; &#160;当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序二叉树，程序必须对该排序二叉树进行维护。维护可分为如下几种情况：</p>
<ol>
<li>被删除的节点是叶子节点，则只需将它从其父节点中删除即可。</li>
<li>如果待删除节点左子树存在右子树不存在，或者左子树不存在右子树存在。直接将其子树中存在的一边候补上来即可。</li>
<li>若被删除节点 p 的左、右子树均非空，有两种做法：一：将 pL 设为 p 的父节点 q 的左或右子节点（取决于 p 是其父节点 q 的左、右子节点），将 pR 设为 p 节点的中序前趋节点 s 的右子节点（s 是 pL 最右下的节点，也就是 pL 子树中最大的节点）。二：以 p 节点的中序前趋或后继替代 p 所指节点，然后再从原排序二叉树中删去中序前趋或后继节点即可。（也就是用大于 p 的最小节点或小于 p 的最大节点代替 p 节点即可）。</li>
</ol>
<p>&#160; &#160; &#160; &#160;下面我们结合图例来说明。当是左子树右子树只有一个存在时如下图：<br><img src="http://img.blog.csdn.net/20140210085705265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="http://img.blog.csdn.net/20140210085800921" alt=""></p>
<p>&#160; &#160; &#160; &#160;如果左右子树都存在：</p>
<p>被删除节点左右子节点不为空的情形，采用到是第一种方式维护：<br><img src="http://img.blog.csdn.net/20140210085841468" alt=""></p>
<p>被删除节点左右子节点不为空的情形，采用到是第二种方式维护：<br><img src="http://img.blog.csdn.net/20140210085916093" alt=""></p>
<p>&#160; &#160; &#160; &#160;TreeMap 删除节点采用上图第二种方式的情形进行维护——也就是用被删除节点的右子树中最小节点与被删节点交换的方式进行维护。</p>
<p>&#160; &#160; &#160; &#160;在使用第二种方式进行维护时，如果使用前驱节点代替被删除的节点，则前驱节点可能还存在左子树（因为前驱节点是根节点左子树中最右边的节点），而如果是后继节点的话，这个后继节点可能还存在右子树。他们的处理方法相同，直接将子树移上去即可。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">一定要理解，无论是前驱还是后继节点，不可能同时具有左子树或右子树，这就为删除替代节点后的操作带来了方便。</font>如下图：</p>
<p><img src="http://img.blog.csdn.net/20140414215015765" alt=""></p>
<p>tip:直接前驱后继是按中序序列化而来。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>&#160; &#160; &#160; &#160;从二叉排序树中进行查找时，根据树的性质，节点的左子树必定小于根节点，右子树必定大于根结点。如果查找的节点值小于根节点，则进入左子树，大于进入右子树，重复这个比较步骤直到找到这个节点或者这个节点不存在。 </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&#160; &#160; &#160; &#160;二叉树以链式方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需要修改链接指针节课。插入删除的时间性能比较好。而丢与二拆排序树的查找，走的就是从根节点到要查找的节点的路径，其比较次数等于给定值的节点在二叉排序树的层数。极端情况，最少为1次，即根节点就是要找的节点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形状是不确定的。可能出现以下情况，而二叉平衡树就不会：</p>
<p><img src="http://img.blog.csdn.net/20140414214957765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ3l1bnl1bjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="二叉平衡树／AVL"><a href="#二叉平衡树／AVL" class="headerlink" title="二叉平衡树／AVL"></a>二叉平衡树／AVL</h2><p>&#160; &#160; &#160; &#160;ALV树中左右子树的高度差值最大不超过1。树在查找、插入和删除时平均和最坏的情况下都是O(logn)。在一颗二叉搜索树查找一个值的平均时间复杂度为log(n)，但是若查找树的所有的节点向一边倾斜，这时候的查找就退化为线性查找，复杂度为n。为了获得更高的查找效率，就有了AVL树的概念，对于一颗非平衡的AVL树，可以通过旋转变换为AVL树。</p>
<p>&#160; &#160; &#160; &#160;由于平衡二叉树也是排序二叉树，所以使用二叉树的插入、删除和查找操作即可。只是在操作完成后，为了下次能够保持一个好的检索效率，也为了防止这个链表退化为普通链表，则需要对树进行旋转。旋转可以再次达到平衡。主要包括：左旋转、右旋转、左右旋转、右左旋转。</p>
<h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><p>&#160; &#160; &#160; &#160;插入一个新节点到根节点的左子树的左子树，导致根节点的平衡因子由1变为2.需要 右 旋转来解决。</p>
<p><img src="http://img.blog.csdn.net/20140226092057593" alt=""></p>
<h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><p>插入一个新节点到根节点的左子树的左子树，导致根节点的平衡因子由1插入一个新节点到根节点的左子树的右子树，导致根节点的平衡因子由1变为2.需要先左旋后右旋转来解决。</p>
<p><img src="http://img.blog.csdn.net/20140226092128906" alt=""></p>
<h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p>&#160; &#160; &#160; &#160;插入一个新节点到根节点的右子树的 右 子树，导致根节点的平衡因子由1变为2.需要 左 旋转来解决。</p>
<h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><p>&#160; &#160; &#160; &#160;插入一个新节点到根节点的 右 子树的左子树，导致根节点的平衡因子由1变为2.需要先 右 旋后 左 旋转来解决。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>&#160; &#160; &#160; &#160;在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。<br>完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>&#160; &#160; &#160; &#160;我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。</p>
<h2 id="红黑树／RBT"><a href="#红黑树／RBT" class="headerlink" title="红黑树／RBT"></a>红黑树／RBT</h2><p>&#160; &#160; &#160; &#160;红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型地，JDK 提供的集合类 TreeMap 本身就是一个红黑树的实现。排序二叉树的深度直接影响了检索的性能，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。但是红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。<br>红黑树在原有的排序二叉树增加了如下几个要求：</p>
<p>性质 1：每个节点要么是红色，要么是黑色。</p>
<p>性质 2：根节点永远是黑色的。</p>
<p>性质 3：所有的叶节点都是空节点（即 nil），并且是黑色的。</p>
<p>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）。</p>
<p>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<p><img src="http://img.my.csdn.net/uploads/201212/12/1355319681_6107.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;之前我们了解了二叉查找树的插入，接下来，咱们便来具体了解下红黑树的插入操作。红黑树的插入相当于在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。<br>下面来看一下几个约定：</p>
<p>&#160; &#160; &#160; &#160;（1）性质 3 中指定红黑树的每个叶子节点都是空节点，而且叶子节点都是黑色 Java 实现的红黑树将使用 null 来代表，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。非叶子节点，也就是非null节点称为红黑树中的儿子节点。</p>
<p>&#160; &#160; &#160; &#160;（2） 红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度”。</p>
<p>&#160; &#160; &#160; &#160;对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。</p>
<p>&#160; &#160; &#160; &#160;假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 - 黑节点 - 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 - 红节点 - 黑节点 - 红节点 - 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，红黑树中最长路径就是一条红黑交替的路径。</p>
<p>&#160; &#160; &#160; &#160;红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。  </p>
<h2 id="B-Tree／平衡多路搜索树"><a href="#B-Tree／平衡多路搜索树" class="headerlink" title="B-Tree／平衡多路搜索树"></a>B-Tree／平衡多路搜索树</h2><p>&#160; &#160; &#160; &#160;性质如下，图片显示M=3时的例子：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG" alt=""></p>
<p>&#160; &#160; &#160; &#160;B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<h3 id="B-树的特性："><a href="#B-树的特性：" class="headerlink" title="B-树的特性："></a>B-树的特性：</h3><ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>&#160; &#160; &#160; &#160;由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/0.JPG" alt=""></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>&#160; &#160; &#160; &#160;B+树是B-树的变体，也是一种多路搜索树：</p>
<ol>
<li>其定义基本与B-树同，除了：</li>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG" alt=""></p>
<p>&#160; &#160; &#160; &#160;B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<h3 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h3><ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<p>&#160; &#160; &#160; &#160;b+tree每层节点直接还有链表连接，增加局部和范围访问效率,尾部还有聚集和非聚集区别，这数据结构很适合存储引擎</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构（一）——树&quot;&gt;&lt;a href=&quot;#数据结构（一）——树&quot; class=&quot;headerlink&quot; title=&quot;数据结构（一）——树&quot;&gt;&lt;/a&gt;数据结构（一）——树&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在数据结构的学习当中，看到后面树，图，散列的时候已经有点难度，理解的较浅，学习完后面的知识，就发现，这些数据结构和经典算法都用在了一些常用工具的实现原理上，所以需要把这些知识总结一下,今天重点说下树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>实现简易web服务器和web浏览器</title>
    <link href="http://yoursite.com/2017/04/02/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cweb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/04/02/web服务器和web浏览器的实现原理/</id>
    <published>2017-04-02T04:31:39.000Z</published>
    <updated>2017-05-23T05:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web服务器和web浏览器的实现原理"><a href="#web服务器和web浏览器的实现原理" class="headerlink" title="web服务器和web浏览器的实现原理"></a>web服务器和web浏览器的实现原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;那么，既然是网络通信。对应于Java当中来说，就自然离不开Socket与IO流。其实这也正是Web服务器与浏览器的基础实现原理。当然，想要开发一套完善的WEB服务器或浏览器，需要做的工作是很复杂的，要考虑多线程、并发、io流、网络等等。但我们想要了解的只是其原理。后面将对使用较多的servlet和tomcat在进行分析，达到一个比较深入的理解。本篇在此博客基础上进一步整理：<a href="http://blog.csdn.net/ghost_programmer/article/details/43446531" target="_blank" rel="external">浅析web服务器与浏览器的实现原理</a>。</p>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>&#160; &#160; &#160; &#160;我们知道，将开发的web项目部署到tomcat服务器之后，就可以通过浏览器对服务器上的资源进行访问。但重要的一点是，存在多种不同厂商开发的不同浏览器。但各个类型的WEB浏览器，都可以正常的访问tomcat服务器上的资源。对此，我们可以这样理解：我开发了一个WEB服务器，并且能够保证其他人开发的客户端都能够与我的服务器正常通信。</p>
<p>&#160; &#160; &#160; &#160;能够实现这样的目的的前提自然就是，你要制定一个规范，并让想要与你开发的服务器正常进行通信的客户端都遵循这个规范来实现。这个规范，也就是所谓的协议。</p>
<p>&#160; &#160; &#160; &#160;正如在网络通信中，数据的传输可以遵循TCP/IP或UDP协议一样。WEB服务器与WEB浏览器之间，也通过一种双方都熟悉的语言进行通信。这种协议即是：超文本传输协议，也就是HTTP协议。不同的是，TCP/IP与UDP议是传输层当中的通信协议，而HTTP协议是应用层当中的协议。</p>
<p>&#160; &#160; &#160; &#160;当我们想要使用Java语言实现所谓的WEB通信，自然也应当遵循HTTP协议。Java中已经为我们提供了这样的一种实现规范，也就是广为人知的：Servlet接口。而我们开发web项目时,最常用到的HttpServlet类，就是基于此接口实现的具体子类。该类封装和提供了，针对基于Http协议通信的内容进行访问和操作的常用方法。</p>
<h2 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h2><p>&#160; &#160; &#160; &#160;首先，我们通过一段简单的Servlet代码来看一下，基于HTTP协议进行WEB通信的请求信息。我的环境是os x+idea+tomcat7，项目工程我放在github上，链接传送门：<a href="https://github.com/wustzoujing/MyBrowerAndMyTomcat" target="_blank" rel="external">wustzoujing/MyBrowerAndMyTomcat</a>。</p>
<p>&#160; &#160; &#160; &#160;首先要了解servlet，这个基础没有的话，可以参考这个入门教程<a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="external">servlet教程</a>。从helloworld开始做。这里我们基于HttpServlet+Tomcat，先建立一个web的项目，再写servlet测试类，然后配置web.xml，最后用tomcat发布。</p>
<p>&#160; &#160; &#160; &#160;这里贴上一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import javax.servlet.http.*;</div><div class="line">import javax.servlet.*;</div><div class="line">import java.io.IOException;</div><div class="line">import java.util.Enumeration;</div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class ServeletTest extends HttpServlet &#123;</div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        for (Enumeration e = request.getHeaderNames(); e.hasMoreElements();) &#123;</div><div class="line">            String header = (String) e.nextElement();</div><div class="line">            if (header != null)</div><div class="line">                System.out.println((new StringBuilder(String.valueOf(header)))</div><div class="line">                        .append(&quot;:&quot;).append(request.getHeader(header))</div><div class="line">                        .toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;接下来是web.xml的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</div><div class="line">		  http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd&quot;</div><div class="line">           version=&quot;3.0&quot;&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;ServeletTest&lt;/servlet-class&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"></div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/servlet/HttpServletDemo&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当我们在浏览器输入链接<a href="http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：" target="_blank" rel="external">http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host:localhost:8080</div><div class="line">accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">upgrade-insecure-requests:1</div><div class="line">cookie:JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">accept-language:zh-cn</div><div class="line">accept-encoding:gzip, deflate</div><div class="line">connection:keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在计算机网络的学习中我们就知道了，这是http请求报文的内容，我们这里再回忆一下：一个HTTP协议的请求中，通常主要包含三个部分：</p>
<ol>
<li>方法/统一资源标示符(URI)/协议/版本 </li>
<li>请求标头</li>
<li>实体主体</li>
</ol>
<p>&#160; &#160; &#160; &#160;其中方法也就是所谓的get/post之类的请求方法，统一资源标示符也就是要访问的目标资源的路径，包括协议及协议版本，这些信息被放在请求的第一行。</p>
<p>&#160; &#160; &#160; &#160;随后，紧接着的便是请求标头；请求标头通常包含了与客户端环境及请求实体主体相关的有用信息。</p>
<p>&#160; &#160; &#160; &#160;最后，在标头与实体主体之间是一个空行。它对于HTTP请求格式是很重要的，空行告诉HTTP服务器，实体主体从这里开始。</p>
<h2 id="实现最简易的Tomcat"><a href="#实现最简易的Tomcat" class="headerlink" title="实现最简易的Tomcat"></a>实现最简易的Tomcat</h2><p>&#160; &#160; &#160; &#160;前面已经说过了，我们这里想要研究的，是WEB服务器的基本实现原理。那么我们自然想要自己来实现一下所谓的WEB服务器，我们已经知道了：所谓的B/S结构，实际上就是客户端与服务器之间基于HTTP协议的网络通信。那么，肯定是离不开socket与io的，所以我们可以简单的模拟一个最简易功能的web服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line">            int length = in.read(buf);</div><div class="line">            String request = new String(buf,0,length);</div><div class="line">            //</div><div class="line">            System.out.println(request);</div><div class="line">            </div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line"></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="demo中所需理论"><a href="#demo中所需理论" class="headerlink" title="demo中所需理论"></a>demo中所需理论</h3><p>&#160; &#160; &#160; &#160;demo中我们用到了ServerSocket和Socket，这也是Java网络编程中必须知道的，分别使用与服务器端和客户端。下面我们看下区别：</p>
<h4 id="serverSocket类"><a href="#serverSocket类" class="headerlink" title="serverSocket类"></a>serverSocket类</h4><p>&#160; &#160; &#160; &#160;创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务，如：上面的ServerSocket tomcat = new ServerSocket(9090);这里指定提供监听服务的端口是9090，一台计算机可以同时提供多个服务，这些不同的服务之间通过端口号来区别，不同的端口号上提供不同的服务。</p>
<p>&#160; &#160; &#160; &#160;为了随时监听可能的Client请求，执行如下的语句：Socket s = tomcat.accept();该语句调用了ServerSocket对象的accept()方法，这个方法的执行将使Server端的程序处于等待状态，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象Link-Socket。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时，关闭ServerSocket对象：如tomcat.close()；</p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>&#160; &#160; &#160; &#160;当Client程序需要从Server端获取信息及其他服务时，应创建一个Socket对象：Socket MySocket=new Socket(“ServerComputerName”，600)；</p>
<p>&#160; &#160; &#160; &#160;Socket类的构造函数有两个参数，第一个参数是欲连接到的Server计算机的主机地址，第二个参数是该Server机上提供服务的端口号。Socket对象建立成功之后，就可以在Client和Server之间建立一个连接，并通过这个连接在两个端点之间传递数据。利用Socket类的方法getOutputStream()和getInputStream()分别获得向Socket读写数据的输入／输出流，最后将从Server端读取的数据重新返还到Server端。</p>
<p>&#160; &#160; &#160; &#160;当Server和Client端的通信结束时，可以调用Socket类的close()方法关闭Socket，拆除连接。ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的Socket与客户端的Socket，在ServerSocket 进行accept之后，就将主动权转让了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#160; &#160; &#160; &#160;服务器端程序设计：</p>
<p>&#160; &#160; &#160; &#160;在服务器端，利用ServerSocket类的构造函数ServerSocket(int port)创建一个ServerSocket类的对象，port参数传递端口，这个端口就是服务器监听连接请求的端口，如果在这时出现错误将抛出IOException异常对象，否则将创建ServerSocket对象并开始准备接收连接请求。</p>
<p>&#160; &#160; &#160; &#160;服务程序从调用ServerSocket的accept()方法开始，直到连接建立。在建立连接后，accept()返回一个最近创建的Socket对象，该Socket对象绑定了客户程序的IP地址或端口号。</p>
<p>&#160; &#160; &#160; &#160;客户端程序设计：</p>
<p>&#160; &#160; &#160; &#160;当客户程序需要与服务器程序通信时，需在客户机创建一个Socket对象。Socket类有构造函数Socket(InetAddress addr，int port)和Socket(String host，intport)，两个构造函数都创建了一个基于Socket的连接服务器端流套接字的流套接字。对于第一个InetAd-dress子类对象通过addr参数获得服务器主机的IP地址，对于第二个函数host参数包被分配到InetAddress对象中，如果没有IP地址与host参数相一致，那么将抛出UnknownHostException异常对象。两个函数都通过参数port获得服务器的端口号。假设已经建立连接了，网络API将在客户端基于Socket的流套接字中捆绑客户程序的IP地址和任意一个端口号，否则两个函数都会抛出一个IOException对象。</p>
<p>&#160; &#160; &#160; &#160;如果创建了一个Socket对象，那么它可通过get-InputStream()方法从服务程序获得输入流读传送来的信息，也可通过调用getOutputStream()方法获得输出流来发送消息。在读写活动完成之后，客户程序调用close()方法关闭流和流套接字。</p>
<h3 id="分析demo"><a href="#分析demo" class="headerlink" title="分析demo"></a>分析demo</h3><p>&#160; &#160; &#160; &#160;在demo中，我们开启一个服务器socket来监听9090端口，所以我们在通过在浏览器中输入<a href="http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：" target="_blank" rel="external">http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">服务器启动</div><div class="line">GET / HTTP/1.1</div><div class="line">Host: localhost:9090</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Cookie: JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">Accept-Language: zh-cn</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;通过成果我们看到，我们已经成功的实现了最简易的tomcat。不过这里需要注意的是，我们自己山寨的tomcat服务器当中，之所以也成功的输出了Http协议的请求体，是因为：我们是通过web浏览器进行访问的，如果通过普通的socket进行对serversocket的连接访问，是没有这些请求信息的。因为我们前面已经说过了，web浏览器与服务器之间的通信必须遵循Http协议。</p>
<h2 id="实现简易浏览器"><a href="#实现简易浏览器" class="headerlink" title="实现简易浏览器"></a>实现简易浏览器</h2><p>&#160; &#160; &#160; &#160;通过前面的学习，我相信我们现在更想把浏览器功能也实现，剖析一下，接下来我们就试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrower &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            Socket browser = new Socket(&quot;127.0.0.1&quot;, 9090);</div><div class="line">            PrintWriter pw = new PrintWriter(browser.getOutputStream(),true);</div><div class="line">            // 封装请求第一行</div><div class="line">            pw.println(&quot;GET/ HTTP/1.1&quot;);</div><div class="line">            // 封装请求头</div><div class="line">            pw.println(&quot;User-Agent: Java/1.8.0_131&quot;);</div><div class="line">            pw.println(&quot;Host: 127.0.0.1:9090&quot;);</div><div class="line">            pw.println(&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);</div><div class="line">            pw.println(&quot;Connection: keep-alive&quot;);</div><div class="line">            // 空行</div><div class="line">            pw.println();</div><div class="line">            // 封装实体主体</div><div class="line">            pw.println(&quot;UserName=JessieZou&amp;Age=22&quot;);</div><div class="line">            // 写入完毕</div><div class="line">            browser.shutdownOutput();</div><div class="line"></div><div class="line"></div><div class="line">            // 接受服务器返回信息，</div><div class="line">            InputStream in = browser.getInputStream();</div><div class="line">            //</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            //</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            System.out.println(request);</div><div class="line">            //browser.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            System.out.println(&quot;亲，出现了异常哦!&quot;);</div><div class="line">        &#125;finally&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;同时改进我们的tomcat如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line"></div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            //</div><div class="line">            System.out.println(&quot;request:&quot;+request);</div><div class="line"></div><div class="line">            PrintWriter pw = new PrintWriter(s.getOutputStream(),true);</div><div class="line">            pw.println(&quot;&lt;html&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;title&gt;LiveSession List&lt;/title&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;body&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;p style=\&quot;font-weight: bold;color: red;\&quot;&gt;welcome to MyTomcat&lt;/p&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/body&gt;&quot;);</div><div class="line">            s.close();</div><div class="line">            tomcat.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>&#160; &#160; &#160; &#160;响应行和响应标头当中，实际上是负责将相关的一些有用信息返回给我们，但这部分是不需要在浏览器中所展示的。也就是说，我们的浏览器除了应当具备获取一个完整的HTTP响应的能力之外，还应该具备解析HTTP协议响应的能力。事实上，Java也为我们提供了这样的对象，那就是URL及URLConnection对象。</p>
<p>如果我们在我们的浏览器中，植入这样的对象，来进行与服务器之间的HTTP通信，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrowser2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(&quot;http://localhost:9090&quot;);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line"></div><div class="line">            InputStream in = conn.getInputStream();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer text = new StringBuffer();</div><div class="line">            String line = null;</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                line = new String(buf, 0, length);</div><div class="line">                text.append(line);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(text);</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这次当我们再运行程序，查看输出信息，发现我们从URLConnection对象获取到的输入流当中，读取的响应信息，就如我们所愿的，只剩下了需要被解析显示在页面的响应实体的内容。实际上这也就是Java为我们提供的对象，将对HTTP协议内容的解析功能进行了封装。而究其根本来说，我们基本可以想象到，URLConnection = Socket + HTTP协议解析器。也就是说，该对象的底层除了通过Socket连接到WEB服务器之外，还封装了对HTTP协议内容的解析功能。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&#160; &#160; &#160; &#160;我们先启动服务器，然后运行浏览器模拟网页浏览的过程，首先看到服务器端收到的请求信息，打印出来的信息和上面类似，我们这里就是把请求报文显示出来。</p>
<p>&#160; &#160; &#160; &#160;紧接着，服务器收到请求进行处理后，返回资源给浏览器，于是得到输出信息，在改进后的tomcat服务器，我们封装了html，不过是静态的。如果在搭配html解析，就可以像我们浏览器一样，能先到解析的页面。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-10%20%E4%B8%8B%E5%8D%883.39.20.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;现在我们是单线程单连接，而且没有前段操作界面的实现，我们真正使用的tomcat和浏览器当然在多线程并发、io、网络、人性化操作等方面也做了大量工作进行效率优化和简化操作，美化界面。我们通过例子是去了解基本底层原理。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;a href=&quot;#web服务器和web浏览器的实现原理&quot; class=&quot;headerlink&quot; title=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;/a&gt;web服务器和web浏览器的实现原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://yoursite.com/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Servlet搭配工作Tomcat</title>
    <link href="http://yoursite.com/2017/03/29/Servlet%E5%8E%9F%E7%90%86%E5%92%8CTomcat%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/29/Servlet原理和Tomcat原理/</id>
    <published>2017-03-29T09:20:19.000Z</published>
    <updated>2017-05-23T05:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet搭配工作Tomcat"><a href="#Servlet搭配工作Tomcat" class="headerlink" title="Servlet搭配工作Tomcat"></a>Servlet搭配工作Tomcat</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;最近再看Tomcat原理与Java Web这本书，作为准备，先了解一下Servlet和Tomcat的搭配工作过程。</p>
 <a id="more"></a>
<h2 id="Tomcat与Servlet搭配工作"><a href="#Tomcat与Servlet搭配工作" class="headerlink" title="Tomcat与Servlet搭配工作"></a>Tomcat与Servlet搭配工作</h2><p> <img src="http://images.cnitblog.com/blog/384192/201302/24114945-4774512d1247438fa58c37399d3999ae.jpg" alt=""></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<h2 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h2><ol>
<li>首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet（）、doPost（）等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</li>
<li>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</li>
<li>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest、ServletResponse 强转为HttpRequest 和 HttpResponse。</li>
</ol>
<h2 id="创建Servlet对象的时机："><a href="#创建Servlet对象的时机：" class="headerlink" title="创建Servlet对象的时机："></a>创建Servlet对象的时机：</h2><ol>
<li>Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。</li>
<li>在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。</li>
<li>Servlet Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的<load-on-startup>属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。</load-on-startup></li>
</ol>
<p>参考博文：<a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="external">servlet原理</a>。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet搭配工作Tomcat&quot;&gt;&lt;a href=&quot;#Servlet搭配工作Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Servlet搭配工作Tomcat&quot;&gt;&lt;/a&gt;Servlet搭配工作Tomcat&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近再看Tomcat原理与Java Web这本书，作为准备，先了解一下Servlet和Tomcat的搭配工作过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://yoursite.com/categories/Java-Web/"/>
    
    
      <category term="Servlet、Tomcat" scheme="http://yoursite.com/tags/Servlet%E3%80%81Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（五）</title>
    <link href="http://yoursite.com/2017/03/24/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/24/高效并发（五）/</id>
    <published>2017-03-24T05:22:25.000Z</published>
    <updated>2017-05-23T05:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent包总结（三）"><a href="#concurrent包总结（三）" class="headerlink" title="concurrent包总结（三）"></a>concurrent包总结（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经分析了线程池和同步工具。这里我们来介绍原子类和forkjoin框架。</p>
 <a id="more"></a>
<h2 id="forkjoin框架"><a href="#forkjoin框架" class="headerlink" title="forkjoin框架"></a>forkjoin框架</h2><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;concurrent包总结（三）&quot;&gt;&lt;a href=&quot;#concurrent包总结（三）&quot; class=&quot;headerlink&quot; title=&quot;concurrent包总结（三）&quot;&gt;&lt;/a&gt;concurrent包总结（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经分析了线程池和同步工具。这里我们来介绍原子类和forkjoin框架。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（四）</title>
    <link href="http://yoursite.com/2017/03/21/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/21/高效并发（四）/</id>
    <published>2017-03-21T05:22:10.000Z</published>
    <updated>2017-05-23T23:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent包总结（二）"><a href="#concurrent包总结（二）" class="headerlink" title="concurrent包总结（二）"></a>concurrent包总结（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经分析了lock和concurrent提供的集合类包括阻塞队列和容器类。这里我们来介绍</p>
 <a id="more"></a>
<h2 id="executor线程池"><a href="#executor线程池" class="headerlink" title="executor线程池"></a>executor线程池</h2><p>### </p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;concurrent包总结（二）&quot;&gt;&lt;a href=&quot;#concurrent包总结（二）&quot; class=&quot;headerlink&quot; title=&quot;concurrent包总结（二）&quot;&gt;&lt;/a&gt;concurrent包总结（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经分析了lock和concurrent提供的集合类包括阻塞队列和容器类。这里我们来介绍&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（三）</title>
    <link href="http://yoursite.com/2017/03/18/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/18/高效并发（三）/</id>
    <published>2017-03-18T01:16:03.000Z</published>
    <updated>2017-05-23T11:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent包总结（一）"><a href="#concurrent包总结（一）" class="headerlink" title="concurrent包总结（一）"></a>concurrent包总结（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在前面的基础知识之上，我们开始对concurrent包的全面分析。</p>
 <a id="more"></a>
<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p>&#160; &#160; &#160; &#160;可参考博文：<a href="http://www.importnew.com/24594.html" target="_blank" rel="external">并发集合总结</a>。</p>
<h3 id="Concurrent-Colleciton相关"><a href="#Concurrent-Colleciton相关" class="headerlink" title="Concurrent Colleciton相关"></a>Concurrent Colleciton相关</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>&#160; &#160; &#160; &#160;采用了锁分离技术，它使用了多个锁代替HashTable中的单个锁，其中get方法并没有加锁。它把区间按照并发级别(concurrentLevel)，分成了若干个segment。默认情况下内部按并发级别为16来创建。对于每个segment的容量，默认情况也是16。当然并发级别(concurrentLevel)和每个段(segment)的初始容量都是可以通过构造函数设定的。</p>
<p>参考博文：<a href="http://www.importnew.com/21781.html" target="_blank" rel="external">concurrenthashmap详解</a></p>
<p><img src="http://images.cnitblog.com/blog/587773/201409/062059451104363.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;看起来只是把以前HashTable的一个hash bucket创建了16份而已。那还有其他特殊的吗？其中Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。我们就从put，get，remove方法重点去了解。</p>
<p>&#160; &#160; &#160; &#160;get方法：count变量表示segment中存在entry的个数,hashentry数据结构，还有get方法没有加同步监视器。我们来看下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">V get(Object key, int hash) &#123;</div><div class="line">        if (count != 0) &#123; // read-volatile // ①</div><div class="line">            HashEntry&lt;K,V&gt; e = getFirst(hash); </div><div class="line">            while (e != null) &#123;</div><div class="line">                if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</div><div class="line">                    V v = e.value;</div><div class="line">                    if (v != null)  // ② 注意这里，结合双层检测锁DCL</div><div class="line">                        return v;</div><div class="line">                    return readValueUnderLock(e); // recheck</div><div class="line">                &#125;</div><div class="line">                e = e.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">transient volatile int count;</div><div class="line"></div><div class="line"></div><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    final int hash;</div><div class="line">    volatile V value;</div><div class="line">    final HashEntry&lt;K,V&gt; next;</div><div class="line">    。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;count和value使用了volatile来修改。我们前文说过，Java5之后，JMM实现了对volatile的保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。所以，每次判断count变量的时候，即使恰好其他线程改变了segment也会体现出来。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>&#160; &#160; &#160; &#160;CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>我们要注意以下两点：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
</li>
</ol>
<p>缺点：</p>
<p>&#160; &#160; &#160; &#160;一、内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>&#160; &#160; &#160; &#160;针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>&#160; &#160; &#160; &#160;二、数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>参考博文：<a href="http://www.importnew.com/22470.html" target="_blank" rel="external">copyonwriteArrayList解析</a></p>
<h4 id="ConcurrentSkipListmap"><a href="#ConcurrentSkipListmap" class="headerlink" title="ConcurrentSkipListmap"></a>ConcurrentSkipListmap</h4><p>&#160; &#160; &#160; &#160;跳跃表其实也是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。跳跃表使用概率均衡技术而不是使用强制性均衡技术，因此，对于插入和删除结点比传统上的平衡树算法更为简洁高效。 跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它。</p>
<p><img src="http://img.blog.csdn.net/20160820163336489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>参考博文：<a href="http://blog.csdn.net/sunxianghuang/article/details/52221913" target="_blank" rel="external">concurrentskipListmap解析</a></p>
<h3 id="Queue接口相关"><a href="#Queue接口相关" class="headerlink" title="Queue接口相关"></a>Queue接口相关</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>&#160; &#160; &#160; &#160;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现 。</p>
<p>&#160; &#160; &#160; &#160;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现。参考博文：<a href="http://ifeve.com/concurrentlinkedqueue/" target="_blank" rel="external">ConcurrentLinkedQueue解析</a>。</p>
<p>&#160; &#160; &#160; &#160;ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。</p>
<pre><code>private transient volatile Node&lt;e&gt; tail = head;
</code></pre><p><img src="http://ifeve.com/wp-content/uploads/2013/01/ConcurrentLinekedQueue队列入队结构变化图.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;我们主要来看入队和出队操作，如上图是入队操作，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点。这时单线程的方式，而多线程是采用CAS方式来实现：</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>&#160; &#160; &#160; &#160;参考博文：<a href="http://blog.csdn.net/suifeng3051/article/details/48807423" target="_blank" rel="external">BlockingQueue解析</a>。BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p>
<ol>
<li>当队列满了的时候进行入队列操作</li>
<li>当队列空了的时候进行出队列操作</li>
</ol>
<p>阻塞队列主要用在生产者/消费者的场景:</p>
<p><img src="http://img.blog.csdn.net/20150929153140497" alt=""></p>
<p>&#160; &#160; &#160; &#160;负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。</p>
<p>在Java6中，BlockingQueue的实现类主要有以下几种：</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ol>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>&#160; &#160; &#160; &#160; ArrayBlockingQueue:一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。ArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);</div><div class="line">queue.put(&quot;1&quot;);</div><div class="line">Object object = queue.take();</div></pre></td></tr></table></figure>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>&#160; &#160; &#160; &#160;DelayQueue阻塞的是其内部元素，DelayQueue中的元素必须实现 java.util.concurrent.Delayed接口，这个接口的定义非常简单：</p>
<pre><code>public interface Delayed extends Comparable&lt;Delayed&gt; {
long getDelay(TimeUnit unit);
}
</code></pre><p>&#160; &#160; &#160; &#160;getDelay()方法的返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时DelayedQueue会通过其take()方法释放此对象。从上面Delayed 接口定义可以看到，它还继承了Comparable接口，这是因为DelayedQueue中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。其实DelayQueue应用场景很多，比如定时关闭连接、缓存对象，超时处理等各种场景。</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使用LinkedBlockingQueue的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();</div><div class="line">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);</div><div class="line">bounded.put(&quot;Value&quot;);</div><div class="line">String value = bounded.take();</div></pre></td></tr></table></figure>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>&#160; &#160; &#160; &#160;一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。需要注意，PriorityBlockingQueue中允许插入null对象。所有插入PriorityBlockingQueue的对象必须实现 java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。另外，我们可以从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>&#160; &#160; &#160; &#160;队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</p>
<h3 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h3><p>&#160; &#160; &#160; &#160;这里首先我们需要总结的是我们应该聪明的使用锁，在jvm的学习中我们已经知道了一些锁优化机制，一些锁的类型，那就是我们在使用的时候应该注意些什么。</p>
<p>这里有一些博文可以参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-lock/" target="_blank" rel="external">如何聪明地使用锁</a>。竞争锁是造成多线程应用程序性能瓶颈的主要原因，在保证程序正确性的前提下，解决同步带来的性能损失的第一步不是去除锁，而是降低锁的竞争。通常，有以下三类方法可以降低锁的竞争：减少持有锁的时间，降低请求锁的频率，或者用其他协调机制取代独占锁。</p>
<h4 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h4><p>&#160; &#160; &#160; &#160;ReentrantLock是可重入锁，什么是可重入锁呢？可重入锁就是当前持有该锁的线程能够多次获取该锁，无需等待。可重入锁是如何实现的呢？这要从ReentrantLock的一个内部类Sync的父类说起，Sync的父类是AbstractQueuedSynchronizer（后面简称AQS）。Sync被设计成为安全的外部不可访问的内部类。参考博文：<a href="http://www.importnew.com/24006.html" target="_blank" rel="external">ReentranLock解析</a>，<a href="http://www.codeceo.com/article/reentrantlock-learn.html" target="_blank" rel="external">ReentranLock解析2</a>.</p>
<p><img src="http://static.codeceo.com/images/2016/08/reentrantlock01.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;这里我们首先来说一下AQS。AQS是JDK1.5提供的一个基于FIFO等待队列实现的一个用于实现同步器的基础框架，这个基础框架的重要性可以这么说，JCU包里面几乎所有的有关锁、多线程并发以及线程同步器等重要组件的实现都是基于AQS这个框架。参考博文：<a href="http://www.importnew.com/22924.html" target="_blank" rel="external">深度解析AQS</a>。<a href="http://www.importnew.com/22102.html" target="_blank" rel="external">AQS实现分析（上）</a>,<a href="http://www.importnew.com/22108.html" target="_blank" rel="external">AQS实现分析（下）</a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">AQS的核心思想是基于volatile int state这样的一个属性同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。当state的值为0的时候，标识改Lock不被任何线程所占有。</font>我们假设目前有三个线程Thread1、Thread2、Thread3同时去竞争锁，如果结果是Thread1获取了锁，Thread2和Thread3进入了等待队列，那么他们的样子如下：</p>
<p><img src="http://static.oschina.net/uploads/space/2016/0403/104016_XiVq_1759553.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;AQS的等待队列基于一个双向链表实现的，HEAD节点不关联线程，后面两个节点分别关联Thread2和Thread3，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的TAIL。</p>
<p>&#160; &#160; &#160; &#160;三个线程同时进来，他们会首先会通过CAS去修改state的状态，如果修改成功，那么竞争成功，因此这个时候三个线程只有一个CAS成功，其他两个线程失败，也就是tryAcquire返回false。addWaiter会把将当前线程关联的EXCLUSIVE类型的节点入队列，如果队尾节点不为null，则说明队列中已经有线程在等待了，那么直接入队尾。对于我们举的例子，这边的逻辑应该是走enq，也就是开始队尾是null，其实这个时候整个队列都是null的。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">他们是如何实现不进行加锁，当有多个线程，或者说很多很多的线程同时执行的时候，怎么能保证最终他们都能够乖乖的入队列而不会出现并发问题的呢？这也是这部分代码的经典之处，多线程竞争，热点、单点在队列尾部，多个线程都通过【CAS+死循环】这个free-lock黄金搭档来对队列进行修改，每次能够保证只有一个成功，如果失败下次重试，如果是N个线程，那么每个线程最多loop N次，最终都能够成功。</font></p>
<p>&#160; &#160; &#160; &#160;羊群效应：</p>
<p>&#160; &#160; &#160; &#160;这里说一下羊群效应，当有多个线程去竞争同一个锁的时候，假设锁被某个线程占用，那么如果有成千上万个线程在等待锁，有一种做法是同时唤醒这成千上万个线程去去竞争锁，这个时候就发生了羊群效应，海量的竞争必然造成资源的剧增和浪费，因此终究只能有一个线程竞争成功，其他线程还是要老老实实的回去等待。<font color="red">AQS的FIFO的等待队列给解决在锁竞争方面的羊群效应问题提供了一个思路：保持一个FIFO队列，队列每个节点只关心其前一个节点的状态，线程唤醒也只唤醒队头等待线程。其实这个思路已经被应用到了分布式锁的实践中，</font>见：Zookeeper分布式锁的改进实现方案。</p>
<h4 id="ReetrantReadWriteLock"><a href="#ReetrantReadWriteLock" class="headerlink" title="ReetrantReadWriteLock"></a>ReetrantReadWriteLock</h4><p>&#160; &#160; &#160; &#160;ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。 所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。ReadWriteLock是一个接口，主要有两个方法，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface ReadWriteLock &#123;</div><div class="line">    /**</div><div class="line">     * 返回读锁</div><div class="line">     */</div><div class="line">    Lock readLock();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 返回写锁</div><div class="line">     */</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考博文：<a href="http://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="external">ReetrantReadWriteLock解析</a>，</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>&#160; &#160; &#160; &#160;Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>&#160; &#160; &#160; &#160;在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class BoundedBuffer &#123;  </div><div class="line">   final Lock lock = new ReentrantLock();//锁对象  </div><div class="line">   final Condition notFull  = lock.newCondition();//写线程条件   </div><div class="line">   final Condition notEmpty = lock.newCondition();//读线程条件   </div><div class="line">  </div><div class="line">   final Object[] items = new Object[100];//缓存队列  </div><div class="line">   int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;  </div><div class="line">  </div><div class="line">   public void put(Object x) throws InterruptedException &#123;  </div><div class="line">     lock.lock();  </div><div class="line">     try &#123;  </div><div class="line">       while (count == items.length)//如果队列满了   </div><div class="line">         notFull.await();//阻塞写线程  </div><div class="line">       items[putptr] = x;//赋值   </div><div class="line">       if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </div><div class="line">       ++count;//个数++  </div><div class="line">       notEmpty.signal();//唤醒读线程  </div><div class="line">     &#125; finally &#123;  </div><div class="line">       lock.unlock();  </div><div class="line">     &#125;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">   public Object take() throws InterruptedException &#123;  </div><div class="line">     lock.lock();  </div><div class="line">     try &#123;  </div><div class="line">       while (count == 0)//如果队列为空  </div><div class="line">         notEmpty.await();//阻塞读线程  </div><div class="line">       Object x = items[takeptr];//取值   </div><div class="line">       if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </div><div class="line">       --count;//个数--  </div><div class="line">       notFull.signal();//唤醒写线程  </div><div class="line">       return x;  </div><div class="line">     &#125; finally &#123;  </div><div class="line">       lock.unlock();  </div><div class="line">     &#125;  </div><div class="line">   &#125;   </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。下面分析一下代码的执行过程：</p>
<ol>
<li><p>一个写线程执行，调用put方法；</p>
</li>
<li><p>判断count是否为100，显然没有100；</p>
</li>
<li><p>继续执行，存入值；</p>
</li>
<li><p>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；</p>
</li>
<li><p>仅唤醒读线程阻塞队列中的一个；</p>
</li>
<li><p>一个读线程执行，调用take方法；</p>
</li>
<li><p>……</p>
</li>
<li><p>仅唤醒写线程阻塞队列中的一个。</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。</p>
<p>参考博文：<a href="http://blog.csdn.net/luonanqin/article/details/41894755" target="_blank" rel="external">Condition的await-signal流程详解</a>,<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="external">Condition-线程通信更高效的方式</a>,<a href="http://www.importnew.com/9281.html" target="_blank" rel="external">怎么理解Condition</a>.</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;concurrent包总结（一）&quot;&gt;&lt;a href=&quot;#concurrent包总结（一）&quot; class=&quot;headerlink&quot; title=&quot;concurrent包总结（一）&quot;&gt;&lt;/a&gt;concurrent包总结（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在前面的基础知识之上，我们开始对concurrent包的全面分析。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（二）</title>
    <link href="http://yoursite.com/2017/03/16/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/16/高效并发（二）/</id>
    <published>2017-03-16T02:55:01.000Z</published>
    <updated>2017-05-23T06:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发基本知识总结（二）"><a href="#并发基本知识总结（二）" class="headerlink" title="并发基本知识总结（二）"></a>并发基本知识总结（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在学习完虚拟机之后，我们了解了java的内存模型、实现线程安全的方法和jvm的一些锁优化机制，我们现在就把方向在往线程的基本操作，到concurrent包里面的线程安全类、原子类和一些lock的实现类。了解整个java并发基础。</p>
 <a id="more"></a>
<h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><h3 id="产生线程的方法"><a href="#产生线程的方法" class="headerlink" title="产生线程的方法"></a>产生线程的方法</h3><ol>
<li>继承thread，重写run方法</li>
<li>thread+runnable</li>
<li>callable+future（新型）</li>
</ol>
<h3 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h3><ol>
<li>join</li>
<li>sleep</li>
<li>yield</li>
<li>修改优先级</li>
</ol>
<h3 id="传统线程里面的通信"><a href="#传统线程里面的通信" class="headerlink" title="传统线程里面的通信"></a>传统线程里面的通信</h3><ol>
<li>notify</li>
<li>notifyAll</li>
<li>wait</li>
</ol>
<h2 id="并发必要知识"><a href="#并发必要知识" class="headerlink" title="并发必要知识"></a>并发必要知识</h2><p>&#160; &#160; &#160; &#160;由第一节我们知道了jvm的内存模型的特点：原子性、可见性、有序性。其中多个过程之间内存可见性的顺序可能不一致，比如下面的程序例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Test1 &#123;</div><div class="line">    private int a=1, b=2;</div><div class="line"> </div><div class="line">    public void foo()&#123;  // 线程1 </div><div class="line">        a=3;</div><div class="line">        b=4;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public int getA()&#123; // 线程2</div><div class="line">        return a;</div><div class="line">    &#125;    </div><div class="line">    public int getB()&#123; // 线程2</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//可能出现的结果</div><div class="line"></div><div class="line">A：a=1, b=2  // 都未改变</div><div class="line">B：a=3, b=4  // 都改变了</div><div class="line">C：a=3, b=2  //  a改变了，b未改变</div><div class="line">D：a=1, b=4  //  b改变了，a未改变</div></pre></td></tr></table></figure>
<p>造成这个的原因有下面两个：</p>
<font color="red"><br><br>1. Java编译器的重排序(Reording)操作有可能导致执行顺序和代码顺序不一致<br><br><br>2. 从线程工作内存写回主存时顺序无法保证。<br><br><br></font><br>&#160; &#160; &#160; &#160;正因为上面的那些问题，JMM中一个重要问题就是：如何让多线程之间，对象的状态对于各线程的“可视性”是顺序一致的。它的解决方式就是 Happens-before 规则：<br>JMM为所有程序内部动作定义了一个偏序关系，叫做happens-before。要想保证执行动作B的线程看到动作A的结果（无论A和B是否发生在同一个线程中），A和B之间就必须满足happens-before关系。<br><br><img src="http://opb7t58xj.bkt.clouddn.com/happen-before.png" alt=""><br><br>&#160; &#160; &#160; &#160;<font color="red">我们重点关注的是②，③，这两条也是我们通常编程中常用的。也就是加锁（包括新的lock类和synchronized）和volatile（语义增强了），当然也有不变类（final）和atomic原子类。</font>

<h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>&#160; &#160; &#160; &#160;早期Java中的锁只有最基本的synchronized，它是一种互斥的实现方式。在Java5之后，增加了一些其它锁，比如ReentrantLock，它基本作用和synchronized相似，但提供了更多的操作方式，比如在获取锁时不必像synchronized那样只是傻等，可以设置定时，轮询，或者中断，这些方法使得它在获取多个锁的情况可以避免死锁操作。</p>
<p>&#160; &#160; &#160; &#160;而我们需要了解的是ReentrantLock的性能相对synchronized来说有很大的提高。（不过据说Java6后对synchronized进行了优化，两者已经接近了。）在ConcurrentHashMap中，每个hash区间使用的锁正是ReentrantLock。</p>
<h3 id="增强的volatile语义"><a href="#增强的volatile语义" class="headerlink" title="增强的volatile语义"></a>增强的volatile语义</h3><p>&#160; &#160; &#160; &#160;Volatile可以看做一种轻量级的锁，但又和锁有些不同。</p>
<ol>
<li>它对于多线程，不是一种互斥（mutex）关系。</li>
<li>用volatile修饰的变量，不能保证该变量状态的改变对于其他线程来说是一种“原子化操作”。</li>
</ol>
<p>&#160; &#160; &#160; &#160;在Java5之前，JMM对Volatile的定义是：保证读写volatile都直接发生在main memory中，线程的working memory不进行缓存。它只承诺了读和写过程的可见性，并没有对Reording做限制，所以旧的Volatile并不太可靠。在Java5之后，JMM对volatile的语义进行了增强。就是我们看到的③ volatile变量法则。对volatile域的写入操作先行于每一个后续的读写操作。</p>
<p>&#160; &#160; &#160; &#160;所以，在使用Volatile时，需要注意：首先，需不需要互斥；其次，对象状态的改变是不是原子化的。它可以简化实现或者同步策略，确保引用对象的可见性，比如标志生命周期的事件：开始或者关闭。</p>
<p>&#160; &#160; &#160; &#160;脆弱的使用条件：</p>
<ol>
<li>写入变量不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值。</li>
<li>变量不需要和其他变量共同参与不变约束。</li>
<li>访问变量时不需要其他原因加锁。<h3 id="不变模式（immutable）"><a href="#不变模式（immutable）" class="headerlink" title="不变模式（immutable）"></a>不变模式（immutable）</h3>&#160; &#160; &#160; &#160;多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li>
</ol>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>&#160; &#160; &#160; &#160;如果操作都是原子操作，那就实现线程安全了。</p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>&#160; &#160; &#160; &#160;四种进程或线程同步互斥的控制方法：</p>
<ol>
<li><p>临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </p>
</li>
<li><p>互斥量:为协调共同对一个共享资源的单独访问而设计的。 </p>
</li>
<li><p>信号量:为控制一个具有有限数量用户资源而设计。 </p>
</li>
<li><p>事件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
</li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发基本知识总结（二）&quot;&gt;&lt;a href=&quot;#并发基本知识总结（二）&quot; class=&quot;headerlink&quot; title=&quot;并发基本知识总结（二）&quot;&gt;&lt;/a&gt;并发基本知识总结（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在学习完虚拟机之后，我们了解了java的内存模型、实现线程安全的方法和jvm的一些锁优化机制，我们现在就把方向在往线程的基本操作，到concurrent包里面的线程安全类、原子类和一些lock的实现类。了解整个java并发基础。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发基础知识" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：近期整理</title>
    <link href="http://yoursite.com/2017/03/15/%E5%89%91%E6%8C%87offer%EF%BC%9A%E8%BF%91%E6%9C%9F%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/15/剑指offer：近期整理/</id>
    <published>2017-03-15T13:27:55.000Z</published>
    <updated>2017-05-15T13:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;一次写一篇效率太低，以后多几篇一起篇，特别是同一类型的题目，本次是位运算、数学计算、数组操作、链表操作的四道题应用。</p>
  <a id="more"></a>
<h1 id="近期整理的四道题"><a href="#近期整理的四道题" class="headerlink" title="近期整理的四道题"></a>近期整理的四道题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</li>
<li>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</li>
<li>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</li>
<li>输入一个链表，输出该链表中倒数第k个结点。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>第一道题，我们采用精妙的位运算，关于位运算的应用，包括乘除，在第二题用过，交换值等我们分析过，在这道题里，<font color="red">把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0</font>。</li>
<li>我们采用递归求指数结果，然后在考虑奇偶，正负的问题。</li>
<li>遍历一遍数组，求出奇偶的个数，然后在遍历一遍把奇偶值填进去。</li>
<li>我们先使一个head往前走k-1步，然后第二个head和第一个一起走，当第一个走到链表的结尾时，第二个所在的地方就是倒数第k个。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public int NumberOf1(int n) &#123;</div><div class="line"></div><div class="line">        int count=0;</div><div class="line">        while(n!=0)&#123;</div><div class="line">            count++;</div><div class="line">            n=(n-1)&amp;n;</div><div class="line">        &#125;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">public double Power(double base, int exponent) &#123;</div><div class="line">        int n=Math.abs(exponent);</div><div class="line">        if(n==0)</div><div class="line">            return 1;</div><div class="line">        if(n==1)</div><div class="line">            return base;</div><div class="line">        double  result=Power(base,n&gt;&gt;1);</div><div class="line">        result*=result;</div><div class="line">        if((n&amp;1)==1)</div><div class="line">            result*=base;</div><div class="line">        if(exponent&lt;0)</div><div class="line">            result=1/result;</div><div class="line">        return result;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line"> public void reOrderArray(int [] array) &#123;</div><div class="line">        int [] result = new int[array.length];</div><div class="line">        int numOfOdd = 0;</div><div class="line">        int numOfEven = 0;</div><div class="line">        for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">            if((array[i]&amp;0x1) == 1)&#123;</div><div class="line">                numOfOdd++;</div><div class="line">            &#125;else&#123;</div><div class="line">                numOfEven++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        int indexOfOdd = 0;</div><div class="line">        int indexOfEven = numOfOdd;</div><div class="line">        for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">            if((array[i]&amp;0x1) == 1)&#123;</div><div class="line">                result[indexOfOdd++] = array[i];</div><div class="line">            &#125;else&#123;</div><div class="line">                result[indexOfEven++] = array[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">            array[i] = result[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</div><div class="line"></div><div class="line">        if(head==null||k&lt;=0)&#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        ListNode n1=head;</div><div class="line">        </div><div class="line">        ListNode n2=head;</div><div class="line">        for(int i=1;i&lt;k;i++)&#123;</div><div class="line">            if(n1.next!=null)&#123;</div><div class="line">                n1=n1.next;</div><div class="line">            &#125;else&#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       while(n1.next!=null)&#123;</div><div class="line">           n1=n1.next;</div><div class="line">           n2=n2.next;</div><div class="line">       &#125;</div><div class="line">        return n2;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;一次写一篇效率太低，以后多几篇一起篇，特别是同一类型的题目，本次是位运算、数学计算、数组操作、链表操作的四道题应用。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：斐波那契数列相关的三道题</title>
    <link href="http://yoursite.com/2017/03/09/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%89%E9%81%93%E9%A2%98/"/>
    <id>http://yoursite.com/2017/03/09/剑指offer：斐波那契数列相关的三道题/</id>
    <published>2017-03-09T12:21:41.000Z</published>
    <updated>2017-05-15T10:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;如果我们需要重复多次计算相同的问题，通常可以选择递归和循环两种方法，递归的代码简洁，利用分治的算法思想，但是我们就要注意递归有时候效率会很低，而且容易栈溢出，接下来几题中，我们就要注意。</p>
  <a id="more"></a>
<h1 id="斐波那契数列相关的三道题"><a href="#斐波那契数列相关的三道题" class="headerlink" title="斐波那契数列相关的三道题"></a>斐波那契数列相关的三道题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。</li>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
<li>我们可以用2 x 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 x 1的小矩形无重叠地覆盖一个2 x n 的大矩形，总共有多少种方法？</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;第一题如果用递归做，会发现效率很低，因为我们利用f(n)=f(n-1)+f(n-2)计算f(n)，导致每次的重复计算f(n-1)、f(n-2)，其实我们已经计算过这些值了，所以我们采用非递归来做。</p>
<p>&#160; &#160; &#160; &#160;青蛙跳台阶的第一道，我们发现这就是斐波那契数列，跳到某一台阶的次数就是跳到前一格台阶的次数加上跳到前两格台阶的次数。采用和上一题一样的做法。</p>
<p>&#160; &#160; &#160; &#160;青蛙跳台阶的第二道，我们用数学归纳法可以证明f(n)=2^2-1,其实这类题目也有很多，我们直接找到通式可以得到结果，像京东的几道题，还有求极限的，有兴趣可以去了解一下。</p>
<p>&#160; &#160; &#160; &#160;方块覆盖问题，其实仔细想想，也是青蛙跳台阶一样的方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int Fibonacci(int n) &#123;</div><div class="line"></div><div class="line">        if(n&lt;1)</div><div class="line">            return 0;</div><div class="line">        if(n==1)</div><div class="line">            return 1;</div><div class="line">        if(n==2) </div><div class="line">            return 1;</div><div class="line">        int a=1,b=1,reslut=0;</div><div class="line">        for(int i=3;i&lt;=n;++i)&#123;</div><div class="line">            reslut=a+b;</div><div class="line">            a=b;</div><div class="line">            b=reslut;</div><div class="line">        &#125;</div><div class="line">         return reslut;   </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    public int JumpFloor(int target) &#123;</div><div class="line"></div><div class="line">        if(target&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if(target==1)&#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        if(target==2)&#123;</div><div class="line">            return 2;</div><div class="line">        &#125;</div><div class="line">        int a=1,b=2,c=0;</div><div class="line">        for(int i=3;i&lt;=target;i++)&#123;</div><div class="line">            c=b+a;</div><div class="line">            a=b;</div><div class="line">            b=c;</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public int JumpFloorII(int target) &#123;</div><div class="line">        </div><div class="line">        if(target&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            int c=1;</div><div class="line">            for(int i=1;i&lt;target;i++)&#123;</div><div class="line">                c=2*c;</div><div class="line">            &#125;</div><div class="line">            return c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    public int RectCover(int target) &#123;</div><div class="line"></div><div class="line">        if(target&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if(target==1)&#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        if(target==2)&#123;</div><div class="line">            return 2;</div><div class="line">        &#125;</div><div class="line">        int a=1,b=2,c=0;</div><div class="line">        for(int i=3;i&lt;=target;i++)&#123;</div><div class="line">            c=b+a;</div><div class="line">            a=b;</div><div class="line">            b=c;</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;如果我们需要重复多次计算相同的问题，通常可以选择递归和循环两种方法，递归的代码简洁，利用分治的算法思想，但是我们就要注意递归有时候效率会很低，而且容易栈溢出，接下来几题中，我们就要注意。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2017/03/07/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/03/07/剑指offer：旋转数组的最小数字/</id>
    <published>2017-03-07T11:10:20.000Z</published>
    <updated>2017-05-15T09:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。</p>
  <a id="more"></a>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;二分查找法的核心思想就是：每次查找都可以排除不需要查找的一半，这道题我们是可以利用这个思想的。</p>
<p>&#160; &#160; &#160; &#160;我们定义两个标志，初识是分别指向第一位和最后一位，按照题目的旋转规则，我们找到数组中间的元素，如果中间的元素位于前面的递增数组中，那他应该小于等于第二个个标志指向的元素，此时数组中最小的元素应该位于该中间元素的后面，排除了一半，利用了二分的思想；同样，如果中间元素位于后面递增子数组中，那么它应该大于等于第二个标志指向的元素。如果相等，把最高位往前移一位，最后第一个标志上就是最小值。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class minNumberInRotateArray_6 &#123;</div><div class="line"></div><div class="line">    public int minNumberInRotateArray(int [] array) &#123;</div><div class="line"></div><div class="line">        //定义两个标志指向首位索引</div><div class="line">        int low = 0 ; int high = array.length - 1;</div><div class="line">        //结束条件</div><div class="line">        while(low &lt; high)&#123;</div><div class="line">            //取中间元素</div><div class="line">            int mid = low + (high - low) / 2;</div><div class="line">            //中间元素比尾数大，最小值在后半段</div><div class="line">            if(array[mid] &gt; array[high])&#123;</div><div class="line">                low = mid + 1;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            //如果相等，高位减1</div><div class="line">            else if(array[mid] == array[high])&#123;</div><div class="line">                high = high - 1;</div><div class="line">            &#125;</div><div class="line">            //如果中间元素比尾数小，最小值在前半段</div><div class="line">            else&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //循环结束，低位标志就是最小值所在</div><div class="line">        return array[low];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/03/06/%E5%89%91%E6%8C%87offer%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/03/06/剑指offer：用两个栈实现队列/</id>
    <published>2017-03-06T10:19:11.000Z</published>
    <updated>2017-05-15T09:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。</p>
  <a id="more"></a>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道栈是先进后出，而队列是先进先出。两个栈是可以实现先进后出的，我们模拟进队列操作时，进队列都进入第一个栈，然后出队列操作时，先把栈1全部倒入栈2，栈2出栈完成出队列操作，为了保证顺序，栈2中元素还要在倒入栈1。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    //定义两个栈</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    //进队都往第一个栈进。</div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    //出队列函数</div><div class="line">    public int pop() &#123;</div><div class="line">        //如果栈1不为空，把栈1值导入栈2，完成逆序</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        //栈2栈顶出队列</div><div class="line">        int first=stack2.pop();</div><div class="line">        //这里是重点：栈2的值都要倒回栈1，因为如果不倒回，出队列操作之后，栈2还有元素，但是之</div><div class="line">        //后进队列的元素又倒回栈2，这样就乱序了，倒回保证每次栈2中先进的都在下面，整体倒入栈2</div><div class="line">        //后肯定保证是先进的元素在栈顶</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        //</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（三）</title>
    <link href="http://yoursite.com/2017/03/06/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/JDK源码阅读（三）/</id>
    <published>2017-03-06T00:19:46.000Z</published>
    <updated>2017-05-22T12:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK源码阅读（三）"><a href="#JDK源码阅读（三）" class="headerlink" title="JDK源码阅读（三）"></a>JDK源码阅读（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在学习map类之后，我们今天了解list接口相关的一些类。本文转自系列博文：<a href="http://blog.csdn.net/column/details/collection.html?page=1" target="_blank" rel="external">Java集合类剖析</a>。</p>
 <a id="more"></a>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>&#160; &#160; &#160; &#160; ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</p>
<p>&#160; &#160; &#160; &#160;ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p>
<p>&#160; &#160; &#160; &#160;ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package java.util;    </div><div class="line">   </div><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;    </div><div class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable    </div><div class="line">&#123;    </div><div class="line">    // 序列版本号    </div><div class="line">    private static final long serialVersionUID = 8683452581122892189L;    </div><div class="line">   </div><div class="line">    // ArrayList基于该数组实现，用该数组保存数据   </div><div class="line">    private transient Object[] elementData;    </div><div class="line">   </div><div class="line">    // ArrayList中实际数据的数量    </div><div class="line">    private int size;    </div><div class="line">   </div><div class="line">    // ArrayList带容量大小的构造函数。    </div><div class="line">    public ArrayList(int initialCapacity) &#123;    </div><div class="line">        super();    </div><div class="line">        if (initialCapacity &lt; 0)    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+    </div><div class="line">                                               initialCapacity);    </div><div class="line">        // 新建一个数组    </div><div class="line">        this.elementData = new Object[initialCapacity];    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // ArrayList无参构造函数。默认容量是10。    </div><div class="line">    public ArrayList() &#123;    </div><div class="line">        this(10);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建一个包含collection的ArrayList    </div><div class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        elementData = c.toArray();    </div><div class="line">        size = elementData.length;    </div><div class="line">        if (elementData.getClass() != Object[].class)    </div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 将当前容量值设为实际元素个数    </div><div class="line">    public void trimToSize() &#123;    </div><div class="line">        modCount++;    </div><div class="line">        int oldCapacity = elementData.length;    </div><div class="line">        if (size &lt; oldCapacity) &#123;    </div><div class="line">            elementData = Arrays.copyOf(elementData, size);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 确定ArrarList的容量。    </div><div class="line">    // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”    </div><div class="line">    public void ensureCapacity(int minCapacity) &#123;    </div><div class="line">        // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的    </div><div class="line">        modCount++;    </div><div class="line">        int oldCapacity = elementData.length;    </div><div class="line">        // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”    </div><div class="line">        if (minCapacity &gt; oldCapacity) &#123;    </div><div class="line">            Object oldData[] = elementData;    </div><div class="line">            int newCapacity = (oldCapacity * 3)/2 + 1;    </div><div class="line">            //如果还不够，则直接将minCapacity设置为当前容量  </div><div class="line">            if (newCapacity &lt; minCapacity)    </div><div class="line">                newCapacity = minCapacity;    </div><div class="line">            elementData = Arrays.copyOf(elementData, newCapacity);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 添加元素e    </div><div class="line">    public boolean add(E e) &#123;    </div><div class="line">        // 确定ArrayList的容量大小    </div><div class="line">        ensureCapacity(size + 1);  // Increments modCount!!    </div><div class="line">        // 添加e到ArrayList中    </div><div class="line">        elementData[size++] = e;    </div><div class="line">        return true;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回ArrayList的实际大小    </div><div class="line">    public int size() &#123;    </div><div class="line">        return size;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // ArrayList是否包含Object(o)    </div><div class="line">    public boolean contains(Object o) &#123;    </div><div class="line">        return indexOf(o) &gt;= 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    //返回ArrayList是否为空    </div><div class="line">    public boolean isEmpty() &#123;    </div><div class="line">        return size == 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 正向查找，返回元素的索引值    </div><div class="line">    public int indexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = 0; i &lt; size; i++)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">            &#125; else &#123;    </div><div class="line">                for (int i = 0; i &lt; size; i++)    </div><div class="line">                if (o.equals(elementData[i]))    </div><div class="line">                    return i;    </div><div class="line">            &#125;    </div><div class="line">            return -1;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 反向查找，返回元素的索引值    </div><div class="line">        public int lastIndexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (o.equals(elementData[i]))    </div><div class="line">                return i;    </div><div class="line">        &#125;    </div><div class="line">        return -1;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值    </div><div class="line">    public int lastIndexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (o.equals(elementData[i]))    </div><div class="line">                return i;    </div><div class="line">        &#125;    </div><div class="line">        return -1;    </div><div class="line">    &#125;    </div><div class="line">     </div><div class="line">   </div><div class="line">    // 返回ArrayList的Object数组    </div><div class="line">    public Object[] toArray() &#123;    </div><div class="line">        return Arrays.copyOf(elementData, size);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回ArrayList元素组成的数组  </div><div class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;    </div><div class="line">        // 若数组a的大小 &lt; ArrayList的元素个数；    </div><div class="line">        // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中    </div><div class="line">        if (a.length &lt; size)    </div><div class="line">            return (T[]) Arrays.copyOf(elementData, size, a.getClass());    </div><div class="line">   </div><div class="line">        // 若数组a的大小 &gt;= ArrayList的元素个数；    </div><div class="line">        // 则将ArrayList的全部元素都拷贝到数组a中。    </div><div class="line">        System.arraycopy(elementData, 0, a, 0, size);    </div><div class="line">        if (a.length &gt; size)    </div><div class="line">            a[size] = null;    </div><div class="line">        return a;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取index位置的元素值    </div><div class="line">    public E get(int index) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        return (E) elementData[index];    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 设置index位置的值为element    </div><div class="line">    public E set(int index, E element) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        E oldValue = (E) elementData[index];    </div><div class="line">        elementData[index] = element;    </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将e添加到ArrayList中    </div><div class="line">    public boolean add(E e) &#123;    </div><div class="line">        ensureCapacity(size + 1);  // Increments modCount!!    </div><div class="line">        elementData[size++] = e;    </div><div class="line">        return true;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将e添加到ArrayList的指定位置    </div><div class="line">    public void add(int index, E element) &#123;    </div><div class="line">        if (index &gt; size || index &lt; 0)    </div><div class="line">            throw new IndexOutOfBoundsException(    </div><div class="line">            &quot;Index: &quot;+index+&quot;, Size: &quot;+size);    </div><div class="line">   </div><div class="line">        ensureCapacity(size+1);  // Increments modCount!!    </div><div class="line">        System.arraycopy(elementData, index, elementData, index + 1,    </div><div class="line">             size - index);    </div><div class="line">        elementData[index] = element;    </div><div class="line">        size++;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除ArrayList指定位置的元素    </div><div class="line">    public E remove(int index) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        modCount++;    </div><div class="line">        E oldValue = (E) elementData[index];    </div><div class="line">   </div><div class="line">        int numMoved = size - index - 1;    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,    </div><div class="line">                 numMoved);    </div><div class="line">        elementData[--size] = null; // Let gc do its work    </div><div class="line">   </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除ArrayList的指定元素    </div><div class="line">    public boolean remove(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">                for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (elementData[index] == null) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 快速删除第index个元素    </div><div class="line">    private void fastRemove(int index) &#123;    </div><div class="line">        modCount++;    </div><div class="line">        int numMoved = size - index - 1;    </div><div class="line">        // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,    </div><div class="line">                             numMoved);    </div><div class="line">        // 将最后一个元素设为null    </div><div class="line">        elementData[--size] = null; // Let gc do its work    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除元素    </div><div class="line">    public boolean remove(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (elementData[index] == null) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">            return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            // 便利ArrayList，找到“元素o”，则删除，并返回true。    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">            return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 清空ArrayList，将全部的元素设为null    </div><div class="line">    public void clear() &#123;    </div><div class="line">        modCount++;    </div><div class="line">   </div><div class="line">        for (int i = 0; i &lt; size; i++)    </div><div class="line">            elementData[i] = null;    </div><div class="line">   </div><div class="line">        size = 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将集合c追加到ArrayList中    </div><div class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        Object[] a = c.toArray();    </div><div class="line">        int numNew = a.length;    </div><div class="line">        ensureCapacity(size + numNew);  // Increments modCount    </div><div class="line">        System.arraycopy(a, 0, elementData, size, numNew);    </div><div class="line">        size += numNew;    </div><div class="line">        return numNew != 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 从index位置开始，将集合c添加到ArrayList    </div><div class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        if (index &gt; size || index &lt; 0)    </div><div class="line">            throw new IndexOutOfBoundsException(    </div><div class="line">            &quot;Index: &quot; + index + &quot;, Size: &quot; + size);    </div><div class="line">   </div><div class="line">        Object[] a = c.toArray();    </div><div class="line">        int numNew = a.length;    </div><div class="line">        ensureCapacity(size + numNew);  // Increments modCount    </div><div class="line">   </div><div class="line">        int numMoved = size - index;    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index, elementData, index + numNew,    </div><div class="line">                 numMoved);    </div><div class="line">   </div><div class="line">        System.arraycopy(a, 0, elementData, index, numNew);    </div><div class="line">        size += numNew;    </div><div class="line">        return numNew != 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除fromIndex到toIndex之间的全部元素。    </div><div class="line">    protected void removeRange(int fromIndex, int toIndex) &#123;    </div><div class="line">    modCount++;    </div><div class="line">    int numMoved = size - toIndex;    </div><div class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,    </div><div class="line">                         numMoved);    </div><div class="line">   </div><div class="line">    // Let gc do its work    </div><div class="line">    int newSize = size - (toIndex-fromIndex);    </div><div class="line">    while (size != newSize)    </div><div class="line">        elementData[--size] = null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    private void RangeCheck(int index) &#123;    </div><div class="line">    if (index &gt;= size)    </div><div class="line">        throw new IndexOutOfBoundsException(    </div><div class="line">        &quot;Index: &quot;+index+&quot;, Size: &quot;+size);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 克隆函数    </div><div class="line">    public Object clone() &#123;    </div><div class="line">        try &#123;    </div><div class="line">            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();    </div><div class="line">            // 将当前ArrayList的全部元素拷贝到v中    </div><div class="line">            v.elementData = Arrays.copyOf(elementData, size);    </div><div class="line">            v.modCount = 0;    </div><div class="line">            return v;    </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;    </div><div class="line">            // this shouldn&apos;t happen, since we are Cloneable    </div><div class="line">            throw new InternalError();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // java.io.Serializable的写入函数    </div><div class="line">    // 将ArrayList的“容量，所有的元素值”都写入到输出流中    </div><div class="line">    private void writeObject(java.io.ObjectOutputStream s)    </div><div class="line">        throws java.io.IOException&#123;    </div><div class="line">    // Write out element count, and any hidden stuff    </div><div class="line">    int expectedModCount = modCount;    </div><div class="line">    s.defaultWriteObject();    </div><div class="line">   </div><div class="line">        // 写入“数组的容量”    </div><div class="line">        s.writeInt(elementData.length);    </div><div class="line">   </div><div class="line">    // 写入“数组的每一个元素”    </div><div class="line">    for (int i=0; i&lt;size; i++)    </div><div class="line">            s.writeObject(elementData[i]);    </div><div class="line">   </div><div class="line">    if (modCount != expectedModCount) &#123;    </div><div class="line">            throw new ConcurrentModificationException();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // java.io.Serializable的读取函数：根据写入方式读出    </div><div class="line">    // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出    </div><div class="line">    private void readObject(java.io.ObjectInputStream s)    </div><div class="line">        throws java.io.IOException, ClassNotFoundException &#123;    </div><div class="line">        // Read in size, and any hidden stuff    </div><div class="line">        s.defaultReadObject();    </div><div class="line">   </div><div class="line">        // 从输入流中读取ArrayList的“容量”    </div><div class="line">        int arrayLength = s.readInt();    </div><div class="line">        Object[] a = elementData = new Object[arrayLength];    </div><div class="line">   </div><div class="line">        // 从输入流中将“所有的元素值”读出    </div><div class="line">        for (int i=0; i&lt;size; i++)    </div><div class="line">            a[i] = s.readObject();    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>注意trantient关键字，说明修饰变量不参与序列化。注意fail-fast和fail-safe的区别。参考博文：<a href="http://blog.csdn.net/ch717828/article/details/46892051" target="_blank" rel="external">fail-fast和fail-safe</a>。</li>
<li><p>ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。</p>
</li>
<li><p>在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p>
</li>
<li>注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。</li>
<li>注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。</li>
<li>注意arraylist和array的互相转化。toArray()和toArray(T[])。</li>
<li>ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;  </div><div class="line">    return (T[]) copyOf(original, newLength, original.getClass());  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;  </div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  </div><div class="line">        ? (T[]) new Object[newLength]  </div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </div><div class="line">    System.arraycopy(original, 0, copy, 0,  </div><div class="line">                     Math.min(original.length, newLength));  </div><div class="line">    return copy;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的,很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。</p>
<p>&#160; &#160; &#160; &#160;下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>&#160; &#160; &#160; &#160;LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。LinkedList同样是非线程安全的，只在单线程下适合使用。LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</p>
<p>&#160; &#160; &#160; &#160;源码解析地址，参考博文：<a href="http://blog.csdn.net/ns_code/article/details/35787253" target="_blank" rel="external">LinkedList源码剖析</a>.</p>
<p>&#160; &#160; &#160; &#160;list集合中还有vector和stack。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK源码阅读（三）&quot;&gt;&lt;a href=&quot;#JDK源码阅读（三）&quot; class=&quot;headerlink&quot; title=&quot;JDK源码阅读（三）&quot;&gt;&lt;/a&gt;JDK源码阅读（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在学习map类之后，我们今天了解list接口相关的一些类。本文转自系列博文：&lt;a href=&quot;http://blog.csdn.net/column/details/collection.html?page=1&quot;&gt;Java集合类剖析&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK集合类源码" scheme="http://yoursite.com/tags/JDK%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：重建二叉树</title>
    <link href="http://yoursite.com/2017/03/05/%E5%89%91%E6%8C%87offer%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/03/05/剑指offer：重建二叉树/</id>
    <published>2017-03-05T09:16:00.000Z</published>
    <updated>2017-05-15T09:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。</p>
  <a id="more"></a>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道在二叉树的前序遍历中，第一个总是根值。中序遍历中，根节点的值在序列的中间。左子树的根节点位于根节点的左边，右子树的结点在根节点的右边，因此我们需要扫描中序遍历才能找到根节点的值。找到根结点之后，中序遍历分成两部分，分别是左右子树的中序遍历，而我们在前序遍历中根据左右子树的个数就能确定左右子树的前序遍历，因此我们就能递归的完成。具体步骤如下：</p>
<ol>
<li>先进行输入序列的检查。</li>
<li>把中序序列放入一个hashmap，值为key，索引为value，这样很方便的通过前序序列中的值得到在中序遍历中的索引，很巧妙，而且时间复杂度较低。</li>
<li>利用递归完成树重建，为了代码的简洁性，写了preIn函数完成功能。具体输入参数和意义如下注释部分。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</div><div class="line">    //为空则返回空，输入检查，还可检查两者长度是否相等。</div><div class="line">    if(pre==null||in==null)&#123;</div><div class="line">          return null;</div><div class="line">    &#125;   </div><div class="line">    java.util.HashMap&lt;Integer,Integer&gt; map=new java.util.HashMap&lt;Integer,Integer&gt;();</div><div class="line">    //中序遍历进map</div><div class="line">    for(int i=0;i&lt;in.length;i++)&#123;</div><div class="line">       map.put(in[i],i); </div><div class="line">    &#125;</div><div class="line">    //交给重建函数</div><div class="line">    return preIn(pre,0,pre.length-1,in,0,in.length-1,map);</div><div class="line">&#125;</div><div class="line">//p，n，map属于不变的，这样写代码简洁一点，变得是前序遍历和中序遍历在原序列中的起止索引。</div><div class="line">public TreeNode preIn(int[] p,int pi,int pj,int[] n,int ni,int nj,java.util.HashMap&lt;Integer,Integer&gt; map)&#123;</div><div class="line">    //前序遍历开始位置大于结束位置，返回空。</div><div class="line">    if(pi&gt;pj)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    //前序遍历开始位置就是根节点。</div><div class="line">    TreeNode head =new TreeNode(p[pi]);</div><div class="line">    //获得根节点在中序序列中的索引位置</div><div class="line">    int index=map.get(p[pi]);</div><div class="line">    //递归左子树，前序遍历pi自增1就行，结束位置算法是（pi+1）+（index-1-ni），因为</div><div class="line">    //index-1为中序遍历结束位置减去ni开始位置就是中序遍历的个数，在加上pi+1就是前序遍历</div><div class="line">    //结束为止</div><div class="line">    head.left=preIn(p,pi+1,pi+index-ni,n,ni,index-1,map);</div><div class="line">    //右子树的前序开始位置为左子树结束位置自增1，结束位置是pj，中序遍历开始是根节点位置自</div><div class="line">    //增1，结束位置是nj</div><div class="line">    head.right=preIn(p,pi+index-ni+1,pj,n,index+1,nj,map);</div><div class="line">    //重建完成返回</div><div class="line">    return head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/03/04/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/03/04/剑指offer：从尾到头打印链表/</id>
    <published>2017-03-04T12:41:39.000Z</published>
    <updated>2017-05-15T09:59:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;补充说明：使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。在Java中我们用自定义类来表示链表，本题就给出了链表默认类。—-源自<em>百度百科</em>，觉得讲的很清楚。</p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;从头到尾输出链表比较简单，因为是题目要求是打印且是从尾到头，打印一般不允许我们改原链表结构的，所以反向链表在从头打印不行的，我们有两个思路：</p>
<ol>
<li>考虑用递归来实现，链表最后一个节点的next节点为空，这也是我们递归结束条件。如果链表当前节点的next不为空，我们递归先打印它的next节点，但是递归都怕栈溢出。</li>
</ol>
<ol>
<li>考虑到这个类似先进后出，可用数据结构栈来实现这种顺序,但是没有递归简洁，而且先要遍历一遍存入栈，然后在出栈。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> import java.util.ArrayList;</div><div class="line"> public class Solution &#123;</div><div class="line"> </div><div class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        //递归结束条件  </div><div class="line">        if(listNode!=null)&#123;</div><div class="line">            //递归打印它的next数组</div><div class="line">            this.printListFromTailToHead(listNode.next);</div><div class="line">            arrayList.add(listNode.val);</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">        Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;();</div><div class="line">        //链表依次进栈</div><div class="line">        while(listNode!=null)&#123;</div><div class="line">            s.push(listNode.val);</div><div class="line">            listNode=listNode.next;</div><div class="line">        &#125;</div><div class="line">        //依次出栈到输出动态数组完成逆序打印</div><div class="line">        while(!s.empty())&#123;</div><div class="line">            arrayList.add(s.pop());</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（二）</title>
    <link href="http://yoursite.com/2017/03/04/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/04/JDK源码阅读（二）/</id>
    <published>2017-03-04T06:46:22.000Z</published>
    <updated>2017-05-20T12:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK源码阅读（二）"><a href="#JDK源码阅读（二）" class="headerlink" title="JDK源码阅读（二）"></a>JDK源码阅读（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。</p>
 <a id="more"></a>
<h2 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a>总体框图</h2><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E9%9B%86%E5%90%88%E7%B1%BB.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中就说明了集合类之间的一些关系，包含接口、抽象类和实现类还有继承实现的关系。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&#160; &#160; &#160; &#160;HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。现在又出现了concurrent包里面的，我们更要知道，在并发情况下更高效。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>&#160; &#160; &#160; &#160;HashMap的底层主要是基于<font color="red">数组和链表</font>来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://images.cnitblog.com/blog/400827/201409/041358026259354.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。我们看看HashMap中Entry类的代码：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">/** Entry是单向链表。    </div><div class="line">     * 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">     *它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </div><div class="line">    **/  </div><div class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">        final K key;    </div><div class="line">        V value;    </div><div class="line">        // 指向下一个节点    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        final int hash;    </div><div class="line">   </div><div class="line">        // 构造函数。    </div><div class="line">        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">            value = v;    </div><div class="line">            next = n;    </div><div class="line">            key = k;    </div><div class="line">            hash = h;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final K getKey() &#123;    </div><div class="line">            return key;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V getValue() &#123;    </div><div class="line">            return value;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V setValue(V newValue) &#123;    </div><div class="line">            V oldValue = value;    </div><div class="line">            value = newValue;    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 判断两个Entry是否相等    </div><div class="line">        // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">        // 否则，返回false    </div><div class="line">        public final boolean equals(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry e = (Map.Entry)o;    </div><div class="line">            Object k1 = getKey();    </div><div class="line">            Object k2 = e.getKey();    </div><div class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">                Object v1 = getValue();    </div><div class="line">                Object v2 = e.getValue();    </div><div class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                    return true;    </div><div class="line">            &#125;    </div><div class="line">            return false;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 实现hashCode()    </div><div class="line">        public final int hashCode() &#123;    </div><div class="line">            return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">                   (value==null ? 0 : value.hashCode());    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final String toString() &#123;    </div><div class="line">            return getKey() + &quot;=&quot; + getValue();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当从HashMap中删除元素时，绘调用recordRemoval()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<font color="red">HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。</font>　</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><p>&#160; &#160; &#160; &#160;这是hashmap一些重要属性。</p>
<pre><code>transient Entry[] table;//存储元素的实体数组

transient int size;//存放元素的个数

int threshold; //临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量

final float loadFactor; //加载因子

transient int modCount;//被修改的次数
</code></pre><p>&#160; &#160; &#160; &#160;其中loadFactor加载因子是表示Hsah表中元素的填满的程度.</p>
<p>&#160; &#160; &#160; &#160;若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）。冲突的机会越大,则查找的成本越高.</p>
<p>&#160; &#160; &#160; &#160;因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p>
<p>&#160; &#160; &#160; &#160;如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">        //确保数字合法</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                              initialCapacity);</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                              loadFactor);</div><div class="line"></div><div class="line">        // Find a power of 2 &gt;= initialCapacity</div><div class="line">        int capacity = 1;   //初始容量</div><div class="line">        while (capacity &lt; initialCapacity)   //确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂</div><div class="line">            capacity &lt;&lt;= 1;</div><div class="line"></div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        threshold = (int)(capacity * loadFactor);</div><div class="line">        table = new Entry[capacity];</div><div class="line">       init();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    public HashMap(int initialCapacity) &#123;</div><div class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    public HashMap() &#123;</div><div class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">        table = new Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">       init();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;我们可以看到在构造HashMap的时候如果我们指定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的。默认初始容量为16，默认加载因子为0.75。我们可以看到上面代码中13-15行，这段代码的作用是确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂，至于为什么要把容量设置为2的n次幂，我们等下再看。</p>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">     // 若“key为null”，则将该键值对添加到table[0]中。</div><div class="line">         if (key == null) </div><div class="line">            return putForNullKey(value);</div><div class="line">     // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</div><div class="line">         int hash = hash(key.hashCode());</div><div class="line">     //搜索指定hash值在对应table中的索引</div><div class="line">         int i = indexFor(hash, table.length);</div><div class="line">     // 循环遍历Entry数组,若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</div><div class="line">         for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; </div><div class="line">             Object k;</div><div class="line">              if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; //如果key相同则覆盖并返回旧值</div><div class="line">                  V oldValue = e.value;</div><div class="line">                 e.value = value;</div><div class="line">                 e.recordAccess(this);</div><div class="line">                 return oldValue;</div><div class="line">              &#125;</div><div class="line">         &#125;</div><div class="line">     //修改次数+1</div><div class="line">         modCount++;</div><div class="line">     //将key-value添加到table[i]处</div><div class="line">     addEntry(hash, key, value, i);</div><div class="line">     return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>&#160; &#160; &#160; &#160;注意：第2和3行的作用就是处理key值为null的情况,如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0].我们再回去看看put方法中第4行，它是通过key的hashCode值计算hash码,得到hash码之后就会通过hash码去计算出应该存储在数组中的索引,这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private V putForNullKey(V value) &#123;</div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</div><div class="line">            if (e.key == null) &#123;   //如果有key为null的对象存在，则覆盖掉</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(0, null, value, 0); //如果键为null的话，则hash值为0</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //计算hash值的方法 通过键的hashCode来计算</div><div class="line">    static int hash(int h) &#123;</div><div class="line">        // This function ensures that hashCodes that differ only by</div><div class="line">        // constant multiples at each bit position have a bounded</div><div class="line">        // number of collisions (approximately 8 at default load factor).</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    static int indexFor(int h, int length) &#123; //根据hash值和数组长度算出索引值</div><div class="line">       //这里不能随便算取，用hash&amp;(length-1)是有原因的，</div><div class="line">       //这样可以确保算出来的索引是在数组大小范围内，不会超出</div><div class="line">         return h &amp; (length-1);  </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">         //如果要加入的位置有值，将该位置原先的值设置为新entry的next,</div><div class="line">        //也就是新entry链表的下一个节点</div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex]; </div><div class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        if (size++ &gt;= threshold) //如果大于临界值就扩容</div><div class="line">            resize(2 * table.length); //以2的倍数扩容</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。第4行和第5行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，HashMap扩容是扩为原来的两倍。resize()如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void resize(int newCapacity) &#123;</div><div class="line">        Entry[] oldTable = table;</div><div class="line">        int oldCapacity = oldTable.length;</div><div class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">        Entry[] newTable = new Entry[newCapacity];</div><div class="line">        transfer(newTable);//用来将原先table的元素全部移到newTable里面</div><div class="line">        table = newTable;  //再将newTable赋值给table</div><div class="line">        threshold = (int)(newCapacity * loadFactor);//重新计算临界值</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;新建了一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将HashMap的全部元素添加到新的HashMap中,并重新计算元素在新的数组中的索引位置</p>
<p>&#160; &#160; &#160; &#160;当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>&#160; &#160; &#160; &#160;那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小 x loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为 2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;   </div><div class="line">    if (key == null)   </div><div class="line">        return getForNullKey();   </div><div class="line">    int hash = hash(key.hashCode());   </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   </div><div class="line">        e != null;   </div><div class="line">        e = e.next) &#123;   </div><div class="line">        Object k;   </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))   </div><div class="line">            return e.value;   </div><div class="line">    &#125;   </div><div class="line">    return null;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<p>本文转自博文：<a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="external">Java集合—HashMap源码剖析</a>，感谢博主的总结。我们还可以从面试官的角度去想问题：参考<a href="http://www.importnew.com/7099.html" target="_blank" rel="external">HashMap的工作原理</a>。</p>
<h2 id="其他的map实现"><a href="#其他的map实现" class="headerlink" title="其他的map实现"></a>其他的map实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.TreeMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/3/04.</div><div class="line"> */</div><div class="line">public class mapDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        hashmap();</div><div class="line"></div><div class="line">        treemap();</div><div class="line">        </div><div class="line">        linkedmap();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //按key排序；</div><div class="line">    public static void treemap()&#123;</div><div class="line">        TreeMap&lt;String , Double&gt; map =  new TreeMap&lt;String , Double&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void hashmap()&#123;</div><div class="line">        HashMap&lt;String,Double&gt; map=new HashMap&lt;&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line">    &#125;</div><div class="line">       public static void hashmap()&#123;</div><div class="line">        HashMap&lt;String,Double&gt; map=new HashMap&lt;&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;对于LinkedHashMap，输出顺序和插入顺序一样；对于hashmap，顺序是随机的；对于treemap。当程序执行 map.put(“ccc” , 89.0); 时，系统将直接把 “ccc”-89.0 这个 Entry 放入 Map 中，这个 Entry 就是该“红黑树”的根节点。接着程序执行 map.put(“aaa” , 80.0); 时，程序会将 “aaa”-80.0 作为新节点添加到已有的红黑树中。以后每向 TreeMap 中放入一个 key-value 对，系统都需要将该 Entry 当成一个新节点，添加成已有红黑树中，通过这种方式就可保证 TreeMap 中所有 key 总是按某种规则排列。例如我们输出上面程序，将看到如下结果（所有 key 由小到大地排列）：</p>
<pre><code>{aaa=80.0, ccc=89.0, bbb=89.0, zzz=80.0}
{aaa=80.0, bbb=89.0, ccc=89.0, zzz=80.0}
{ccc=89.0, aaa=80.0, zzz=80.0, bbb=89.0}
</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>&#160; &#160; &#160; &#160;TreeMap 的实现使用了红黑树数据结构，也就是一棵自平衡的排序二叉树，这样就可以保证快速检索指定节点。对于 TreeMap 而言，它采用一种被称为“红黑树”的排序二叉树来保存 Map 中每个 Entry —— 每个 Entry 都被当成“红黑树”的一个节点对待。</p>
<p>&#160; &#160; &#160; &#160;TreeMap、TreeSet 比 HashMap、HashSet 的优势在于：TreeMap 中的所有 Entry 总是按 key 根据指定排序规则保持有序状态，TreeSet 中所有元素总是根据指定排序规则保持有序状态。但是插入性能变低。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>&#160; &#160; &#160; &#160;输出顺序按输入顺序一样，是hashmap的一个子类,也允许一个null的key。</p>
<p><img src="http://img.blog.csdn.net/20140716084631981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><img src="http://img.blog.csdn.net/20140716084409234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&#160; &#160; &#160; &#160; 关于LinkedHashMap的源码，给出以下几点比较重要的总结：</p>
<ol>
<li>从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。</li>
</ol>
<ol>
<li>实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。</li>
</ol>
<ol>
<li>注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。</li>
</ol>
<ol>
<li>注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。</li>
</ol>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>&#160; &#160; &#160; &#160;现在使用的较少了，是hashtable的线程安全版本，且不允许插入null值，效率较低，我们后面重点介绍concurrent包里面的效率较高的map。这里针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。</p>
<ol>
<li>二者的存储结构和解决冲突的方法都是相同的。</li>
<li>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</li>
<li>Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null</li>
<li>Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</li>
<li>Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共同点：</p>
<p>&#160; &#160; &#160; &#160;HashMap,LinkedHashMap,TreeMap都属于Map；Map 主要用于存储键(key)值(value)对，根据键得到值，因此键不允许键重复,但允许值重复。  </p>
<p>不同点：</p>
<ol>
<li>HashMap里面存入的键值对在取出的时候是随机的,也是我们最常用的一个Map.它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。  </li>
<li>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。  </li>
<li>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现.  (应用场景：购物车等需要顺序的)<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK源码阅读（二）&quot;&gt;&lt;a href=&quot;#JDK源码阅读（二）&quot; class=&quot;headerlink&quot; title=&quot;JDK源码阅读（二）&quot;&gt;&lt;/a&gt;JDK源码阅读（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK集合类源码" scheme="http://yoursite.com/tags/JDK%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：替换空格</title>
    <link href="http://yoursite.com/2017/03/03/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2017/03/03/剑指offer：替换空格/</id>
    <published>2017-03-03T07:23:15.000Z</published>
    <updated>2017-05-15T09:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
  <a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;C／C++中每个字符串都已字符’\0’作为结尾，这样我吗就能很方便的找到字符串的末位，但是这个特点导致字符串都有一个额外的开销。而在Java和C#中，String是不可变的，一旦试图改变，将产生一个新的实例。所以要活用StringBuilder和StringBuffer。可参考这个博文：<a href="http://blog.csdn.net/qh_java/article/details/46382265" target="_blank" rel="external">从源码角度分析Java三种字符串</a>。</p>
<p>&#160; &#160; &#160; &#160;用Java实现本题，输入的是一个StringBuffer，我们可以先定义一个返回字符串StringBuffer类型，遍历一遍字符串，使用charAt（int i）方法，如果当前字符没空字符，则使用append（char c）添加给定字符，如果不是则添加该字符。最后把StringBuffer变成String返回。使用toStirng（）方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>public String replaceSpace(StringBuffer str) {
    StringBuilder newstr =new StringBuilder();
    for(int i=0;i&lt;str.length();i++){
        if(str.charAt(i)==&apos; &apos; )
            newstr.append(&quot;%&quot;).append(&quot;2&quot;).append(&quot;0&quot;);
        else
           newstr.append(str.charAt(i));
    }
           return newstr.toString();
}
</code></pre><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（一）</title>
    <link href="http://yoursite.com/2017/03/02/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/02/JDK源码阅读（一）/</id>
    <published>2017-03-02T11:01:19.000Z</published>
    <updated>2017-05-11T06:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK源码阅读（一）"><a href="#JDK源码阅读（一）" class="headerlink" title="JDK源码阅读（一）"></a>JDK源码阅读（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;我们运行的demo的时候，肯定想看自己的结果，所以首先的基础内容就是java的格式化输出，包括保留几位小数啦、进制之间的转换，不同类型之间的转化啦。这里就给几个整理的非常好的总结博客：<a href="http://blog.csdn.net/lonely_fireworks/article/details/7962171/" target="_blank" rel="external">String.format的用法</a>、<a href="http://www.cnblogs.com/huhx/p/javaFormatter.html" target="_blank" rel="external">Formatter的用法</a>、<a href="http://blog.csdn.net/feiyudiaoling/article/details/51354413" target="_blank" rel="external">Java基础类型和字符串之间的转化</a>。而且我们看源码，不是看了就懂的，作为准备得有一定的基础知识的补充才行，补充之后在进行一定拓展我这里就按照这种方式，整理出一个系统完全的学习笔记。每个类的测试demo，我放在了Github上，传送门：<a href="">wustzoujing/Java_Learning</a>.</p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>&#160; &#160; &#160; &#160;Java中所有的类都有一个共同的祖先，它就是Object类，我们首先就学习它。他有12个成员方法。按照用途如下：构造函数 ；hashCode和equale函数用来判断对象是否相同;wait(), wait(long), wait(long,int), notify(), notifyAll() ;toString()和getClass； clone() 用途是用来另存一个当前存在的对象。；finalize() 用于在垃圾回收；</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20161205181623207" alt=""></p>
<p>这里是整理的博客，和应该关注的重点！！！</p>
<p><a href="http://www.cnblogs.com/langtianya/archive/2013/01/31/2886572.html" target="_blank" rel="external">全方法注释解析</a>。源码上英文注释，我们试着翻译一下。注意native方法。   </p>
<p><a href="http://blog.csdn.net/liuyanbohome/article/details/8899964" target="_blank" rel="external">equal和==、hashcode</a> String和hashmap等重写了这两个方法，必须一起重写，理由和怎么写？看博客。  </p>
<p><a href="http://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="external">clone。浅拷贝和深拷贝</a>  这时C++里面重要的概念，应为C++中要delete，自己回收，而java不用。</p>
<p><a href="http://longdick.iteye.com/blog/453615" target="_blank" rel="external">wait notify notifyall实例</a>    理解这三个函数的作用。</p>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>&#160; &#160; &#160; &#160;我们这里拿Integer类来学习Java中的基本数据类型，在JDK源码中有大量的位运算和空间换时间的设计来优化速度。下面是整理的重点知识。</p>
<p><a href="http://blog.csdn.net/javazejian/article/details/51192130" target="_blank" rel="external">Java中参数传递</a>。这个是在运行自己写的交换函数的时候发现的问题。Java中其实都是值传递，都是栈空间中的，要么是基本类型，要么是引用类型，就是一个地址。</p>
<p><a href="http://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="external">位运算总结</a>。位运算有判断奇偶、交换两数、变换符号及求绝对值等上的小技巧。源码在项目上。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/16799925" target="_blank" rel="external">Java中的数据类型</a>。基本分类和引用类型及详细介绍。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17684701" target="_blank" rel="external">Integer类源码解读(一)</a></p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17681787" target="_blank" rel="external">Integer类源码解读(二)</a></p>
<h2 id="String-StringBuffer-StringBuiler"><a href="#String-StringBuffer-StringBuiler" class="headerlink" title="String\StringBuffer\StringBuiler"></a>String\StringBuffer\StringBuiler</h2><p>&#160; &#160; &#160; &#160;String不final修饰的，不可变的，重写了hashcode和equal方法，compareTo方法。首先来看一下字符串常见的几个问题：</p>
<p>（1）String s = new String(“xyz”);创建了几个String 对象？<br>&#160; &#160; &#160; &#160;两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个，类似与缓存Byte数值的-128~127数值。New String每写一遍，就创建一个新的对象，那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<p>&#160; &#160; &#160; &#160;所以，凡是通过构造器创建的对象都会进行内存分配，所以他就不会指向缓存池中已有的对象而指向新的对象，这样就会造成缓存池中存在多个值相同的字符串对象，浪费资源。所以一般要直接为字符串指定值即可。</p>
<p>&#160; &#160; &#160; &#160;这里需要介绍一下缓存池：为了节省内存，提高资源的复用，jvm引入了常量池这个概念，它属于方法区的一部分，作用之一就是存放编译期间生产的各种字面量和符号引用。方法区的垃圾回收行为是比较少出现的，该区中的对象基本不会被回收，可以理解成是永久存在的。</p>
<p>（2）String s=”a”+”b”+”c”+”d”;创建了几个String对象？<br>&#160; &#160; &#160; &#160;一个，因为Javac在做编译时已经对这些字符串进行了合并操作，预先做了优化处理。</p>
<p>（3）String name = “ab”;  name = name + “c”;两条语句总共创建了多少个字符串对象？<br>&#160; &#160; &#160; &#160;创建了两个对象，这两个对象都会放到缓存池中，只是name的引用由”ab”改变为”abc”了。我们在这样用的时候，还需要考虑其他问题，如这个程序会造成内在泄漏，因为缓存池中的在缓存池中的字符串是不会被垃圾回收机制回收的，基本都是常驻内存，所以过多使用String类，可能会出现内存溢出。</p>
<p>（4）字符串比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;a&quot;;  </div><div class="line">String s2 = s1 + &quot;b&quot;;  </div><div class="line">String s3 = &quot;ab&quot;;   </div><div class="line">System.out.println(s2 == s3);//false</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;可以看到s2与s3的引用并不相同。由于s2字符串在编译时并不能进行确定，所以首先进入缓存池中的有s1和s3，随后会创建一个新的s2字符串对象，两者当然不一样了。如果程序的字符串连接表达式中没有使用变量或者调用方法，那么该字符串变量的值就能够在编译期间确定下来，并且将该字符换缓存在缓冲区中，同时让该变量指向该字符串；否则将无法利用缓冲区，因为使用了变量和调用了方法之后的字符串变量的值只能在运行期间才能确定连接式的值，也就无法在编译期间确定字符串变量的值，从而无法将字符串变量增加到缓冲区并加以利用。如果要对s1与s2加上final关键字后，结果就为true了。因为会在编译期进行优化处理。所以如果有字符串拼接之类的操作，建议使用StringBuilder类型或StringBuffer类。而StringBuffer在方法加上了同步关键字，多线程情况下使用。</p>
<p>&#160; &#160; &#160; &#160;还可以参考如下博客：</p>
<p><a href="https://my.oschina.net/jiangmitiao/blog/480549" target="_blank" rel="external">String 源码浅析</a>。</p>
<p><a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">String\StringBuffer\StringBuiler比较</a>。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK源码阅读（一）&quot;&gt;&lt;a href=&quot;#JDK源码阅读（一）&quot; class=&quot;headerlink&quot; title=&quot;JDK源码阅读（一）&quot;&gt;&lt;/a&gt;JDK源码阅读（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK基础类型源码" scheme="http://yoursite.com/tags/JDK%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：二维数组中的查找</title>
    <link href="http://yoursite.com/2017/03/02/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/03/02/剑指offer：二维数组中的查找/</id>
    <published>2017-03-02T08:28:06.000Z</published>
    <updated>2017-05-15T09:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。</p>
  <a id="more"></a>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;遍历数组能解决问题，但是由于所给数组已经部分排序，我们可以利用这个排序规则进行不必要的比较剔除，进行优化。试想如果起点是左下角，同目标值比较，如果大于目标值，整行我们就不用比较了，如果小于目标值，本行之前也都不用比较了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#160; &#160; &#160; &#160;以右上角为起点，代码如下：</p>
<pre><code>public boolean Find(int target, int [][] a) {
    // 右上角初始值，第一行最后一列。
    int j=a[0].length-1;
    int i=0;
    //循环条件
    while((j&gt;=0)&amp;&amp;i&lt;a.length){
        //大于目标值，该行之后肯定都大于目标值，只会在该行，减少列数查找
        if(a[i][j]&gt;target)
            --j;
        //小于目标指，则该行全小于目标值，往下一行查找
        else if(a[i][j]&lt;target)
            ++i;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><p>   &#160; &#160; &#160; &#160;以左下角为起点，代码如下： </p>
<pre><code>    public boolean Find(int target, int [][] a) {
    //左下角初始值，最后一行，第一列
    int i=a.length-1;
    int j=0;
    //循环条件
    while((i&gt;=0)&amp;&amp;j&lt;a[0].length){
        //大于目标值则该行都大于目标值，往上一行查找。
        if(a[i][j]&gt;target)
            --i;
        //小于目标值，则该行之前都小于目标值，结果只会在该行，再增加列数查找
        else if(a[i][j]&lt;target)
            ++j;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（一）</title>
    <link href="http://yoursite.com/2017/02/28/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/高效并发（一）/</id>
    <published>2017-02-28T05:20:54.000Z</published>
    <updated>2017-05-09T07:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型与线程（一）"><a href="#Java内存模型与线程（一）" class="headerlink" title="Java内存模型与线程（一）"></a>Java内存模型与线程（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。</p>
 <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;多任务处理在现代操作系统中几乎已是一项必备的功能了，许多情况下，让计算机同时去做几件事，只是处理器的运算能力太强大了，与通讯子系统差距太大，大部分时间花了在磁盘i／o，网络通讯和数据库访问。后来在主内存和处理器之间加入了高速缓冲区cache，java的内存模型也是参考那样的方式设计的如下图：</p>
<p><img src="http://img.my.csdn.net/uploads/201302/06/1360141335_1299.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;线程间通信的步骤：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>&#160; &#160; &#160; &#160;八种操作来完成：来完成一个变量从主内存拷贝到工作内存、以及工作内存同步回主内存之内。</p>
<ol>
<li>Lock（锁定）：作用于主内存的变量，将主内存该变量标记成当前线程私有的，其他线程无法访问。</li>
<li>Unlock（解锁）：作用于主内存的变量，解除主内存中该变量的锁定状态，让他变成线程共享变量。</li>
<li>Read（读取）：作用于主内存的变量，将该变量读取到当前线程的工作内存中，以便进行load操作。</li>
<li>Load（加载）：作用于工作内存中的变量，将read获取到的变量载入工作内存的变量副本中。</li>
<li>Use（使用）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了一个变量就会执行该操作，使用该变量。</li>
<li>Assgin（赋值）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了变量赋值的指令就会执行该操作。</li>
<li>Store（存储）：作用于工作内存中的变量，将工作内存中的变量放入主内存，以便进行write操作。</li>
<li>Write（写入）：作用于主内存中的变量，将store得到的变量放入主内存的变量中。</li>
</ol>
<p>&#160; &#160; &#160; &#160;说明：如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序的执行store和write操作。这两个操作必须按顺序执行，但是没有保证是连续执行，也就是说read与load之间、store与write之间是可插入其他指令的。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，就是对一个变量执行use和store之前必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，僵尸清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>&#160; &#160; &#160; &#160;它有两个语义：</p>
<ol>
<li>保证该变量对所以线程的可见性，但不是总能保证线程安全性，因为java的操作并非原子操作。</li>
<li>禁止指令重排序。指令重排序会干扰并发程序的执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;我们如何选择：volatile的效率是高于锁的，只是在写操作上因为防止重排序插入了内存屏障指令高于普通变量。我们重点放到只使用volatile是否就能满足我们的业务需求，而且对double和long类型变量我们一般不会用到，可能会读到半个变量。</p>
<p>&#160; &#160; &#160; &#160;Java内存模型中对volatile变量定义的特殊规则：</p>
<ol>
<li>在工作内存中，每次使用volatile变量前都必须从主内存中刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值。</li>
<li>在工作内存中，每次修改后的值都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量的修改。</li>
<li>volatile修饰的变量不会被指令重排优化，保证代码的执行顺序与程序的顺序相同。</li>
</ol>
<h2 id="内存模型的特点"><a href="#内存模型的特点" class="headerlink" title="内存模型的特点"></a>内存模型的特点</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&#160; &#160; &#160; &#160;由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们可以大致的认为基本数据类型的访问读写是具备原子性的（long和double除外）。Java代码中的同步块即synchronized关键字，因此在synchronized块之间的操作也具备原子性。内部是通过字节码指令monitorenter和monitorexit来实现。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>&#160; &#160; &#160; &#160;就是当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。关键字synchronized和final也能保证可见性。首先同步块是因为对变量执行unlock操作之前，必须先把次变量同步回主内存中。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this指针传递出去，那么在其他线程中就能看见final字段的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>&#160; &#160; &#160; &#160;用synchronized和volatile关键字来保证线程操作之间的有序性。volatile本省就包含禁止指令重排序的语义，而synchronized则是因为：一个变量在同一时刻只允许一条线程对齐进行lock操作。这个规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>&#160; &#160; &#160; &#160;如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦。java内存模型中的一个重点原则——先行发生原则（Happens-Before），使用这个原则作为依据，来指导你判断是否存在线程安全和竞争问题。</p>
<ol>
<li>程序顺序规则：在程序中，如果A操作在B操作之前（比如A代码在B代码上面，或者由A程序调用B程序），那么在这个线程中，A操作将在B操作之前执行。</li>
<li>管理锁定规则：一个unlock操作先于后面对同一个锁的lock操作之前执行。<br>volatile变量规则：对一个volatile变量的写操作必须在对该变量的读操作之前发生。</li>
<li>线程启动规则：线程的Thread.start()必须在该线程所有其他操作之前发生。</li>
<li>线程终止规则：线程中所有操作都先行发生于该线程的终止检测。可以通过Thread.join()方法结束、Thread.isAlive()的返回值判断线程是否终止。</li>
<li>线程中断规则：对线程interrupt()方法的调用必须在被中断线程的代码检测到interrupt调用之前执行。</li>
<li>对象终结规则：对象的初始化（构造函数的调用）必须在该对象的finalize()方法完成。<br>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生于C。</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>&#160; &#160; &#160; &#160;主要有三种方式：使用内核线程KLT、用户线程UT、使用用户和轻量级进程LWP混合。操作系统支持怎么样的线程模型，很大程度决定了java采用何种线程实现方式，对于java程序的编码和运行来说是差异是透明的。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>&#160; &#160; &#160; &#160;分为协同式和抢占式两种。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>&#160; &#160; &#160; &#160;分为以下几种：新建、运行、无限期等待、限期等待、阻塞、结束</p>
<p><img src="http://img.blog.csdn.net/20160717080817309" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型与线程（一）&quot;&gt;&lt;a href=&quot;#Java内存模型与线程（一）&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型与线程（一）&quot;&gt;&lt;/a&gt;Java内存模型与线程（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
