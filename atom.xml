<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jessie_Zou’s Homepage</title>
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-30T03:05:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础篇：排序（二）</title>
    <link href="http://yoursite.com/2017/04/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/30/算法基础篇：排序（二）/</id>
    <published>2017-04-30T02:07:42.000Z</published>
    <updated>2017-04-30T03:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改进排序算法及其Java实现"><a href="#改进排序算法及其Java实现" class="headerlink" title="改进排序算法及其Java实现"></a>改进排序算法及其Java实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上节讲了经典的三个排序算法，这节将对改进的排序算法进行分析，有快速排序和归并排序。对于排序和数据结构，推荐一个很棒的网站，支持能动态的看排序过程，可以单步，调节快慢：<a href="http://zh.visualgo.net" target="_blank" rel="external">学习利器</a></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&#160; &#160; &#160;&#160; 快速排序（Quicksort）是对<em>冒泡排序</em>的一种改进。</p>
<p>&#160; &#160; &#160;&#160; 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序对海量数据来说，相对其他排序方式是较快的， 他的时间复杂度比经典排序小且常系数也比较小才称为快速排序。以数组{49,38,65,97,76,13,27,49}为例，选择第一个元素49为基准,初始化关键字： [49,38,65,97,76,13,27,49]</p>
<p>&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="http://img.blog.csdn.net/20160426213936501" alt=""></p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 首先随机选择数列中的一个数（可用随机数产生，但也可以就选第一个数），然后进行一个partition函数，他的思想是扫描一遍数列把大于这个基数的数都放在右边，小于这个基数的数都放在左边。最后利用分治的思想，对基数的右边和左边分别在进行这个partition操作，最后数列就有序了。我这里为了代码尽量简洁，写出以下代码。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>//快速排序，s代表数列，l是数列第一项索引，r是数列最后一项的索引
public static void quicksort(int[] s,int l,int r){
//用i，j接住首位和末位，后面分别代表小于区间和🐠等于区间。x代表基数，这里用首位代表基数，没有随机产生
    int i=l,j=r,x=s[l];
    //执行操作条件
    if(l&lt;r){
        //循环结束条件
        while(i&lt;j){
            //从右至左找小于基数的数
            while(i&lt;j&amp;&amp;s[j]&gt;=x)
                j--;//如果大于等于基数j--，因为它们顺序正确
             //找到之后放在左边，此处精妙的使用i++
            if(i&lt;j)
                s[i++]=s[j];
            //从左至右找大于等于基数的数
            while(i&lt;j&amp;&amp;s[i]&lt;x)
                i++;
            //放在
            if(i&lt;j)
                s[j--]=s[i];
        }
        //最后把基数放在i位置上，完成了partition操作
        s[i]=x;
        //对数列左边和右边分别递归
        quicksort(s,l,i-1);
        quicksort(s,i+1,r);
    }
}
</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 基本原理如下：对于给定的一组记录，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。 经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，直到进行比较的记录只剩下一个为止。</p>
<p>&#160; &#160; &#160;&#160;以数组{50,10,90,30,70,40,80,60,20}为例，排序过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20160427172905073" alt=""></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>public static void merge(int[] a, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;// 左指针
    int j = mid + 1;// 右指针
    int k = 0;
    // 把较小的数先移到新数组中
    while (i &lt;= mid &amp;&amp; j &lt;= high) {
        if (a[i] &lt; a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i &lt;= mid) {
        temp[k++] = a[i++];
    }
    // 把右边边剩余的数移入数组
    while (j &lt;= high) {
        temp[k++] = a[j++];
    }
    // 把新数组中的数覆盖nums数组
    for (int k2 = 0; k2 &lt; temp.length; k2++) {
        a[k2 + low] = temp[k2];
    }
}

public static void mergeSort(int[] a, int low, int high) {
    int mid = (low + high) / 2;
    if (low &lt; high) {
        // 左边
        mergeSort(a, low, mid);
        // 右边
        mergeSort(a, mid + 1, high);
        // 左右归并
        merge(a, low, mid, high);
        System.out.println(Arrays.toString(a));
    }

}
</code></pre><p> &#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493531505656&amp;di=3fcca775d3be2b21bad6ac93d3a7ade9&amp;imgtype=0&amp;src=http%3A%2F%2Fimgs.aixifan.com%2Fcontent%2F2016_09_10%2F1473520477.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改进排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#改进排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;改进排序算法及其Java实现&quot;&gt;&lt;/a&gt;改进排序算法及其Java实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础篇：排序（一）</title>
    <link href="http://yoursite.com/2017/04/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/27/算法基础篇：排序（一）/</id>
    <published>2017-04-27T04:19:38.000Z</published>
    <updated>2017-04-30T02:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法及其Java实现"><a href="#基础排序算法及其Java实现" class="headerlink" title="基础排序算法及其Java实现"></a>基础排序算法及其Java实现</h1><p>##前言</p>
<p>&#160; &#160; &#160; &#160;看完了牛客网上的买的算法课程，准备首先从基础的<font color="red"><strong>数据结构</strong></font>和<font color="red"><strong>算法</strong></font>开始写。  </p>
<p>  &#160; &#160; &#160; &#160;本篇先从基础的排序开始，需要要掌握的有<em>冒泡排序</em>，<em>选择排序</em>和 <em>插入排序</em>。</p>
  <a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>  1.<em>第一次循环</em>：从0到n-2（即0&lt;=i&lt;n-1-0），每个位置上的数拿本身和后一位相比，如果比后一位大就交换两个位置的值。</p>
<p>  2.<em>第二次循环</em>：从0到n-3即（即0&lt;=i&lt;n-1-1），操作同第一次循环一样。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：0位置上的数（即0&lt;=i&lt;n-1-(n-2)），操作同第一次循环。</p>
<p>  &#160; &#160; &#160; &#160;说明：为了实现本身和后一位相比直到最后，要用内层循环实现，范围区间已在上面给出，外层共有n-1次循环，我们可以写出代码如下。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>public static int[] BubbleSort(int[] A, int n) {

    // 给变量赋初识值
    int temp,i = 0,j = 0;
    //外层循环计数如上面算法思想的减数部分
    for(;i &lt; n-1;++i){
    //内层循环来实现相邻两个比较
        for(;j&lt;n-i-1;++j){
        //前一个比后一个大，冒泡到最后
        //说明：逆序排列的话条件相反
            if(A [j] &gt; A [j+1]){
                temp = A[j];
                A[j] = A[j+1];
                A[j+1] = temp;
            }
        }
    }
    return A;
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从0到n-1（即1&lt;=i&lt;n），选出区间最小值放到位置0上。</p>
<p>  2.<em>第二次循环</em>：从1到n-1（即2&lt;=i&lt;n），选出最小值放到位置1上。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从n-2到n-1（即n-2&lt;=i&lt;n），选出最小值放在位置n-2上。</p>
<p>  &#160; &#160; &#160; &#160;说明：内层循环选取区间内的最小值，循环区间上面已给出，利用附加空间的int k来存储最小值的索引，最后和对应位置值交换，外层循环循环n-1次。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] selectSort(int[] data){
//初始化变量，需要额外的k存最小智的索引
    int i, j, k, tmp = 0;
    //外层循环，0-n-2，循环n-2次
    for (i = 0; i &lt; data.length - 1; i++) {
        //记录下区间第一个值
        k = i;
        //内层循环从区间第二个值开始比较
        for (j = i + 1; j &lt; data.length; j++)
        //更新最小值索引
            if (data[j] &lt; data[k])
                k = j;
        //如果最小值索引不是当前位置，交换他们的值
        if (k != i) {
            tmp = data[i];
            data[i] = data[k];
            data[k] = tmp;
        }
    }
    return data;
}
</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从位置1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——1区间一定有序。</p>
<p>  2.<em>第二次循环</em>：从位置2上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——2区间一定有序。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从位置n-1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——n-1区间即整个数列就有序了。</p>
<p>  &#160; &#160; &#160; &#160;说明：外层循环循环n-1次。从1到n-1，即1&lt;=i&lt;n。内层循环首先取当前索引的前一位索引，与当前索引位置的值比较，如果当前索引位置较小就交换当前索引和前一位的值，并从它的前一位开始继续向前比较。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] insertionSort(int[] A, int n) {
    // 外层循环从1——n-1，共n-1次。
    for(int i=1;i&lt;n;++i){
        //j从当前索引i前一位开始，每次比较后j递减更新当前索引位置
        for(int j=i-1;j&gt;=0;--j){
            //比较前一位和当前索引位置，如果当前位置小则交换
            if(A[j]&gt;A[j+1]){
                int temp=A[j];
                A[j]=A[j+1];
                A[j+1]=temp;
            }
            //如果当前位置大，停止内层循环
            else
                break;
        }

    }
    return A;
}
</code></pre><p>明天讲其他几种，最后试着插入一个动图！！！</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://ww2.sinaimg.cn/bmiddle/88070423gw1ep30aw8an7g204d04gkgd.gif" alt="亦菲表演机器猫"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#基础排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法及其Java实现&quot;&gt;&lt;/a&gt;基础排序算法及其Java实现&lt;/h1&gt;&lt;p&gt;##前言&lt;/p&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看完了牛客网上的买的算法课程，准备首先从基础的&lt;font color=red&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/font&gt;和&lt;font color=red&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/font&gt;开始写。  &lt;/p&gt;
&lt;p&gt;  &amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇先从基础的排序开始，需要要掌握的有&lt;em&gt;冒泡排序&lt;/em&gt;，&lt;em&gt;选择排序&lt;/em&gt;和 &lt;em&gt;插入排序&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://yoursite.com/2017/04/27/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/04/27/hexo搭建个人博客/</id>
    <published>2017-04-27T02:14:11.000Z</published>
    <updated>2017-04-27T04:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-nodejs-markdown搭建hexo"><a href="#git-nodejs-markdown搭建hexo" class="headerlink" title="git+nodejs+markdown搭建hexo"></a>git+nodejs+markdown搭建hexo</h1><h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。<br><a id="more"></a></p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p>
<p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">创始人 John Gruber 的 Markdown 语法说明</a></p>
<p><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 中文版语法说明</a></p>
<h3 id="Mac下的编辑器Mou和MacDown"><a href="#Mac下的编辑器Mou和MacDown" class="headerlink" title="Mac下的编辑器Mou和MacDown"></a>Mac下的编辑器Mou和MacDown</h3><p>代码高亮</p>
<p>Mou 和 MacDown 都支持 fenced code blocks（前后三个反引号可以表示代码块），但 MacDown 支持加语言标识符实现代码高亮，这对程序员来说简直是福音啊，非常棒的功能。</p>
<p>MacDown 支持代码高亮<br>MacDown 支持代码高亮<br>GFM Task List 支持</p>
<p>MacDown 支持 Task list，有了这个功能，你可以将你的 MD 编辑器立马变成 TODO list，是不是很赞？</p>
<p>MacDown 对 Task list 的支持<br>MacDown 对 Task list 的支持<br>Jekyll Front-matter 支持</p>
<p>很多人使用 Jekyll 作为博客引擎，这时 Jekyll 的前面那段该怎么去渲染呢？MacDown 和 github 一样可以支持。</p>
<p>MacDown 对 Jekyll front-matter 的支持<br>MacDown 对 Jekyll front-matter 的支持</p>
<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><p><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">参考链接</a></p>
<h2 id="nodejs-git-并安装hexo"><a href="#nodejs-git-并安装hexo" class="headerlink" title="nodejs+git 并安装hexo"></a>nodejs+git 并安装hexo</h2><h3 id="这个教程很多，下面给个链接"><a href="#这个教程很多，下面给个链接" class="headerlink" title="这个教程很多，下面给个链接"></a>这个教程很多，下面给个链接</h3><p><a href="http://www.jianshu.com/p/ecd51e8ef2fa" target="_blank" rel="external">参考链接</a></p>
<h2 id="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"><a href="#next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。" class="headerlink" title="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"></a>next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git-nodejs-markdown搭建hexo&quot;&gt;&lt;a href=&quot;#git-nodejs-markdown搭建hexo&quot; class=&quot;headerlink&quot; title=&quot;git+nodejs+markdown搭建hexo&quot;&gt;&lt;/a&gt;git+nodejs+markdown搭建hexo&lt;/h1&gt;&lt;h2 id=&quot;markdown语法&quot;&gt;&lt;a href=&quot;#markdown语法&quot; class=&quot;headerlink&quot; title=&quot;markdown语法&quot;&gt;&lt;/a&gt;markdown语法&lt;/h2&gt;&lt;p&gt;Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。&lt;br&gt;
    
    </summary>
    
      <category term="hexo相关" scheme="http://yoursite.com/categories/hexo%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
