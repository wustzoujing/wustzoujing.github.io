<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jessie_Zou’s Homepage</title>
  <subtitle>我的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-10T09:29:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现简易web服务器和web浏览器</title>
    <link href="http://yoursite.com/2017/05/10/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cweb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/05/10/web服务器和web浏览器的实现原理/</id>
    <published>2017-05-10T04:31:39.000Z</published>
    <updated>2017-05-10T09:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web服务器和web浏览器的实现原理"><a href="#web服务器和web浏览器的实现原理" class="headerlink" title="web服务器和web浏览器的实现原理"></a>web服务器和web浏览器的实现原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;那么，既然是网络通信。对应于Java当中来说，就自然离不开Socket与IO流。其实这也正是Web服务器与浏览器的基础实现原理。当然，想要开发一套完善的WEB服务器或浏览器，需要做的工作是很复杂的，要考虑多线程、并发、io流、网络等等。但我们想要了解的只是其原理。后面将对使用较多的servlet和tomcat在进行分析，达到一个比较深入的理解。本篇在此博客基础上进一步整理：<a href="http://blog.csdn.net/ghost_programmer/article/details/43446531" target="_blank" rel="external">浅析web服务器与浏览器的实现原理</a>。</p>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>&#160; &#160; &#160; &#160;我们知道，将开发的web项目部署到tomcat服务器之后，就可以通过浏览器对服务器上的资源进行访问。但重要的一点是，存在多种不同厂商开发的不同浏览器。但各个类型的WEB浏览器，都可以正常的访问tomcat服务器上的资源。对此，我们可以这样理解：我开发了一个WEB服务器，并且能够保证其他人开发的客户端都能够与我的服务器正常通信。</p>
<p>&#160; &#160; &#160; &#160;能够实现这样的目的的前提自然就是，你要制定一个规范，并让想要与你开发的服务器正常进行通信的客户端都遵循这个规范来实现。这个规范，也就是所谓的协议。</p>
<p>&#160; &#160; &#160; &#160;正如在网络通信中，数据的传输可以遵循TCP/IP或UDP协议一样。WEB服务器与WEB浏览器之间，也通过一种双方都熟悉的语言进行通信。这种协议即是：超文本传输协议，也就是HTTP协议。不同的是，TCP/IP与UDP议是传输层当中的通信协议，而HTTP协议是应用层当中的协议。</p>
<p>&#160; &#160; &#160; &#160;当我们想要使用Java语言实现所谓的WEB通信，自然也应当遵循HTTP协议。Java中已经为我们提供了这样的一种实现规范，也就是广为人知的：Servlet接口。而我们开发web项目时,最常用到的HttpServlet类，就是基于此接口实现的具体子类。该类封装和提供了，针对基于Http协议通信的内容进行访问和操作的常用方法。</p>
<h2 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h2><p>&#160; &#160; &#160; &#160;首先，我们通过一段简单的Servlet代码来看一下，基于HTTP协议进行WEB通信的请求信息。我的环境是os x+idea+tomcat7，项目工程我放在github上，链接传送门：<a href="https://github.com/wustzoujing/MyBrowerAndMyTomcat" target="_blank" rel="external">wustzoujing/MyBrowerAndMyTomcat</a>。</p>
<p>&#160; &#160; &#160; &#160;首先要了解servlet，这个基础没有的话，可以参考这个入门教程<a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="external">servlet教程</a>。从helloworld开始做。这里我们基于HttpServlet+Tomcat，先建立一个web的项目，再写servlet测试类，然后配置web.xml，最后用tomcat发布。</p>
<p>&#160; &#160; &#160; &#160;这里贴上一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import javax.servlet.http.*;</div><div class="line">import javax.servlet.*;</div><div class="line">import java.io.IOException;</div><div class="line">import java.util.Enumeration;</div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class ServeletTest extends HttpServlet &#123;</div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        for (Enumeration e = request.getHeaderNames(); e.hasMoreElements();) &#123;</div><div class="line">            String header = (String) e.nextElement();</div><div class="line">            if (header != null)</div><div class="line">                System.out.println((new StringBuilder(String.valueOf(header)))</div><div class="line">                        .append(&quot;:&quot;).append(request.getHeader(header))</div><div class="line">                        .toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;接下来是web.xml的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</div><div class="line">		  http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd&quot;</div><div class="line">           version=&quot;3.0&quot;&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;ServeletTest&lt;/servlet-class&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"></div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/servlet/HttpServletDemo&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当我们在浏览器输入链接<a href="http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：" target="_blank" rel="external">http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host:localhost:8080</div><div class="line">accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">upgrade-insecure-requests:1</div><div class="line">cookie:JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">accept-language:zh-cn</div><div class="line">accept-encoding:gzip, deflate</div><div class="line">connection:keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在计算机网络的学习中我们就知道了，这是http请求报文的内容，我们这里再回忆一下：一个HTTP协议的请求中，通常主要包含三个部分：</p>
<ol>
<li>方法/统一资源标示符(URI)/协议/版本 </li>
<li>请求标头</li>
<li>实体主体</li>
</ol>
<p>&#160; &#160; &#160; &#160;其中方法也就是所谓的get/post之类的请求方法，统一资源标示符也就是要访问的目标资源的路径，包括协议及协议版本，这些信息被放在请求的第一行。</p>
<p>&#160; &#160; &#160; &#160;随后，紧接着的便是请求标头；请求标头通常包含了与客户端环境及请求实体主体相关的有用信息。</p>
<p>&#160; &#160; &#160; &#160;最后，在标头与实体主体之间是一个空行。它对于HTTP请求格式是很重要的，空行告诉HTTP服务器，实体主体从这里开始。</p>
<h2 id="实现最简易的Tomcat"><a href="#实现最简易的Tomcat" class="headerlink" title="实现最简易的Tomcat"></a>实现最简易的Tomcat</h2><p>&#160; &#160; &#160; &#160;前面已经说过了，我们这里想要研究的，是WEB服务器的基本实现原理。那么我们自然想要自己来实现一下所谓的WEB服务器，我们已经知道了：所谓的B/S结构，实际上就是客户端与服务器之间基于HTTP协议的网络通信。那么，肯定是离不开socket与io的，所以我们可以简单的模拟一个最简易功能的web服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line">            int length = in.read(buf);</div><div class="line">            String request = new String(buf,0,length);</div><div class="line">            //</div><div class="line">            System.out.println(request);</div><div class="line">            </div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line"></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="demo中所需理论"><a href="#demo中所需理论" class="headerlink" title="demo中所需理论"></a>demo中所需理论</h3><p>&#160; &#160; &#160; &#160;demo中我们用到了ServerSocket和Socket，这也是Java网络编程中必须知道的，分别使用与服务器端和客户端。下面我们看下区别：</p>
<h4 id="serverSocket类"><a href="#serverSocket类" class="headerlink" title="serverSocket类"></a>serverSocket类</h4><p>&#160; &#160; &#160; &#160;创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务，如：上面的ServerSocket tomcat = new ServerSocket(9090);这里指定提供监听服务的端口是9090，一台计算机可以同时提供多个服务，这些不同的服务之间通过端口号来区别，不同的端口号上提供不同的服务。</p>
<p>&#160; &#160; &#160; &#160;为了随时监听可能的Client请求，执行如下的语句：Socket s = tomcat.accept();该语句调用了ServerSocket对象的accept()方法，这个方法的执行将使Server端的程序处于等待状态，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象Link-Socket。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时，关闭ServerSocket对象：如tomcat.close()；</p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>&#160; &#160; &#160; &#160;当Client程序需要从Server端获取信息及其他服务时，应创建一个Socket对象：Socket MySocket=new Socket(“ServerComputerName”，600)；</p>
<p>&#160; &#160; &#160; &#160;Socket类的构造函数有两个参数，第一个参数是欲连接到的Server计算机的主机地址，第二个参数是该Server机上提供服务的端口号。Socket对象建立成功之后，就可以在Client和Server之间建立一个连接，并通过这个连接在两个端点之间传递数据。利用Socket类的方法getOutputStream()和getInputStream()分别获得向Socket读写数据的输入／输出流，最后将从Server端读取的数据重新返还到Server端。</p>
<p>&#160; &#160; &#160; &#160;当Server和Client端的通信结束时，可以调用Socket类的close()方法关闭Socket，拆除连接。ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的Socket与客户端的Socket，在ServerSocket 进行accept之后，就将主动权转让了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#160; &#160; &#160; &#160;服务器端程序设计：</p>
<p>&#160; &#160; &#160; &#160;在服务器端，利用ServerSocket类的构造函数ServerSocket(int port)创建一个ServerSocket类的对象，port参数传递端口，这个端口就是服务器监听连接请求的端口，如果在这时出现错误将抛出IOException异常对象，否则将创建ServerSocket对象并开始准备接收连接请求。</p>
<p>&#160; &#160; &#160; &#160;服务程序从调用ServerSocket的accept()方法开始，直到连接建立。在建立连接后，accept()返回一个最近创建的Socket对象，该Socket对象绑定了客户程序的IP地址或端口号。</p>
<p>&#160; &#160; &#160; &#160;客户端程序设计：</p>
<p>&#160; &#160; &#160; &#160;当客户程序需要与服务器程序通信时，需在客户机创建一个Socket对象。Socket类有构造函数Socket(InetAddress addr，int port)和Socket(String host，intport)，两个构造函数都创建了一个基于Socket的连接服务器端流套接字的流套接字。对于第一个InetAd-dress子类对象通过addr参数获得服务器主机的IP地址，对于第二个函数host参数包被分配到InetAddress对象中，如果没有IP地址与host参数相一致，那么将抛出UnknownHostException异常对象。两个函数都通过参数port获得服务器的端口号。假设已经建立连接了，网络API将在客户端基于Socket的流套接字中捆绑客户程序的IP地址和任意一个端口号，否则两个函数都会抛出一个IOException对象。</p>
<p>&#160; &#160; &#160; &#160;如果创建了一个Socket对象，那么它可通过get-InputStream()方法从服务程序获得输入流读传送来的信息，也可通过调用getOutputStream()方法获得输出流来发送消息。在读写活动完成之后，客户程序调用close()方法关闭流和流套接字。</p>
<h3 id="分析demo"><a href="#分析demo" class="headerlink" title="分析demo"></a>分析demo</h3><p>&#160; &#160; &#160; &#160;在demo中，我们开启一个服务器socket来监听9090端口，所以我们在通过在浏览器中输入<a href="http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：" target="_blank" rel="external">http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">服务器启动</div><div class="line">GET / HTTP/1.1</div><div class="line">Host: localhost:9090</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Cookie: JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">Accept-Language: zh-cn</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;通过成果我们看到，我们已经成功的实现了最简易的tomcat。不过这里需要注意的是，我们自己山寨的tomcat服务器当中，之所以也成功的输出了Http协议的请求体，是因为：我们是通过web浏览器进行访问的，如果通过普通的socket进行对serversocket的连接访问，是没有这些请求信息的。因为我们前面已经说过了，web浏览器与服务器之间的通信必须遵循Http协议。</p>
<h2 id="实现简易浏览器"><a href="#实现简易浏览器" class="headerlink" title="实现简易浏览器"></a>实现简易浏览器</h2><p>&#160; &#160; &#160; &#160;通过前面的学习，我相信我们现在更想把浏览器功能也实现，剖析一下，接下来我们就试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrower &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            Socket browser = new Socket(&quot;127.0.0.1&quot;, 9090);</div><div class="line">            PrintWriter pw = new PrintWriter(browser.getOutputStream(),true);</div><div class="line">            // 封装请求第一行</div><div class="line">            pw.println(&quot;GET/ HTTP/1.1&quot;);</div><div class="line">            // 封装请求头</div><div class="line">            pw.println(&quot;User-Agent: Java/1.8.0_131&quot;);</div><div class="line">            pw.println(&quot;Host: 127.0.0.1:9090&quot;);</div><div class="line">            pw.println(&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);</div><div class="line">            pw.println(&quot;Connection: keep-alive&quot;);</div><div class="line">            // 空行</div><div class="line">            pw.println();</div><div class="line">            // 封装实体主体</div><div class="line">            pw.println(&quot;UserName=JessieZou&amp;Age=22&quot;);</div><div class="line">            // 写入完毕</div><div class="line">            browser.shutdownOutput();</div><div class="line"></div><div class="line"></div><div class="line">            // 接受服务器返回信息，</div><div class="line">            InputStream in = browser.getInputStream();</div><div class="line">            //</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            //</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            System.out.println(request);</div><div class="line">            //browser.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            System.out.println(&quot;亲，出现了异常哦!&quot;);</div><div class="line">        &#125;finally&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;同时改进我们的tomcat如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line"></div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            //</div><div class="line">            System.out.println(&quot;request:&quot;+request);</div><div class="line"></div><div class="line">            PrintWriter pw = new PrintWriter(s.getOutputStream(),true);</div><div class="line">            pw.println(&quot;&lt;html&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;title&gt;LiveSession List&lt;/title&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;body&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;p style=\&quot;font-weight: bold;color: red;\&quot;&gt;welcome to MyTomcat&lt;/p&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/body&gt;&quot;);</div><div class="line">            s.close();</div><div class="line">            tomcat.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>&#160; &#160; &#160; &#160;响应行和响应标头当中，实际上是负责将相关的一些有用信息返回给我们，但这部分是不需要在浏览器中所展示的。也就是说，我们的浏览器除了应当具备获取一个完整的HTTP响应的能力之外，还应该具备解析HTTP协议响应的能力。事实上，Java也为我们提供了这样的对象，那就是URL及URLConnection对象。</p>
<p>如果我们在我们的浏览器中，植入这样的对象，来进行与服务器之间的HTTP通信，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrowser2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(&quot;http://localhost:9090&quot;);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line"></div><div class="line">            InputStream in = conn.getInputStream();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer text = new StringBuffer();</div><div class="line">            String line = null;</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                line = new String(buf, 0, length);</div><div class="line">                text.append(line);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(text);</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这次当我们再运行程序，查看输出信息，发现我们从URLConnection对象获取到的输入流当中，读取的响应信息，就如我们所愿的，只剩下了需要被解析显示在页面的响应实体的内容。实际上这也就是Java为我们提供的对象，将对HTTP协议内容的解析功能进行了封装。而究其根本来说，我们基本可以想象到，URLConnection = Socket + HTTP协议解析器。也就是说，该对象的底层除了通过Socket连接到WEB服务器之外，还封装了对HTTP协议内容的解析功能。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&#160; &#160; &#160; &#160;我们先启动服务器，然后运行浏览器模拟网页浏览的过程，首先看到服务器端收到的请求信息，打印出来的信息和上面类似，我们这里就是把请求报文显示出来。</p>
<p>&#160; &#160; &#160; &#160;紧接着，服务器收到请求进行处理后，返回资源给浏览器，于是得到输出信息，在改进后的tomcat服务器，我们封装了html，不过是静态的。如果在搭配html解析，就可以像我们浏览器一样，能先到解析的页面。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-10%20%E4%B8%8B%E5%8D%883.39.20.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;现在我们是单线程单连接，而且没有前段操作界面的实现，我们真正使用的tomcat和浏览器当然在多线程并发、io、网络、人性化操作等方面也做了大量工作进行效率优化和简化操作，美化界面。我们通过例子是去了解基本底层原理。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;a href=&quot;#web服务器和web浏览器的实现原理&quot; class=&quot;headerlink&quot; title=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;/a&gt;web服务器和web浏览器的实现原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://yoursite.com/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：斐波那契数列相关的三道题</title>
    <link href="http://yoursite.com/2017/05/09/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%89%E9%81%93%E9%A2%98/"/>
    <id>http://yoursite.com/2017/05/09/剑指offer：斐波那契数列相关的三道题/</id>
    <published>2017-05-09T12:21:41.000Z</published>
    <updated>2017-05-10T12:42:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;如果我们需要重复多次计算相同的问题，通常可以选择递归和循环两种方法，递归的代码简洁，利用分治的算法思想，但是我们就要注意递归有时候效率会很低，而且容易栈溢出，接下来几题中，我们就要主要。</p>
  <a id="more"></a>
<h1 id="斐波那契数列相关的三道题"><a href="#斐波那契数列相关的三道题" class="headerlink" title="斐波那契数列相关的三道题"></a>斐波那契数列相关的三道题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39。</li>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
<li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;第一题如果用递归做，会发现效率很低，因为我们利用f(n)=f(n-1)+f(n-2)计算f(n)，导致每次的重复计算f(n-1)、f(n-2)，其实我们已经计算过这些值了，所以我们采用非递归来做。</p>
<p>&#160; &#160; &#160; &#160;青蛙跳台阶的第一道，我们发现这就是斐波那契数列，跳到某一台阶的次数就是跳到前一格台阶的次数加上跳到前两格台阶的次数。采用和上一题一样的做法。</p>
<p>&#160; &#160; &#160; &#160;青蛙跳台阶的第二道，我们用数学归纳法可以证明f(n)=2^2-1,其实这类题目也有很多，我们直接找到通式可以得到结果，像京东的几道题，还有求极限的，有兴趣可以去了解一下。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int Fibonacci(int n) &#123;</div><div class="line"></div><div class="line">        if(n&lt;1)</div><div class="line">            return 0;</div><div class="line">        if(n==1)</div><div class="line">            return 1;</div><div class="line">        if(n==2) </div><div class="line">            return 1;</div><div class="line">        int a=1,b=1,reslut=0;</div><div class="line">        for(int i=3;i&lt;=n;++i)&#123;</div><div class="line">            reslut=a+b;</div><div class="line">            a=b;</div><div class="line">            b=reslut;</div><div class="line">        &#125;</div><div class="line">         return reslut;   </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    public int JumpFloor(int target) &#123;</div><div class="line"></div><div class="line">        if(target&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        if(target==1)&#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">        if(target==2)&#123;</div><div class="line">            return 2;</div><div class="line">        &#125;</div><div class="line">        int a=1,b=2,c=0;</div><div class="line">        for(int i=3;i&lt;=target;i++)&#123;</div><div class="line">            c=b+a;</div><div class="line">            a=b;</div><div class="line">            b=c;</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public int JumpFloorII(int target) &#123;</div><div class="line">        </div><div class="line">        if(target&lt;=0)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            int c=1;</div><div class="line">            for(int i=1;i&lt;target;i++)&#123;</div><div class="line">                c=2*c;</div><div class="line">            &#125;</div><div class="line">            return c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;如果我们需要重复多次计算相同的问题，通常可以选择递归和循环两种方法，递归的代码简洁，利用分治的算法思想，但是我们就要注意递归有时候效率会很低，而且容易栈溢出，接下来几题中，我们就要主要。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Servlet搭配工作Tomcat</title>
    <link href="http://yoursite.com/2017/05/08/Servlet%E5%8E%9F%E7%90%86%E5%92%8CTomcat%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/05/08/Servlet原理和Tomcat原理/</id>
    <published>2017-05-08T09:20:19.000Z</published>
    <updated>2017-05-10T10:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet搭配工作Tomcat"><a href="#Servlet搭配工作Tomcat" class="headerlink" title="Servlet搭配工作Tomcat"></a>Servlet搭配工作Tomcat</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;最近再看Tomcat原理与Java Web这本书，作为准备，先了解一下Servlet和Tomcat的搭配工作过程。</p>
 <a id="more"></a>
<h2 id="Tomcat与Servlet搭配工作"><a href="#Tomcat与Servlet搭配工作" class="headerlink" title="Tomcat与Servlet搭配工作"></a>Tomcat与Servlet搭配工作</h2><p> <img src="http://images.cnitblog.com/blog/384192/201302/24114945-4774512d1247438fa58c37399d3999ae.jpg" alt=""></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<h2 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h2><ol>
<li>首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet（）、doPost（）等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。</li>
<li>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。</li>
<li>Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest、ServletResponse 强转为HttpRequest 和 HttpResponse。</li>
</ol>
<h2 id="创建Servlet对象的时机："><a href="#创建Servlet对象的时机：" class="headerlink" title="创建Servlet对象的时机："></a>创建Servlet对象的时机：</h2><ol>
<li>Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。</li>
<li>在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。</li>
<li>Servlet Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的<load-on-startup>属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。</load-on-startup></li>
</ol>
<p>参考博文：<a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="external">servlet原理</a>。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet搭配工作Tomcat&quot;&gt;&lt;a href=&quot;#Servlet搭配工作Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Servlet搭配工作Tomcat&quot;&gt;&lt;/a&gt;Servlet搭配工作Tomcat&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近再看Tomcat原理与Java Web这本书，作为准备，先了解一下Servlet和Tomcat的搭配工作过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://yoursite.com/categories/Java-Web/"/>
    
    
      <category term="Servlet、Tomcat" scheme="http://yoursite.com/tags/Servlet%E3%80%81Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2017/05/07/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/05/07/剑指offer：旋转数组的最小数字/</id>
    <published>2017-05-07T11:10:20.000Z</published>
    <updated>2017-05-10T12:19:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。</p>
  <a id="more"></a>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;二分查找法的核心思想就是：每次查找都可以排除不需要查找的一半，这道题我们是可以利用这个思想的。</p>
<p>&#160; &#160; &#160; &#160;我们定义两个标志，初识是分别指向第一位和最后一位，按照题目的旋转规则，我们找到数组中间的元素，如果中间的元素位于前面的递增数组中，那他应该小于等于第二个个标志指向的元素，此时数组中最小的元素应该位于该中间元素的后面，排除了一半，利用了二分的思想；同样，如果中间元素位于后面递增子数组中，那么它应该大于等于第二个标志指向的元素。如果相等，把最高位往前移一位，最后第一个标志上就是最小值。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class minNumberInRotateArray_6 &#123;</div><div class="line"></div><div class="line">    public int minNumberInRotateArray(int [] array) &#123;</div><div class="line"></div><div class="line">        //定义两个标志指向首位索引</div><div class="line">        int low = 0 ; int high = array.length - 1;</div><div class="line">        //结束条件</div><div class="line">        while(low &lt; high)&#123;</div><div class="line">            //取中间元素</div><div class="line">            int mid = low + (high - low) / 2;</div><div class="line">            //中间元素比尾数大，最小值在后半段</div><div class="line">            if(array[mid] &gt; array[high])&#123;</div><div class="line">                low = mid + 1;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            //如果相等，高位减1</div><div class="line">            else if(array[mid] == array[high])&#123;</div><div class="line">                high = high - 1;</div><div class="line">            &#125;</div><div class="line">            //如果中间元素比尾数小，最小值在前半段</div><div class="line">            else&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //循环结束，低位标志就是最小值所在</div><div class="line">        return array[low];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/05/06/%E5%89%91%E6%8C%87offer%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/05/06/剑指offer：用两个栈实现队列/</id>
    <published>2017-05-06T10:19:11.000Z</published>
    <updated>2017-05-10T09:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。</p>
  <a id="more"></a>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道栈是先进后出，而队列是先进先出。两个栈是可以实现先进后出的，我们模拟进队列操作时，进队列都进入第一个栈，然后出队列操作时，先把栈1全部倒入栈2，栈2出栈完成出队列操作，为了保证顺序，栈2中元素还要在倒入栈1。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    //定义两个栈</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    //进队都往第一个栈进。</div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    //出队列函数</div><div class="line">    public int pop() &#123;</div><div class="line">        //如果栈1不为空，把栈1值导入栈2，完成逆序</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        //栈2栈顶出队列</div><div class="line">        int first=stack2.pop();</div><div class="line">        //这里是重点：栈2的值都要倒回栈1，因为如果不倒回，出队列操作之后，栈2还有元素，但是之</div><div class="line">        //后进队列的元素又倒回栈2，这样就乱序了，倒回保证每次栈2中先进的都在下面，整体倒入栈2</div><div class="line">        //后肯定保证是先进的元素在栈顶</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        //</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：重建二叉树</title>
    <link href="http://yoursite.com/2017/05/05/%E5%89%91%E6%8C%87offer%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/05/05/剑指offer：重建二叉树/</id>
    <published>2017-05-05T09:16:00.000Z</published>
    <updated>2017-05-10T09:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。</p>
  <a id="more"></a>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道在二叉树的前序遍历中，第一个总是根值。中序遍历中，根节点的值在序列的中间。左子树的根节点位于根节点的左边，右子树的结点在根节点的右边，因此我们需要扫描中序遍历才能找到根节点的值。找到根结点之后，中序遍历分成两部分，分别是左右子树的中序遍历，而我们在前序遍历中根据左右子树的个数就能确定左右子树的前序遍历，因此我们就能递归的完成。具体步骤如下：</p>
<ol>
<li>先进行输入序列的检查。</li>
<li>把中序序列放入一个hashmap，值为key，索引为value，这样很方便的通过前序序列中的值得到在中序遍历中的索引，很巧妙，而且时间复杂度较低。</li>
<li>利用递归完成树重建，为了代码的简洁性，写了preIn函数完成功能。具体输入参数和意义如下注释部分。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</div><div class="line">    //为空则返回空，输入检查，还可检查两者长度是否相等。</div><div class="line">    if(pre==null||in==null)&#123;</div><div class="line">          return null;</div><div class="line">    &#125;   </div><div class="line">    java.util.HashMap&lt;Integer,Integer&gt; map=new java.util.HashMap&lt;Integer,Integer&gt;();</div><div class="line">    //中序遍历进map</div><div class="line">    for(int i=0;i&lt;in.length;i++)&#123;</div><div class="line">       map.put(in[i],i); </div><div class="line">    &#125;</div><div class="line">    //交给重建函数</div><div class="line">    return preIn(pre,0,pre.length-1,in,0,in.length-1,map);</div><div class="line">&#125;</div><div class="line">//p，n，map属于不变的，这样写代码简洁一点，变得是前序遍历和中序遍历在原序列中的起止索引。</div><div class="line">public TreeNode preIn(int[] p,int pi,int pj,int[] n,int ni,int nj,java.util.HashMap&lt;Integer,Integer&gt; map)&#123;</div><div class="line">    //前序遍历开始位置大于结束位置，返回空。</div><div class="line">    if(pi&gt;pj)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    //前序遍历开始位置就是根节点。</div><div class="line">    TreeNode head =new TreeNode(p[pi]);</div><div class="line">    //获得根节点在中序序列中的索引位置</div><div class="line">    int index=map.get(p[pi]);</div><div class="line">    //递归左子树，前序遍历pi自增1就行，结束位置算法是（pi+1）+（index-1-ni），因为</div><div class="line">    //index-1为中序遍历结束位置减去ni开始位置就是中序遍历的个数，在加上pi+1就是前序遍历</div><div class="line">    //结束为止</div><div class="line">    head.left=preIn(p,pi+1,pi+index-ni,n,ni,index-1,map);</div><div class="line">    //右子树的前序开始位置为左子树结束位置自增1，结束位置是pj，中序遍历开始是根节点位置自</div><div class="line">    //增1，结束位置是nj</div><div class="line">    head.right=preIn(p,pi+index-ni+1,pj,n,index+1,nj,map);</div><div class="line">    //重建完成返回</div><div class="line">    return head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/05/04/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/05/04/剑指offer：从尾到头打印链表/</id>
    <published>2017-05-04T12:41:39.000Z</published>
    <updated>2017-05-10T09:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;补充说明：使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。在Java中我们用自定义类来表示链表，本题就给出了链表默认类。—-源自<em>百度百科</em>，觉得讲的很清楚。</p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;从头到尾输出链表比较简单，因为是题目要求是打印且是从尾到头，打印一般不允许我们改原链表结构的，所以反向链表在从头打印不行的，我们有两个思路：</p>
<ol>
<li>考虑用递归来实现，链表最后一个节点的next节点为空，这也是我们递归结束条件。如果链表当前节点的next不为空，我们递归先打印它的next节点，但是递归都怕栈溢出。</li>
</ol>
<ol>
<li>考虑到这个类似先进后出，可用数据结构栈来实现这种顺序,但是没有递归简洁，而且先要遍历一遍存入栈，然后在出栈。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> import java.util.ArrayList;</div><div class="line"> public class Solution &#123;</div><div class="line"> </div><div class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        //递归结束条件  </div><div class="line">        if(listNode!=null)&#123;</div><div class="line">            //递归打印它的next数组</div><div class="line">            this.printListFromTailToHead(listNode.next);</div><div class="line">            arrayList.add(listNode.val);</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">        Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;();</div><div class="line">        //链表依次进栈</div><div class="line">        while(listNode!=null)&#123;</div><div class="line">            s.push(listNode.val);</div><div class="line">            listNode=listNode.next;</div><div class="line">        &#125;</div><div class="line">        //依次出栈到输出动态数组完成逆序打印</div><div class="line">        while(!s.empty())&#123;</div><div class="line">            arrayList.add(s.pop());</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：替换空格</title>
    <link href="http://yoursite.com/2017/05/03/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2017/05/03/剑指offer：替换空格/</id>
    <published>2017-05-03T07:23:15.000Z</published>
    <updated>2017-05-10T09:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
  <a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;C／C++中每个字符串都已字符’\0’作为结尾，这样我吗就能很方便的找到字符串的末位，但是这个特点导致字符串都有一个额外的开销。而在Java和C#中，String是不可变的，一旦试图改变，将产生一个新的实例。所以要活用StringBuilder和StringBuffer。可参考这个博文：<a href="http://blog.csdn.net/qh_java/article/details/46382265" target="_blank" rel="external">从源码角度分析Java三种字符串</a>。</p>
<p>&#160; &#160; &#160; &#160;用Java实现本题，输入的是一个StringBuffer，我们可以先定义一个返回字符串StringBuffer类型，遍历一遍字符串，使用charAt（int i）方法，如果当前字符没空字符，则使用append（char c）添加给定字符，如果不是则添加该字符。最后把StringBuffer变成String返回。使用toStirng（）方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>public String replaceSpace(StringBuffer str) {
    StringBuilder newstr =new StringBuilder();
    for(int i=0;i&lt;str.length();i++){
        if(str.charAt(i)==&apos; &apos; )
            newstr.append(&quot;%&quot;).append(&quot;2&quot;).append(&quot;0&quot;);
        else
           newstr.append(str.charAt(i));
    }
           return newstr.toString();
}
</code></pre><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：二维数组中的查找</title>
    <link href="http://yoursite.com/2017/05/02/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/05/02/剑指offer：二维数组中的查找/</id>
    <published>2017-05-02T08:28:06.000Z</published>
    <updated>2017-05-10T09:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。</p>
  <a id="more"></a>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;遍历数组能解决问题，但是由于所给数组已经部分排序，我们可以利用这个排序规则进行不必要的比较剔除，进行优化。试想如果起点是左下角，同目标值比较，如果大于目标值，整行我们就不用比较了，如果小于目标值，本行之前也都不用比较了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#160; &#160; &#160; &#160;以右上角为起点，代码如下：</p>
<pre><code>public boolean Find(int target, int [][] a) {
    // 右上角初始值，第一行最后一列。
    int j=a[0].length-1;
    int i=0;
    //循环条件
    while((j&gt;=0)&amp;&amp;i&lt;a.length){
        //大于目标值，该行之后肯定都大于目标值，只会在该行，减少列数查找
        if(a[i][j]&gt;target)
            --j;
        //小于目标指，则该行全小于目标值，往下一行查找
        else if(a[i][j]&lt;target)
            ++i;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><p>   &#160; &#160; &#160; &#160;以左下角为起点，代码如下： </p>
<pre><code>    public boolean Find(int target, int [][] a) {
    //左下角初始值，最后一行，第一列
    int i=a.length-1;
    int j=0;
    //循环条件
    while((i&gt;=0)&amp;&amp;j&lt;a[0].length){
        //大于目标值则该行都大于目标值，往上一行查找。
        if(a[i][j]&gt;target)
            --i;
        //小于目标值，则该行之前都小于目标值，结果只会在该行，再增加列数查找
        else if(a[i][j]&lt;target)
            ++j;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>所有的剑指offer代码，我托管到GitHub上了，可以直接运行，对照博客理解思路。<a href="https://github.com/wustzoujing/Algorithm_Learning" target="_blank" rel="external">wustzoujing/Algorithm_Learning</a>。觉得还可以的麻烦fork一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（一）</title>
    <link href="http://yoursite.com/2017/03/02/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/02/JDK源码阅读（一）/</id>
    <published>2017-03-02T11:01:19.000Z</published>
    <updated>2017-05-11T06:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK源码阅读（一）"><a href="#JDK源码阅读（一）" class="headerlink" title="JDK源码阅读（一）"></a>JDK源码阅读（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;我们运行的demo的时候，肯定想看自己的结果，所以首先的基础内容就是java的格式化输出，包括保留几位小数啦、进制之间的转换，不同类型之间的转化啦。这里就给几个整理的非常好的总结博客：<a href="http://blog.csdn.net/lonely_fireworks/article/details/7962171/" target="_blank" rel="external">String.format的用法</a>、<a href="http://www.cnblogs.com/huhx/p/javaFormatter.html" target="_blank" rel="external">Formatter的用法</a>、<a href="http://blog.csdn.net/feiyudiaoling/article/details/51354413" target="_blank" rel="external">Java基础类型和字符串之间的转化</a>。而且我们看源码，不是看了就懂的，作为准备得有一定的基础知识的补充才行，补充之后在进行一定拓展我这里就按照这种方式，整理出一个系统完全的学习笔记。每个类的测试demo，我放在了Github上，传送门：<a href="">wustzoujing/Java_Learning</a>.</p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>&#160; &#160; &#160; &#160;Java中所有的类都有一个共同的祖先，它就是Object类，我们首先就学习它。他有12个成员方法。按照用途如下：构造函数 ；hashCode和equale函数用来判断对象是否相同;wait(), wait(long), wait(long,int), notify(), notifyAll() ;toString()和getClass； clone() 用途是用来另存一个当前存在的对象。；finalize() 用于在垃圾回收；</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20161205181623207" alt=""></p>
<p>这里是整理的博客，和应该关注的重点！！！</p>
<p><a href="http://www.cnblogs.com/langtianya/archive/2013/01/31/2886572.html" target="_blank" rel="external">全方法注释解析</a>。源码上英文注释，我们试着翻译一下。注意native方法。   </p>
<p><a href="http://blog.csdn.net/liuyanbohome/article/details/8899964" target="_blank" rel="external">equal和==、hashcode</a> String和hashmap等重写了这两个方法，必须一起重写，理由和怎么写？看博客。  </p>
<p><a href="http://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="external">clone。浅拷贝和深拷贝</a>  这时C++里面重要的概念，应为C++中要delete，自己回收，而java不用。</p>
<p><a href="http://longdick.iteye.com/blog/453615" target="_blank" rel="external">wait notify notifyall实例</a>    理解这三个函数的作用。</p>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>&#160; &#160; &#160; &#160;我们这里拿Integer类来学习Java中的基本数据类型，在JDK源码中有大量的位运算和空间换时间的设计来优化速度。下面是整理的重点知识。</p>
<p><a href="http://blog.csdn.net/javazejian/article/details/51192130" target="_blank" rel="external">Java中参数传递</a>。这个是在运行自己写的交换函数的时候发现的问题。Java中其实都是值传递，都是栈空间中的，要么是基本类型，要么是引用类型，就是一个地址。</p>
<p><a href="http://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="external">位运算总结</a>。位运算有判断奇偶、交换两数、变换符号及求绝对值等上的小技巧。源码在项目上。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/16799925" target="_blank" rel="external">Java中的数据类型</a>。基本分类和引用类型及详细介绍。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17684701" target="_blank" rel="external">Integer类源码解读(一)</a></p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17681787" target="_blank" rel="external">Integer类源码解读(二)</a></p>
<h2 id="String-StringBuffer-StringBuiler"><a href="#String-StringBuffer-StringBuiler" class="headerlink" title="String\StringBuffer\StringBuiler"></a>String\StringBuffer\StringBuiler</h2><p>&#160; &#160; &#160; &#160;String不final修饰的，不可变的，重写了hashcode和equal方法，compareTo方法。首先来看一下字符串常见的几个问题：</p>
<p>（1）String s = new String(“xyz”);创建了几个String 对象？<br>&#160; &#160; &#160; &#160;两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个，类似与缓存Byte数值的-128~127数值。New String每写一遍，就创建一个新的对象，那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<p>&#160; &#160; &#160; &#160;所以，凡是通过构造器创建的对象都会进行内存分配，所以他就不会指向缓存池中已有的对象而指向新的对象，这样就会造成缓存池中存在多个值相同的字符串对象，浪费资源。所以一般要直接为字符串指定值即可。</p>
<p>&#160; &#160; &#160; &#160;这里需要介绍一下缓存池：为了节省内存，提高资源的复用，jvm引入了常量池这个概念，它属于方法区的一部分，作用之一就是存放编译期间生产的各种字面量和符号引用。方法区的垃圾回收行为是比较少出现的，该区中的对象基本不会被回收，可以理解成是永久存在的。</p>
<p>（2）String s=”a”+”b”+”c”+”d”;创建了几个String对象？<br>&#160; &#160; &#160; &#160;一个，因为Javac在做编译时已经对这些字符串进行了合并操作，预先做了优化处理。</p>
<p>（3）String name = “ab”;  name = name + “c”;两条语句总共创建了多少个字符串对象？<br>&#160; &#160; &#160; &#160;创建了两个对象，这两个对象都会放到缓存池中，只是name的引用由”ab”改变为”abc”了。我们在这样用的时候，还需要考虑其他问题，如这个程序会造成内在泄漏，因为缓存池中的在缓存池中的字符串是不会被垃圾回收机制回收的，基本都是常驻内存，所以过多使用String类，可能会出现内存溢出。</p>
<p>（4）字符串比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;a&quot;;  </div><div class="line">String s2 = s1 + &quot;b&quot;;  </div><div class="line">String s3 = &quot;ab&quot;;   </div><div class="line">System.out.println(s2 == s3);//false</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;可以看到s2与s3的引用并不相同。由于s2字符串在编译时并不能进行确定，所以首先进入缓存池中的有s1和s3，随后会创建一个新的s2字符串对象，两者当然不一样了。如果程序的字符串连接表达式中没有使用变量或者调用方法，那么该字符串变量的值就能够在编译期间确定下来，并且将该字符换缓存在缓冲区中，同时让该变量指向该字符串；否则将无法利用缓冲区，因为使用了变量和调用了方法之后的字符串变量的值只能在运行期间才能确定连接式的值，也就无法在编译期间确定字符串变量的值，从而无法将字符串变量增加到缓冲区并加以利用。如果要对s1与s2加上final关键字后，结果就为true了。因为会在编译期进行优化处理。所以如果有字符串拼接之类的操作，建议使用StringBuilder类型或StringBuffer类。而StringBuffer在方法加上了同步关键字，多线程情况下使用。</p>
<p>&#160; &#160; &#160; &#160;还可以参考如下博客：</p>
<p><a href="https://my.oschina.net/jiangmitiao/blog/480549" target="_blank" rel="external">String 源码浅析</a>。</p>
<p><a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">String\StringBuffer\StringBuiler比较</a>。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDK源码阅读（一）&quot;&gt;&lt;a href=&quot;#JDK源码阅读（一）&quot; class=&quot;headerlink&quot; title=&quot;JDK源码阅读（一）&quot;&gt;&lt;/a&gt;JDK源码阅读（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK基础类型源码" scheme="http://yoursite.com/tags/JDK%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（一）</title>
    <link href="http://yoursite.com/2017/02/28/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/高效并发（一）/</id>
    <published>2017-02-28T05:20:54.000Z</published>
    <updated>2017-05-09T07:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型与线程（一）"><a href="#Java内存模型与线程（一）" class="headerlink" title="Java内存模型与线程（一）"></a>Java内存模型与线程（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。</p>
 <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;多任务处理在现代操作系统中几乎已是一项必备的功能了，许多情况下，让计算机同时去做几件事，只是处理器的运算能力太强大了，与通讯子系统差距太大，大部分时间花了在磁盘i／o，网络通讯和数据库访问。后来在主内存和处理器之间加入了高速缓冲区cache，java的内存模型也是参考那样的方式设计的如下图：</p>
<p><img src="http://img.my.csdn.net/uploads/201302/06/1360141335_1299.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;线程间通信的步骤：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>&#160; &#160; &#160; &#160;八种操作来完成：来完成一个变量从主内存拷贝到工作内存、以及工作内存同步回主内存之内。</p>
<ol>
<li>Lock（锁定）：作用于主内存的变量，将主内存该变量标记成当前线程私有的，其他线程无法访问。</li>
<li>Unlock（解锁）：作用于主内存的变量，解除主内存中该变量的锁定状态，让他变成线程共享变量。</li>
<li>Read（读取）：作用于主内存的变量，将该变量读取到当前线程的工作内存中，以便进行load操作。</li>
<li>Load（加载）：作用于工作内存中的变量，将read获取到的变量载入工作内存的变量副本中。</li>
<li>Use（使用）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了一个变量就会执行该操作，使用该变量。</li>
<li>Assgin（赋值）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了变量赋值的指令就会执行该操作。</li>
<li>Store（存储）：作用于工作内存中的变量，将工作内存中的变量放入主内存，以便进行write操作。</li>
<li>Write（写入）：作用于主内存中的变量，将store得到的变量放入主内存的变量中。</li>
</ol>
<p>&#160; &#160; &#160; &#160;说明：如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序的执行store和write操作。这两个操作必须按顺序执行，但是没有保证是连续执行，也就是说read与load之间、store与write之间是可插入其他指令的。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，就是对一个变量执行use和store之前必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，僵尸清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>&#160; &#160; &#160; &#160;它有两个语义：</p>
<ol>
<li>保证该变量对所以线程的可见性，但不是总能保证线程安全性，因为java的操作并非原子操作。</li>
<li>禁止指令重排序。指令重排序会干扰并发程序的执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;我们如何选择：volatile的效率是高于锁的，只是在写操作上因为防止重排序插入了内存屏障指令高于普通变量。我们重点放到只使用volatile是否就能满足我们的业务需求，而且对double和long类型变量我们一般不会用到，可能会读到半个变量。</p>
<p>&#160; &#160; &#160; &#160;Java内存模型中对volatile变量定义的特殊规则：</p>
<ol>
<li>在工作内存中，每次使用volatile变量前都必须从主内存中刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值。</li>
<li>在工作内存中，每次修改后的值都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量的修改。</li>
<li>volatile修饰的变量不会被指令重排优化，保证代码的执行顺序与程序的顺序相同。</li>
</ol>
<h2 id="内存模型的特点"><a href="#内存模型的特点" class="headerlink" title="内存模型的特点"></a>内存模型的特点</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&#160; &#160; &#160; &#160;由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们可以大致的认为基本数据类型的访问读写是具备原子性的（long和double除外）。Java代码中的同步块即synchronized关键字，因此在synchronized块之间的操作也具备原子性。内部是通过字节码指令monitorenter和monitorexit来实现。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>&#160; &#160; &#160; &#160;就是当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。关键字synchronized和final也能保证可见性。首先同步块是因为对变量执行unlock操作之前，必须先把次变量同步回主内存中。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this指针传递出去，那么在其他线程中就能看见final字段的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>&#160; &#160; &#160; &#160;用synchronized和volatile关键字来保证线程操作之间的有序性。volatile本省就包含禁止指令重排序的语义，而synchronized则是因为：一个变量在同一时刻只允许一条线程对齐进行lock操作。这个规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>&#160; &#160; &#160; &#160;如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦。java内存模型中的一个重点原则——先行发生原则（Happens-Before），使用这个原则作为依据，来指导你判断是否存在线程安全和竞争问题。</p>
<ol>
<li>程序顺序规则：在程序中，如果A操作在B操作之前（比如A代码在B代码上面，或者由A程序调用B程序），那么在这个线程中，A操作将在B操作之前执行。</li>
<li>管理锁定规则：一个unlock操作先于后面对同一个锁的lock操作之前执行。<br>volatile变量规则：对一个volatile变量的写操作必须在对该变量的读操作之前发生。</li>
<li>线程启动规则：线程的Thread.start()必须在该线程所有其他操作之前发生。</li>
<li>线程终止规则：线程中所有操作都先行发生于该线程的终止检测。可以通过Thread.join()方法结束、Thread.isAlive()的返回值判断线程是否终止。</li>
<li>线程中断规则：对线程interrupt()方法的调用必须在被中断线程的代码检测到interrupt调用之前执行。</li>
<li>对象终结规则：对象的初始化（构造函数的调用）必须在该对象的finalize()方法完成。<br>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生于C。</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>&#160; &#160; &#160; &#160;主要有三种方式：使用内核线程KLT、用户线程UT、使用用户和轻量级进程LWP混合。操作系统支持怎么样的线程模型，很大程度决定了java采用何种线程实现方式，对于java程序的编码和运行来说是差异是透明的。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>&#160; &#160; &#160; &#160;分为协同式和抢占式两种。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>&#160; &#160; &#160; &#160;分为以下几种：新建、运行、无限期等待、限期等待、阻塞、结束</p>
<p><img src="http://img.blog.csdn.net/20160717080817309" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存模型与线程（一）&quot;&gt;&lt;a href=&quot;#Java内存模型与线程（一）&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型与线程（一）&quot;&gt;&lt;/a&gt;Java内存模型与线程（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（四）</title>
    <link href="http://yoursite.com/2017/02/25/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/25/Java虚拟机（四）/</id>
    <published>2017-02-25T02:16:03.000Z</published>
    <updated>2017-05-09T05:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之类加载机制（四）"><a href="#JVM之类加载机制（四）" class="headerlink" title="JVM之类加载机制（四）"></a>JVM之类加载机制（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。<font color="red">而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？</font>。这是我们接下来要学习的内容。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;虚拟机把描述类的数据从calss文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<font color="red">与那些在编译期需要进行连接的工作语言不同，在Java语言里，类加载荷连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为程序提供高度的灵活性</font>，动态扩展的特性也就是依赖运行期间动态加载和动态连接这个特点实现的。如面向接口的编程。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>&#160; &#160; &#160; &#160;类从加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期共包含七个阶段，如下图：</p>
<p>&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20140105211344671" alt=""></p>
<p>&#160; &#160; &#160; &#160;其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="初始化规范"><a href="#初始化规范" class="headerlink" title="初始化规范"></a>初始化规范</h3><p>&#160; &#160; &#160; &#160;虚拟机规范中堆什么情况需要开始类加载的第一个阶段，加载并没有强制约束，但是对初始化阶段，规范了有且只有4种情况必须立即对类进行初始化。</p>
<ol>
<li>遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时（比如在使用new创建对象的时候，读取或设置一个类静态字段、调用一个类的静态方法）</li>
<li>使用java.lang.relect包的方法对类进行反射调用的时候，如果类没有进行初始化，首先出发初始化。</li>
<li>当初始化一个类，发现父类还没有进行初始化，先出发父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的哪个类），虚拟机会先初始化这个主类。</li>
</ol>
<p>&#160; &#160; &#160; &#160;以上四种是对类的主动引用，下面说几种被动引用：</p>
<ol>
<li>通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li>
<li>一个类的成员进入常量池，另一个类引用只是对常量池的引用，两个class就无关了。</li>
<li>接口加载和类加载稍微有点不同，只有真正使用到父接口的时候才会初始化。</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>&#160; &#160; &#160; &#160;接下来讲解一下类加载的全过程，也就是加载、验证、准备、解析和初始化这五个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法去访问数据的访问入口。</li>
</ol>
<p>&#160; &#160; &#160; &#160;正是因为没有指明具体的从哪获取，怎么获取，所以充满活力的开发前辈玩出了很多花样：</p>
<ol>
<li>从zip包中读取，最后成为jar，EAR，WAR格式的基础。</li>
<li>从网络中获取，比如Applet</li>
<li>从计算机运行生成，比如动态代理</li>
<li>其他文件，比如JSP</li>
<li>从数据库读取，有些中间件服务器可以把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ol>
<p>&#160; &#160; &#160; &#160;相对其他过程，加载是开发期可控性最强的阶段。可以使用系统的加载器，也可以自定义类加载器。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>文件格式验证；比如魔数、主次版本号；常量池是否含有不支持的常量类型；等等。。。经过验证才会进入内存的方法区进行存储。所以下面的几个验证阶段全部都是基于方法区的存储结构进行的。</li>
</ol>
<ol>
<li>元数据验证；验证点比如：这个类是否有父类，父亲是否成常量不允许基础的类，如果这个类不是抽象类，是否实现了父类或接口之中要求实现的索引方法，类中的字段、方法是否和父类产生了矛盾等。这一阶段主要进行语义检验，保证不存在不符合Java语言规范的元数据信息。</li>
</ol>
<ol>
<li><p>字节码检验；是最复杂的的一个阶段，主要工作是进行数据流和控制流分析。在第二个阶段堆数据类型做完校验之后，这阶段对类的方法体进行校验分析。比如：保证任何时刻操作数类型和指令码序列都能配合工作、保证跳转指令不会跳转到方法体以外的字节码指令、保证类型转换时有效的。如果通过不一定安全，不通过一定不安全。</p>
</li>
<li><p>符号引用；对类自身以外的信息进行匹配性校验。比如：全限定名能否找到该类，指定类中是否存在符合方法的字段描述符。</p>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>&#160; &#160; &#160; &#160;此阶段时正式为类变量（ 不包括实例变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配，</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>&#160; &#160; &#160; &#160;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法四类符号引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&#160; &#160; &#160; &#160;对类的静态变量，静态代码块执行初始化操作。</p>
<p>参考这边博文：<a href="http://www.cnblogs.com/ITtangtang/p/3978102.html" target="_blank" rel="external">类加载机制及反射</a>。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>&#160; &#160; &#160; &#160;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，实现这个动作的代码块称为类加载器。它在Java Applet、类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p>
<p>&#160; &#160; &#160; &#160;对任意一个类都需要由加载它的类加载器和这个类本身一同确定它在虚拟机中的唯一性。对虚拟机里来说只有两种不同的类加载器，一种是启动类加载器由C++实现，另一种就是Java写的，都继承java.lang.ClassLoader。对于开发人员来说它还进一步分为扩展类的和应用程序类的加载器。分别加载／lib/etc目录下的，和calsspath用户路径下的。</p>
<p><img src="http://img.my.csdn.net/uploads/201009/25/0_1285421756PHyZ.gif" alt=""></p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>&#160; &#160; &#160; &#160;工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。在classload的loadclass（）方法中实现。</p>
<p>&#160; &#160; &#160; &#160;好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之类加载机制（四）&quot;&gt;&lt;a href=&quot;#JVM之类加载机制（四）&quot; class=&quot;headerlink&quot; title=&quot;JVM之类加载机制（四）&quot;&gt;&lt;/a&gt;JVM之类加载机制（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;font color=red&gt;而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？&lt;/font&gt;。这是我们接下来要学习的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（三）</title>
    <link href="http://yoursite.com/2017/02/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/22/Java虚拟机（三）/</id>
    <published>2017-02-22T00:36:37.000Z</published>
    <updated>2017-05-09T02:07:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之Class文件结构（三）"><a href="#JVM之Class文件结构（三）" class="headerlink" title="JVM之Class文件结构（三）"></a>JVM之Class文件结构（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，<font color="red">越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式</font>。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。</p>
<a id="more"></a>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>&#160; &#160; &#160; &#160;Class文件是一组以8位字节为基础的二进制，各个数据项目严格按照顺序紧凑的排列Class文件之间，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。</p>
<p>&#160; &#160; &#160; &#160;虚拟机规范：Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中还有两种数据结构：无符号和表，后面的解析都要以这两种数据类型为基础。</p>
<p>&#160; &#160; &#160; &#160;无符号数属于基本的数据类型，用u1,u2,u4,u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，可以用来描述数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。</p>
<p>&#160; &#160; &#160; &#160;表是由多个无符号数或其他数据项构成的复合结构数据，整个class文件本质上就是一张表。</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>&#160; &#160; &#160; &#160;每个class文件的头四个字节被称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多图片格式在文件头都有魔数。Java中为：0XCAFFBABE；</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>&#160; &#160; &#160; &#160;紧接着4个字节存储的是Class文件的版本号：5-6是次版本，7-8是主版本。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>&#160; &#160; &#160; &#160;主次版本号之后是常量池的入口，也是与其他项目关联最多的数据类型，也是占用class文件空间最大的项目之一，同时还是第一个出现的表类型。主要存放字面量和引用。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>&#160; &#160; &#160; &#160;在常量池之后，紧接2个字节代表访问标志，包括是接口还是类，是否public，abstract，final等等。</p>
<h3 id="类索引、父亲索引与接口索引集合"><a href="#类索引、父亲索引与接口索引集合" class="headerlink" title="类索引、父亲索引与接口索引集合"></a>类索引、父亲索引与接口索引集合</h3><p>&#160; &#160; &#160; &#160;类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合。类确定了这个类的全限定名，父亲索引确定这个父类的全限定名。不允许多继承，所以父类索引直邮一个。除了object都有父类。接口索引表示这个类实现了哪些接口。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>&#160; &#160; &#160; &#160;字段表用于描述接口或类中声明的变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>&#160; &#160; &#160; &#160;访问标志、名称索引、描述符索引都表达清楚了，方法里面的代码经过编译器编译成字节码指令之后，存放在方法属性表集合中一个名为code的属性里面，属性表作为class文件格式最具扩展性的一种数据项目。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>&#160; &#160; &#160; &#160;class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<h2 id="class文件结构的发展"><a href="#class文件结构的发展" class="headerlink" title="class文件结构的发展"></a>class文件结构的发展</h2><p>&#160; &#160; &#160; &#160;上面这些属性大部分都用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;class文件是Java虚拟机执行引擎的数据入口，也是技术体系的基础支柱之一。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之Class文件结构（三）&quot;&gt;&lt;a href=&quot;#JVM之Class文件结构（三）&quot; class=&quot;headerlink&quot; title=&quot;JVM之Class文件结构（三）&quot;&gt;&lt;/a&gt;JVM之Class文件结构（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，&lt;font color=red&gt;越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式&lt;/font&gt;。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Class文件结构" scheme="http://yoursite.com/tags/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（二）</title>
    <link href="http://yoursite.com/2017/02/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/20/Java虚拟机（二）/</id>
    <published>2017-02-20T10:01:02.000Z</published>
    <updated>2017-05-08T14:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之垃圾回收机制（二）"><a href="#JVM之垃圾回收机制（二）" class="headerlink" title="JVM之垃圾回收机制（二）"></a>JVM之垃圾回收机制（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，<font color="red">我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。</font></p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说起GC，我们需要做下面三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>何时回收？</li>
<li>如何回收？</li>
</ol>
<p>&#160; &#160; &#160; &#160;现在内存的动态分配、垃圾回收技术已经相当的成熟，那我们为什么还要去学习内存分配和GC呢？答案：<font color="red">当需要排查各种OOM问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我就需要对自动化的技术实施必要的监控和调节。</font></p>
<h2 id="怎么判断对象已死？"><a href="#怎么判断对象已死？" class="headerlink" title="怎么判断对象已死？"></a>怎么判断对象已死？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>&#160; &#160; &#160; &#160;给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1；失效就减1；任何时刻为0的对象就是不可能再被使用的。</p>
<p>&#160; &#160; &#160; &#160;确定：不能解决循环引用的问题。</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>&#160; &#160; &#160; &#160;Java和C#所采用的方式，基本原理：通过一系列名为GC Roots的对象为起点，从这些根节点向下搜索，走过的路径叫引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。</p>
<p>&#160; &#160; &#160; &#160;Java语言中可作为GC Roots的对象包括：虚拟机栈中（本地变量表）引用的对象、方法区中的类静态属性引用的对象、方法区中的常量引用对象、本地方法栈中JNI，native方法引用的对象。</p>
<h2 id="引用的几个类型"><a href="#引用的几个类型" class="headerlink" title="引用的几个类型"></a>引用的几个类型</h2><p>&#160; &#160; &#160; &#160;无论是哪种方式，判断存活都与引用有关。引用概念在JDK1.2之后进行了扩充，包括四种：</p>
<ol>
<li>强引用；只要引用存在，垃圾回收器永远不会回收。</li>
<li>软引用；系统将要发生内存溢出之前，会把这些对象列进回收范围并进行第二次回收。如果还不够菜抛出异常。</li>
<li>弱引用；只能存活到下一次垃圾回收发生之前。</li>
<li>虚引用；一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过虚引用来获得实例，完全只是为了希望在对这个回收时收到一个系统通知。</li>
</ol>
<h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><p>&#160; &#160; &#160; &#160;根搜索算法不可达的对象也并不是一定被回收，这时候它处于缓刑阶段。至少要经历两次标记过程。如果发现没有引用链，那么标记一次并且进行一次筛选，条件是对象是否有必要执行finalize（），当对象没有覆盖finalize方法，或者已经被虚拟机调用过，都是为没有必要执行。</p>
<p>&#160; &#160; &#160; &#160;如果判断为有必要执行，就会放置在一个F-Queue队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalize线程区执行。但是并不承诺等待它运行结束，原因是：如果一个对象的finalize方法执行缓慢或者死循环了，其他对象将出现永久等待。</p>
<p>&#160; &#160; &#160; &#160;finalize（）是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次标记，如果对象在finalize中拯救自己—只要重新与引用链上的任何一个对象相连即可。只能自救一次，因为finalize最多使用一次。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>&#160; &#160; &#160; &#160;主要回收内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象类似。</p>
<p>&#160; &#160; &#160; &#160;判断无用的类得满足下面三个条件：</p>
<ol>
<li>加载该类的加载器已被回收</li>
<li>所有类的实例已经被回收</li>
<li>该类的java.lang.Class对象没有任何地方引用，无法反射得到。</li>
</ol>
<p>满足了也不一定回收，常用的参数如下：</p>
<ol>
<li>-verbose：class</li>
<li>-xx：+TraceClassLoading</li>
<li>-XX：+TraceClassUnLoding</li>
</ol>
<p>&#160; &#160; &#160; &#160;在大量使用反射、动态代理、CGLib等bytecode框架的时候，以及JSP、OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>&#160; &#160; &#160; &#160;首先标记出所有需要回收的对象，在标记完之后统一回收。</p>
<p>&#160; &#160; &#160; &#160;缺点：效率低，产生的碎片多。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>&#160; &#160; &#160; &#160;他将可用的内存划分为等大小的两块，每次只使用其中一块，当用完了，把存活的对象都复制到另一半上，然后把第一块的一次性清理。</p>
<p>缺点：内存利用率低</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>&#160; &#160; &#160; &#160;让所有存活的对象都向一端移动，然后直接清楚掉端边界以外的内存。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>&#160; &#160; &#160; &#160;当前商业虚拟机都常用分代收集算法，更具对象的存活周期的不同将内存划分为几块，一般是新生代和老年代，这样就可以根据各个年代的特点采用最适当的<strong>收集算法</strong>。在新生代中，每次都有大批对象死去，只有少量的存活，那就选用复制算法。（复制的内容比较少，复制少量存活对象成本），而老年代中因为对象存活率高，就必须使用标记-清理或者标记-整理。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>&#160; &#160; &#160; &#160;包含的收集器如下：<br><img src="http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg" alt=""></p>
<h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><p>&#160; &#160; &#160; &#160;单线程收集器，垃圾收集时，必须暂停所有工作线程。“Stop The World”。</p>
<p>优势：简单而高效，没有线程切换，在客户端模式是个很好选择。</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>&#160; &#160; &#160; &#160;是Serial的多线程版本（在新生代垃圾回收的时候采用多GC线程），是服务器模式下首选的新生代收集器，目前只有它能与CMS收集器配合工作。但是作为老年代的收集器，却无法和Parallel Scavenge配合工作。</p>
<p>&#160; &#160; &#160; &#160;它在单核环境中绝对不会比serial效果好，多核也不能百分之百比serial好。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-10.png" alt=""></p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>&#160; &#160; &#160; &#160;是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器，特别之处是它注重达到一个可控制的吞吐量，可通过设置参数来完成。</p>
<h3 id="serial-Old"><a href="#serial-Old" class="headerlink" title="serial Old"></a>serial Old</h3><p>&#160; &#160; &#160; &#160;是serial的老年代版本，采用的是标记-整理算法。主要意义是客户端模式下使用。如果使用在服务器模式下，主要有两个用途：搭配Parallel Scavenge使用，或者作为CMS收集器的后备预案。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-9.jpg" alt=""></p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>&#160; &#160; &#160; &#160;之前新生代 Parallel Scavenge很尴尬，因为只能喝serial old组，被单线程所拖累。知道Parallel Old出现，吞吐量优先收集器终于有了比较名副其实的应用组合。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-11.jpg" alt=""></p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>&#160; &#160; &#160; &#160;是一种以获取最短回收停顿时间为目标的收集器。目前很多一部分的Java应用都集中在服务器上，尤其注重响应速度，希望系统停顿的时间越短越好。CMS就非常符合这个要求。</p>
<p>&#160; &#160; &#160; &#160;基于标记-清除的，但是改进了分以下四步：</p>
<ol>
<li>初识标记；仍需要暂停其他线程，仅仅是标记一下GC Roots能直接关联的对象，速度很快。</li>
<li>并发标记；进行GC Roots Tracing过程</li>
<li>重新标记；仍需要暂停其他线程，修正并发标记期间，因用户程序继续运行而导致的一部分改变，会比👨‍🍳标记消耗时间长一些，比并发标记时间短。</li>
<li>并发清除；消耗时间也较长。</li>
</ol>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-12.jpg" alt=""></p>
<h4 id="CMS-优缺点"><a href="#CMS-优缺点" class="headerlink" title="CMS 优缺点"></a>CMS 优缺点</h4><p>&#160; &#160; &#160; &#160;CMS的优点很明显：并发收集、低停顿（由于进行垃圾收集的时间主要耗在并发标记与并发清除这两个过程，虽然初始标记和重新标记仍然需要暂停用户线程，但是从总体上看，这部分占用的时间相比其他两个步骤很小，所以可以认为是低停顿的）。</p>
<p>&#160; &#160; &#160; &#160;尽管如此，CMS收集器的缺点也是很明显的：</p>
<p>&#160; &#160; &#160; &#160;1.对CPU资源太敏感，这点可以这么理解，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分CPU资源，导致程序的响应速度变慢。（增量式并发收集器i-CMS）</p>
<p>&#160; &#160; &#160; &#160;2.CMS收集器无法处理浮动垃圾。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”。（调高-XX：CMSInitiatingOccupancyFraction参数，太高又会造成CMF失败，后备预案就是采用Serial收集器对老年代进行，反而效率会降低）。</p>
<p>&#160; &#160; &#160; &#160;3.由于CMS收集器是基于“标记-清除”算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存,那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次Full GC（这个后面还会提到）这个问题的解决是通过控制参数-XX:+UseCMSCompactAtFullCollection，用于在CMS垃圾收集器顶不住要进行FullGC的时候开启空间碎片的合并整理过程。相应停顿也不得不变长。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>&#160; &#160; &#160; &#160;G1时当前收集器技术中最前沿的成果。相比之前的CMS收集器又两个改进：</p>
<ol>
<li>基于标记-整理算法实现，也就是说不会产生碎片。</li>
<li>精确的控制停顿，在M毫秒哪，收集时间不超过N毫秒，这几乎已经时实时java（RTSJ）的垃圾收集器特征了。</li>
</ol>
<p>&#160; &#160; &#160; &#160;将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域厘米的垃圾堆积程度，后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域，这就是Garbage First的由来。保证有效时间内获得更高的收集效率。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>&#160; &#160; &#160; &#160;Java技术体系中所提倡的自动内存管理最终归结为自动化解决了两个问题：给内存分配对象以及回收分配给对象的内存。接下来再来说说内存分配，往大方向讲，就是在堆上分配。<br>根据设置参数和收集器的使用组合不同，内存分配机制可能不同，但是我们讲述一般性规则，分析之前先看看两种GC：</p>
<ol>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，比较频繁，回收速度也快。</li>
<li>老年代GC （Full GC／Major GC）：发生在老年代的GC，经常伴随着至少一次Minor GC，但不是绝对，速度较慢，。</li>
</ol>
<h3 id="对象优先在Eden中分配"><a href="#对象优先在Eden中分配" class="headerlink" title="对象优先在Eden中分配"></a>对象优先在Eden中分配</h3><p>&#160; &#160; &#160; &#160;大多数情况下，对象优先在新生代Eden区中分配。当Eden没有足够空间的时候，会发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>&#160; &#160; &#160; &#160;需要大量连续空间的Java对象，很长的字符串及数组等，所以程序中不要写短命大对象。（不进入Eden和Survivor时因为他们采用复制算法）。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>&#160; &#160; &#160; &#160;虚拟机给每一个对象一个年龄计数器，默认15岁。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>&#160; &#160; &#160; &#160;如果Survivor空间中相同年龄所以对象总和大于空间的一半，年龄大于等于该年龄的进入老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>&#160; &#160; &#160; &#160;发生 Minor GC时，虚拟机会检测晋升到老年代的空间是否够，如果不够就发起一次Full GC，如果小于，如果参数HannlePromotionFailure设置允许担保失败，就只会进行Minor GC；</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本次介绍了垃圾收集算法和多种收集器，以及自动内存分配的一些机制。内存回收与垃圾收集在很多时候都是影响系统性能、并发俄力的主要因素之一，虚拟机提供了多种不同收集器与大量调节参数。必须要了解每个具体收集器行为、优点缺点。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之垃圾回收机制（二）&quot;&gt;&lt;a href=&quot;#JVM之垃圾回收机制（二）&quot; class=&quot;headerlink&quot; title=&quot;JVM之垃圾回收机制（二）&quot;&gt;&lt;/a&gt;JVM之垃圾回收机制（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，&lt;font color=red&gt;我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器与内存分配策略" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>OOM异常实战</title>
    <link href="http://yoursite.com/2017/02/18/OOM%E5%BC%82%E5%B8%B8%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2017/02/18/OOM异常实战/</id>
    <published>2017-02-18T08:27:03.000Z</published>
    <updated>2017-05-09T02:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOM异常实战"><a href="#OOM异常实战" class="headerlink" title="OOM异常实战"></a>OOM异常实战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。</p>
<a id="more"></a>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>&#160; &#160; &#160; &#160;有几个重要参数设置如下：</p>
<ol>
<li><p>-Xms  堆大小的最小值设置参数</p>
</li>
<li><p>-Xmx  堆的大小最大值，如果设置为最小值一样，则不允许自动扩展。</p>
</li>
<li><p>-XX：+HeapDumpOnOutOfMemoryError  让内存溢出时Dump出当前内存堆转储快照。</p>
</li>
</ol>
<h3 id="模拟产生方法"><a href="#模拟产生方法" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制回收这些对象，就能模拟抛出OOM异常的情景。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&#160; &#160; &#160; &#160;<br>使用内存映像分析工具：Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，即要搞明白是内存泄漏还是内存溢出。 </p>
<ol>
<li>内存泄漏导致的OOM：new出来的很多对象已经不需要了，但仍然有引用指向，所以垃圾回收机制无法回收。 </li>
<li>内存溢出：new出来的对象都是需要的，但堆内存太小装不下了。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;<font color="red">如果是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。找到泄漏对象是通过怎样的路径与GC Roots发生关联，然后导致垃圾回收机制无法自动回收的。如果不存在内存泄漏，也就是所有的对象都必须存在，这时候就调大堆内存。</font></p>
<h2 id="虚拟机栈和本地方法溢出"><a href="#虚拟机栈和本地方法溢出" class="headerlink" title="虚拟机栈和本地方法溢出"></a>虚拟机栈和本地方法溢出</h2><p>&#160; &#160; &#160; &#160;在hotspot中不区分虚拟机和本地方法栈，因此对于hotspot来说，-Xoss参数存在但是无效，栈容量只由-Xss参数决定。</p>
<p>&#160; &#160; &#160; &#160;书上的实验结果表明；</p>
<ol>
<li>在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。</li>
<li>不限于单线程可以模拟出OOM，但是这种产生的内存溢出与栈空间足够大不存在联系，而且越大反而更容易产生内存溢出。原因：<font color="red">内存有限，每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程的时候就越容易把剩下的内存耗尽。</font></li>
<li>所以在多线程开发中特别注意，StackOverflowError有错误堆栈可以阅读，相对排查简单一些。大多数情况下达到1000～2000完全没有问题，对于正常的递归大多数情况下完全够用了。<font color="red">如果是多线程导致内存溢出的话，就只能减少最大堆或者栈的容量来获得更多的线程。</font></li>
</ol>
<h2 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h2><h3 id="模拟产生方法-1"><a href="#模拟产生方法-1" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果要向运行时内存中添加内容，最简单的方式是使用string.intern（）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：PermSize        &#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：MaxPermSize。溢出后提示信息是PermGen space。</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>&#160; &#160; &#160; &#160;方法区存放class信息，比如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<h3 id="模拟产生方法-2"><a href="#模拟产生方法-2" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;产生许多类区填满方法区，直到溢出。还可以反射和动态代理，还可以用CGLIB直接操作字符码，生成动态类。（框架中精彩需要对类进行增强，都会使用到CGLIB，增强的类越多，就需要越大的方法区保证动态生成的class可以加载入内存）。</p>
<p>&#160; &#160; &#160; &#160;方法区溢出也是常见的内存溢出，一个类如果要被垃圾收集器回收掉条件是十分苛刻的。在动态生成大量Class文件的应用中，需要特别注意类的回收状况。常见的还有JSP应用。</p>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>-XX：MaxDirectMemorySize，如果不指定默认和堆一样大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OOM异常实战&quot;&gt;&lt;a href=&quot;#OOM异常实战&quot; class=&quot;headerlink&quot; title=&quot;OOM异常实战&quot;&gt;&lt;/a&gt;OOM异常实战&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM进阶" scheme="http://yoursite.com/categories/JVM%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="OOM异常" scheme="http://yoursite.com/tags/OOM%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机（一）</title>
    <link href="http://yoursite.com/2017/02/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/15/Java虚拟机（一）/</id>
    <published>2017-02-15T03:09:08.000Z</published>
    <updated>2017-05-08T08:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之自动内存管理机制（一）"><a href="#JVM之自动内存管理机制（一）" class="headerlink" title="JVM之自动内存管理机制（一）"></a>JVM之自动内存管理机制（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这段时间准备整理下JVM的知识，了解Java就必须了解java虚拟机的特性，本节先从Java的自动内存管理机制来讲起，有一句话：<font color="red">Java与C++之间有一堵由内存动态分配和垃圾手机技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</font></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&#160; &#160; &#160; &#160;在c和c++中的内存管理领域，程序员拥有最高权力的皇帝，拥有每一个对象的所有权，又担负着每一个对象生命开始到结束的责任。对于java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new对象配对delete／free代码，而且不太容易出现内存泄漏和溢出。正是因为这样，Java程序员没有了掌控权，排除问题的时候将是异常艰难的工作。了解内存的各个区域，是翻越这个高墙的第一步。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>&#160; &#160; &#160; &#160;虚拟机在执行java程序的时候会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途、创建和销毁的时间。如下图所示：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://dl.iteye.com/upload/picture/pic/115264/4991b17e-a8b4-3d0a-a316-4651bb23da5e.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol>
<li>是一个较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器工作时就是通过改变这个计数起的值来选取下一条需要执行的字节码指令。</li>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能都依赖计算器。</li>
<li>多线程时通过线程轮流切换并分配处理器执行时间的方式来实现的。</li>
<li>由于在任何一个确定的时刻，一个处理器只能处理一个线程，所以每个线程应该需要一个独立的程序计数器，所以它被称为<font color="red">线程私有。</font></li>
<li>如果正在执行native方法，程序计数器为空。</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ol>
<li>也是线程私有，生命周期和线程一样。</li>
<li>虚拟机栈描述的是Java方法执行的内存模型：每个方法一行的时候都会产生一个栈帧，它用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法调用直到完成就对应一个栈帧在虚拟机栈入栈道出栈的过程</li>
<li>局部变量表存放了编译器可知的各种数据类型，包括基本类型和引用类型（这里只是一个地址）和retrunAddress类型（指向一条字节码指令的地址）。</li>
<li>在这个区域定义了两个异常：StackOverflowError异常，栈深度大于虚拟机所允许的栈深度，栈溢出，和OutOfMemoryError，即OOM，表示动态扩展的虚拟机无法申请到足够内存时会抛出的异常。</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&#160; &#160; &#160; &#160;其实只不过是区别于虚拟机栈所执行方法的不同，虚拟机栈执行Java方法，本地方法栈执行native方法。比如hotspot虚拟机就把本地方法栈和虚拟机合二为一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ol>
<li>是虚拟机所管理的内存中的最大一块，Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。</li>
<li>存放的都是对象的实例，几乎所有的对象实例都在这里分配内存。随着及时动态编译器jit的发展和逃逸分析技术的逐渐成熟，所有的对象都分配在堆上也不是那么绝对。</li>
<li>Java堆事垃圾回收的主要区域，也被称为GC堆。垃圾回收一般采用分代收集算法，堆中细分的话可分：新生代、老生代或者、Eden、From Survivor、To Survivor等。</li>
<li>线程共享的Java堆可能划分出多个线程私有的分配缓冲区，不过存放内容都是对象，进一步划分事为了更好的回收对象。</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol>
<li>和Java堆一样，是各个线程共享的区域，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。是堆的一个逻辑部分，但是别名NonHeap，非堆。</li>
<li>垃圾收集行为在此区域较少发生，但并非永久代，对常量池的回收和类的卸载。</li>
<li>此区域无法满足内存分配时，会抛出OOM异常。</li>
<li>运行时常量池时方法区的一部分，编译期已经确定的字面量和符号引用，类加载完之后就存放到方法区的运行时常量池中。</li>
<li>不一定都在编译的时候放入常量池，比如string的intern（）方法，可把新的常量放入池中。常量池也会报OOM异常。</li>
</ol>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ol>
<li>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范汇总的内存区域，但是被频繁使用，而且可能导致OOM异常，比如NIO，引用了一种基于通道与缓冲区的I／O方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能显著的提高性能，因为避免了在Java堆和native堆中来回复制数据。</li>
<li>显然直接内存不会受到堆大小的限制，但是内存都收到系统内存限制。也可能出现OOM。</li>
</ol>
<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>&#160; &#160; &#160; &#160;我们分析一下下面这个简单代码的运行过程：</p>
<pre><code>Object obj=new Object();
</code></pre><p>&#160; &#160; &#160; &#160;这句代码中，Object obj 这部分的语义将会反映到java栈的本地变量表中，作为一个ref引用类型数据出现，而new Object（）这部分语义反映到堆中，形成一块存储了object类型所有实例数据值的结构内存，具体类型以及虚拟机实现的对象内存分布不同。另外，对象类型、父类、实现的接口、方法等信息存储在方法区中，保证能查找到对象类型数据的地址信息。</p>
<p>&#160; &#160; &#160; &#160;主流的访问方式有两种：</p>
<ol>
<li>使用句柄方式，堆中还会划分出一个内存来作为句柄池，ref中存储的就是对象的句柄地址，句柄中又包含对象实例和对象类型的指针。好处是存储的是稳定的地址，在对象移动时只改变句柄中的，不用改变ref的。</li>
<li>使用直接指针访问方式，ref中直接存储就是对象地址。最大好处就是速度更快，节省了一次指针定位的时间。hotspot就是采用这种。</li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之自动内存管理机制（一）&quot;&gt;&lt;a href=&quot;#JVM之自动内存管理机制（一）&quot; class=&quot;headerlink&quot; title=&quot;JVM之自动内存管理机制（一）&quot;&gt;&lt;/a&gt;JVM之自动内存管理机制（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这段时间准备整理下JVM的知识，了解Java就必须了解java虚拟机的特性，本节先从Java的自动内存管理机制来讲起，有一句话：&lt;font color=red&gt;Java与C++之间有一堵由内存动态分配和垃圾手机技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="自动内存管理机制" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（二）</title>
    <link href="http://yoursite.com/2017/02/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/10/Java基础之面向对象（二）/</id>
    <published>2017-02-10T07:25:36.000Z</published>
    <updated>2017-05-08T03:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（二）"><a href="#Java面向对象特性（二）" class="headerlink" title="Java面向对象特性（二）"></a>Java面向对象特性（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;本篇继续讲面向对象特性，自动装箱和拆箱，抽象和接口，内部类和lambda表达式，枚举类型等方面。</p>
  <a id="more"></a>
<h2 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h2><p>&#160; &#160; &#160; &#160;JDK 1.5之前，Java有8个基本数据类型不能当前Object类型，之后就才用自动装箱和拆箱，可以把一个基本数据类型直接赋值给包装类变量，也可以把包装类对象直接复制给一个对应的基本数据类型。</p>
<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><p>&#160; &#160; &#160; &#160;用static关键字修饰的成员就是类成员，static语义代表的是修饰的对象属于整个类而不属于任何实例。</p>
<p>&#160; &#160; &#160; &#160;Java中只能包括五种：成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）、以static修饰的成员就是类成员，他能修饰除构造器之外的其他四种。</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>&#160; &#160; &#160; &#160;在一些特殊场景下，要求不允许自由创建该类的对象，而只允许为该类创建一个对象，为了避免该类被自由创建，类的构造器使用private修饰，从而把该类的所有构造器隐藏起来。但是还要有一个public方法作为该类的访问点，用于创建该类的对象，且该方法必须使用static修饰，除此之外，该类还不许知道已经缓存过已经创建的对象，否则该类无法知道是否创建过该对象。下面就手写代码实现一个单例类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;但是这也只是懒汉，单线程情况，还有几种写法参考博客：<a href="https://www.oschina.net/code/snippet_107039_6062" target="_blank" rel="external">单例的5种写法</a>。</p>
<h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><p>&#160; &#160; &#160; &#160;final关键字可以修饰类、变量和方法，用于它修饰的类，方法和变量不可变，类似C#中的sealed。修饰变量包括成员变量和局部变量和形参。准确说是一旦赋类初始值就不能被改变。final还可以完成C中宏定义的类似功能。</p>
<h3 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h3><p>&#160; &#160; &#160; &#160;final修饰的成员变量必须由程序员显式的指定初始值。</p>
<h3 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3><p>&#160; &#160; &#160; &#160; 系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。但是用final修饰局部变量时，既可以在定义时，指定默认初始值，也可以不指定。</p>
<h3 id="final修饰基本变量和引用变量区别"><a href="#final修饰基本变量和引用变量区别" class="headerlink" title="final修饰基本变量和引用变量区别"></a>final修饰基本变量和引用变量区别</h3><p>&#160; &#160; &#160; &#160;当使用final修饰基本变量时，不能对基本变量类型进行重新赋值，但对引用来说，仅仅是一个引用地址，final只能保证引用类型变量指定的地址不会改变，一直引用一个对象，但这个对象完全可以发生改变。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>&#160; &#160; &#160; &#160;不想子类重写的可以用final修饰，比如Object中的getClass（）方法。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&#160; &#160; &#160; &#160;final类不能使用子类，比如Math类就是。保证不能被继承。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>&#160; &#160; &#160; &#160;当编写一个类时候，常常会给类定义一些方法，比如形状类Shape，应该提供一个计算周长的方法，但是Shape类型不同计算周长方式不同，这时我们可以使用抽象方法，只有方法签名，没有方法实现。</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ol>
<li>都必须使用abstract修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，<font color="red">无法使用new来调用构造器实例对象，即使不包含抽象方法。</font></li>
<li>抽象类可以包含成员变量、方法、构造器、初始化块、内部类5个成分。主要作用是被其子类调用。</li>
<li>含有抽象方法的类：包括直接定义来一个抽象方法，继承一个抽象父类，但没有完全实现父类包含的抽象方法，或者实现了一个接口但没有完全实现接口包含的抽象方法这三种情况）只能被定义为抽象类。</li>
<li>不能用来修饰成员变量、局部变量、构造器。</li>
<li>static和abstract不同时修饰一个方法，即没有所谓的类静态抽象方法。但也不是绝对互斥，它们可以修饰内部类。</li>
<li>private和abstract不同时修饰方法。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&#160; &#160; &#160; &#160;在Java8中对接口进行了改进，允许接口中定义默认方法，默认方法可以提供方法实现。默认方法必须使用default修饰，且不能被static修饰。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&#160; &#160; &#160; &#160;接口是从多个相似类中抽象出来的规范，规范了它实现类的基本行为规范。接口使用interface关键字。仿佛默认使用public修饰。</p>
<p>&#160; &#160; &#160; &#160;Java8中允许接口中定义类方法，必须使用statci修饰，该方法可以使用接口来调用。</p>
<p>&#160; &#160; &#160; &#160;接口成员默认使用public static final修饰。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>接口支持多继承；</li>
<li>接口不能创建实例；</li>
<li>接口的实现类 implents；实现类可实现多个接口。</li>
</ol>
<h2 id="抽象和接口的比较"><a href="#抽象和接口的比较" class="headerlink" title="抽象和接口的比较"></a>抽象和接口的比较</h2><p>&#160; &#160; &#160; &#160;一般接口来控制行为规范，抽象类用来定型。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>参考这篇博客：<a href="http://www.cnblogs.com/yongjiapei/p/5494894.html" target="_blank" rel="external">抽象和接口的区别</a>。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="实现简单工厂模式"><a href="#实现简单工厂模式" class="headerlink" title="实现简单工厂模式"></a>实现简单工厂模式</h3><p><a href="http://www.cnblogs.com/toutou/p/4899388.html" target="_blank" rel="external">详解工厂模式三种类型</a></p>
<h3 id="实现命令模式"><a href="#实现命令模式" class="headerlink" title="实现命令模式"></a>实现命令模式</h3><p><a href="http://blog.csdn.net/jason0539/article/details/45110355" target="_blank" rel="external">Java命令模式实现</a></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><ol>
<li>非静态内部类可以访问外部private成员。</li>
<li>优先在局部变量中寻找。</li>
<li>外部不能访问非静态内部类的private成员。</li>
<li>非静态内部类中不能定义静态成员。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>静态内部类中可以包含静态、非静态成员都可以。</li>
<li>静态类不能访问外部成员，只能是访问静态成员。</li>
<li>静态内部类是外部类的一个静态成员，因此外部类的所有成员可以使用静态内部类来定义，创建对象，但是不能直接访问静态内部类的成员。</li>
<li>接口中也能定义内部类，接口中只能是静态内部类，默认使用public static。</li>
</ol>
<h2 id="内部类的使用"><a href="#内部类的使用" class="headerlink" title="内部类的使用"></a>内部类的使用</h2><ol>
<li>外部类内部使用内部类：和普通类没有太大区别，唯一区别是：不要在外部类中的静态成员中使用非静态的内部类。</li>
<li>在外部类以外使用非静态内部类：如果希望被访问，不能使用private。</li>
<li>外部类以外访问静态内部类，无须实例外部类。</li>
<li>局部内部类，在方法里，只能在方法内使用。</li>
</ol>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>&#160; &#160; &#160; &#160;适合创建那种只需要一次使用的类，类如命令模式中的command对象。匿名内部类必须继承一个父类或实现一个接口，但最多继承一个父类或实现一个接口。不允许为抽象类，不能定义构造器，因为没有类名，但可以定义初始化块来完成构造器要完成的事情。</p>
<p>&#160; &#160; &#160; &#160;在Java8之前，Java要求局部内部类、匿名内部类访问的局部变量必须使用final修饰，从Java8开始这个限制被取消了，Java8更加智能，自动添加final。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html" target="_blank" rel="external">匿名内部类总结</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>&#160; &#160; &#160; &#160;允许用更简单的代码来创建只有一个抽象方法的接口，即函数式接口。lambda表达式完全可用于简化创建匿名内部类对象。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>&#160; &#160; &#160; &#160;早期会用简单的静态变量来表示枚举，但是类型不安全，没有命名空间，意义不明确，后来用类来封装，但是额外要写代码，JDK1.5之后增加了对枚举类的支持。enum。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/oumyye/p/4232532.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（二）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（二）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（二）&quot;&gt;&lt;/a&gt;Java面向对象特性（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇继续讲面向对象特性，自动装箱和拆箱，抽象和接口，内部类和lambda表达式，枚举类型等方面。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（一）</title>
    <link href="http://yoursite.com/2017/02/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/08/Java基础之面向对象（一）/</id>
    <published>2017-02-08T04:38:25.000Z</published>
    <updated>2017-05-07T07:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（一）"><a href="#Java面向对象特性（一）" class="headerlink" title="Java面向对象特性（一）"></a>Java面向对象特性（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。</p>
  <a id="more"></a>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>&#160; &#160; &#160; &#160;区分类和对象，由类实例出对象，怎么去定义一个类，怎么通过类的构造器实例一个对象。类中有属性和方法。方法有构造方法和普通方法。属性有成员变量和局部变量。构造器没有返回值，返回值时隐式的。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>&#160; &#160; &#160; &#160;如果没有构造器，会默认提供一个无参数的构造器，构造器最大的用处是在创建对象时执行，创建一个对象的时候会执行初始化：所有基本类型0，布尔为false，引用类型为null。构造器也不是完全负责创建Java对象，new的时候已经开辟了内存空间，只不过智能字啊构造器中通过this使用，构造器用来返回一个对象，通常还会赋值给一个引用变量。</p>
<p>&#160; &#160; &#160; &#160;构造器也可以像方法一样重载。</p>
<h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>&#160; &#160; &#160; &#160;方法在逻辑上要么属于类，要么属于对象。方法是类或对象的行为特征的抽象。类似传统结构化程序中的函数。</p>
<p>&#160; &#160; &#160; &#160;方法的参数可以指定个数，也可以可变个数，就是当成数组传入。参数传递机制有值传递和引用传递。基本类型是值传递，引用类型是引用传递。</p>
<p>&#160; &#160; &#160; &#160;方法体内调用他自己，该方法就是递归方法。包含了一种隐式的循环，所以理论上递归都可以转为循环。</p>
<p>&#160; &#160; &#160; &#160;类中方法是可以重载的，就是允许方法名一样，但是参数不一样。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&#160; &#160; &#160; &#160;类中的变量分为成员变量和局部变量，成员变量不在方法体内，分为静态和非静态的，即类成员和实力成员变量，而局部变量一般包括形参、方法的局部变量（定义在方法内）、代码块的局部变量（在代码块内，例如for循环内部）。</p>
<p>&#160; &#160; &#160; &#160;这些的不同必然导致了变量的访问方式、作用范围和生命周期等方面必然有不同。</p>
<p>&#160; &#160; &#160; &#160;局部变量必须显式的初始化才能使用，而成员变量类加载的时候已经赋了初值。局部变量不属于任何实例或者类，他在方法的栈内存中，往往是基本类型和对象的引用。方法执行完就释放。</p>
<p>&#160; &#160; &#160; &#160;了解这些之后我们要合适选择变量类型。准确控制变量的作用域。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>&#160; &#160; &#160; &#160;它指将对象的状态信息部分隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作和访问。具体该怎么实现呢，适用访问控制符。</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>&#160; &#160; &#160; &#160;有下面四种private、default（friendly）、protected、public四种，比较如下图：</p>
<p><img src="http://img.blog.csdn.net/20160908104619224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>&#160; &#160; &#160; &#160;有这三个要掌握：package、import、import static；Java默认导入java.lang包下的所有类。下面列出常用包：</p>
<p> <img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E5%8C%85.png" alt=""></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&#160; &#160; &#160; &#160;Java是单继承多接口，用关键字extends实现。子类继承负累所有成员变量和方法，值得指出的是：子类不能获得父类的构造器。</p>
<h3 id="重写（覆盖）父类方法"><a href="#重写（覆盖）父类方法" class="headerlink" title="重写（覆盖）父类方法"></a>重写（覆盖）父类方法</h3><p>&#160; &#160; &#160; &#160;override，遵守两同两小一大原则：方法名、参数相同；子类返回值类型应该比父类更小或者相等、子类抛出的异常也应该比父类更小或者相等；子类方法的访问权限应该比父类更大或者相等。而且要么都是类方法，要么都是实例方法。</p>
<h3 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h3><pre><code>super....//使用父类方法或属性
this....// 使用类本身方法或属性
</code></pre><h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><p>&#160; &#160; &#160; &#160;从运行过程上看，创建任何对象时总是从该类所在继承树的最顶层类的构造器开始执行，然后依次向下执行，最后才执行本来的构造器。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>&#160; &#160; &#160; &#160;Java引用变量有两个类型，一个是编译时类型，一个时运行时类型。编译类型由声明该变量的类型决定，运行时类型由实际赋值给变量的类型决定，如果出现不一致，就可能出现所谓的多态。例如：</p>
<pre><code>SuperClass base=new SubClass();
</code></pre><p>&#160; &#160; &#160; &#160;因为子类是一个特殊的父类，因此允许把一个子类对象直接赋值给一个父类的引用类型。无须任何类型转换，精确的说时向上转型，向上转型由系统自动完成。但是编译时父类对象无法调用子类方法（可以利用反射来执行该方法）。</p>
<h2 id="强制类型转换和instanceof-运算符"><a href="#强制类型转换和instanceof-运算符" class="headerlink" title="强制类型转换和instanceof 运算符"></a>强制类型转换和instanceof 运算符</h2><pre><code>double d=113.4
long l=(long)d;
Objext hello=&quot;hello&quot;;
if(hello instanceof Object){
....
}
if(hello instanceof String){
....
}
</code></pre><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>&#160; &#160; &#160; &#160;继承是实现类复用的重要手段，但继承带来一个最大的坏处：破坏了封装，相比之下，组合也是实现类复用的重要方式。</p>
<p>&#160; &#160; &#160; &#160;继承在高可用的同时，暴漏了父类的实现细节，且子类还可以任意篡改，所以父类不想子类改变的属性方法应该使用private修饰符，还可以通过final修饰符控制不让子类改变。</p>
<p>&#160; &#160; &#160; &#160;被final修饰的类时不可变的，不能当作父类，如String。</p>
<h2 id="初识化块"><a href="#初识化块" class="headerlink" title="初识化块"></a>初识化块</h2><p>&#160; &#160; &#160; &#160;初始化块是类出现的第四种成员，前面依次由成员变量、方法和构造器，一个类里可以有多个初始化块。初始化块的修饰符只能是static，而且创建对象时，总是先执行初始化块，按出现顺序在执行构造器。</p>
<p>&#160; &#160; &#160; &#160;从某种程度上看，初始化块是构造器的补充。初始化块总是在构造器执行之前执行，系统通用可食用初始化块啦进行对象的初始化操作。</p>
<p>&#160; &#160; &#160; &#160;静态初始化块：在类加载的时候执行，而不是像之前那种在对象加载的时候执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本章主要介绍了Java面向对象的基本知识，包括如何定义类，如何为类成员添加成员变量、方法，以及如何创建类的对象。深入分析对象和引用变量之间的关系，方法的参数传递机制、重载，访问控制符等，三种面向对象特性的分析。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（一）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（一）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（一）&quot;&gt;&lt;/a&gt;Java面向对象特性（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（五）</title>
    <link href="http://yoursite.com/2017/02/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/05/深入理解mysql（五）/</id>
    <published>2017-02-05T11:35:48.000Z</published>
    <updated>2017-05-07T03:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（五）"><a href="#mysql学习笔记（五）" class="headerlink" title="mysql学习笔记（五）"></a>mysql学习笔记（五）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。</p>
  <a id="more"></a>
<h2 id="sql语句的技巧"><a href="#sql语句的技巧" class="headerlink" title="sql语句的技巧"></a>sql语句的技巧</h2><h3 id="group-by和having"><a href="#group-by和having" class="headerlink" title="group by和having"></a>group by和having</h3><p>&#160; &#160; &#160; &#160;在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度.例子如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""></p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""><br>&#160; &#160; &#160; &#160;<font color="red">在group by 后面增加 order by null 就可以防止排序.</font></p>
<p>tips：mysql中group by having 用法需要注意的事项: </p>
<ol>
<li><p>GROUP BY：<br>group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by后面。<br>比如 select name,sum(point) from table_name<br>这样sql语句会报错，必须写成:<br>select name,sum(point) from table_name GROUP BY name </p>
</li>
<li><p>HAVING<br>把 HAVING 加入 SQL 的原因是，WHERE 无法应用于合计函数，而如果没有 HAVING，就无法测试结果条件。<br>select name,sum(point)<br>from table_name GROUP BY name<br>HAVING sum(point)&gt;1000 </p>
</li>
<li><p>having通常和group by联合使用.</p>
</li>
</ol>
<p>参考连接：<a href="http://blog.csdn.net/bingogirl/article/details/52559302" target="_blank" rel="external">GROUP BY和HAVING</a></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>&#160; &#160; &#160; &#160;有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p>
<pre><code>select * from dept, emp where dept.deptno=emp.deptno; //简单处理方式

select * from dept left join emp on dept.deptno=emp.deptno; //左外连接，效果更佳！
</code></pre><p>参考这篇博客：<a href="http://www.cnblogs.com/BeginMan/p/3754322.html" target="_blank" rel="external">mysql三种连接查询总结和性能分析</a></p>
<h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p> 参考这篇博文：<a href="http://www.cnblogs.com/glory-jzx/archive/2012/07/19/2599215.html" target="_blank" rel="external">exists用法</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>&#160; &#160; &#160; &#160;这里放几个别人整理好的sql优化，从细节上我们要把握。</p>
<ol>
<li><a href="http://www.cnblogs.com/ATree/archive/2011/02/13/sql_optimize_1.html" target="_blank" rel="external">优化sql查询</a>。</li>
</ol>
<ol>
<li><a href="http://www.jb51.net/article/39221.htm" target="_blank" rel="external">sql优化常用的30的技巧</a>。</li>
</ol>
<h2 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h2><ol>
<li><p>myisam 存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。（要定期碎片整理，因为删除了数据，MYD文件不会变小，整理可用optimize table XXX）。</p>
</li>
<li><p>INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p>
</li>
</ol>
<ol>
<li>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. 重启mysql就没有了。。。没有持久化机制，不像redis。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>&#160; &#160; &#160; &#160;下面从几个方面来比较几个存储引擎。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt=""></p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>&#160; &#160; &#160; &#160;<a href="http://www.cnblogs.com/100thMountain/p/4692008.html" target="_blank" rel="external">mysql字段类型选择</a></p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><p>&#160; &#160; &#160; &#160;分水平分表和垂直分表。5.1版本之后才用分区。</p>
<p>&#160; &#160; &#160; &#160;<a href="http://www.2cto.com/database/201503/380348.html" target="_blank" rel="external">mysql分表分区详解</a></p>
<h2 id="读写分离、负载均衡、主从复制"><a href="#读写分离、负载均衡、主从复制" class="headerlink" title="读写分离、负载均衡、主从复制"></a>读写分离、负载均衡、主从复制</h2><p>&#160; &#160; &#160; &#160;这些我们在以后分布式系统构建中在深入学习。</p>
<p><img src="http://images2015.cnblogs.com/blog/47685/201606/47685-20160605035114867-448644269.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们就分项的讲诉了许多的优化策略和原理方法，当然并不是全部。要记住这些方法，随时使用。可以参考这篇博文：<a href="http://blog.csdn.net/zls986992484/article/details/52860496" target="_blank" rel="external">mysql优化详解</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（五）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（五）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（五）&quot;&gt;&lt;/a&gt;mysql学习笔记（五）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（四）</title>
    <link href="http://yoursite.com/2017/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/22/深入理解mysql（四）/</id>
    <published>2017-01-22T12:34:17.000Z</published>
    <updated>2017-05-06T12:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（四）"><a href="#mysql学习笔记（四）" class="headerlink" title="mysql学习笔记（四）"></a>mysql学习笔记（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。</p>
  <a id="more"></a>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>&#160; &#160; &#160; &#160;创建索引可以大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="适合建立索引的情况"><a href="#适合建立索引的情况" class="headerlink" title="适合建立索引的情况"></a>适合建立索引的情况</h2><p>一般来说，应该在这些列上创建索引：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h2 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h2><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">此处为参考链接</a>。</p>
<h2 id="索引的使用分析"><a href="#索引的使用分析" class="headerlink" title="索引的使用分析"></a>索引的使用分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>&#160; &#160; &#160; &#160;下图说明利用这个指令出现的每项及其含义：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/explain.png" alt=""></p>
<h3 id="使用索引的几个注意事项"><a href="#使用索引的几个注意事项" class="headerlink" title="使用索引的几个注意事项"></a>使用索引的几个注意事项</h3><p>&#160; &#160; &#160; &#160;我们把dept这张表的deptno列设为主键，然后在把dname和loc列设为复合索引。代码如下：</p>
<pre><code>//添加主键
alter table dept add primary key(deptno);
//  dname 左边的列,loc就是右边的列
alter table dept add index my_ind (dname,loc); 
</code></pre><ol>
<li>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<pre><code>explain select * from dept where loc=&apos;aaa&apos;\G；//此处就不会使用到索引
</code></pre></li>
</ol>
<ol>
<li><p>对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引,‘aaa%’ 会使用到索引。</p>
<p> explain select * from dept where dname like ‘%aaa’\G</p>
<p> 不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 _这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</p>
<p>这两个语句执行比较就可以等到结果。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。情况特殊，比如空表或者记录只有一条的时候。</p>
</li>
</ol>
<h3 id="查询索引使用情况"><a href="#查询索引使用情况" class="headerlink" title="查询索引使用情况"></a>查询索引使用情况</h3><p>&#160; &#160; &#160; &#160;如何查看索引使用的情况，就像看缓存命中率一样:</p>
<pre><code>show status like ‘Handler_read%’;
</code></pre><p>tips：</p>
<pre><code>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。

handler_read_rnd_next:这个值越高，说明查询低效。
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（四）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（四）&quot;&gt;&lt;/a&gt;mysql学习笔记（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
