<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jessie_Zou’s Homepage</title>
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-06T11:12:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jessie Zou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/05/06/%E5%89%91%E6%8C%87offer%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/05/06/剑指offer：用两个栈实现队列/</id>
    <published>2017-05-06T10:19:11.000Z</published>
    <updated>2017-05-06T11:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。</p>
  <a id="more"></a>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道栈是先进后出，而队列是先进先出。两个栈是可以实现先进后出的，我们模拟进队列操作时，进队列都进入第一个栈，然后出队列操作时，先把栈1全部倒入栈2，栈2出栈完成出队列操作，为了保证顺序，栈2中元素还要在倒入栈1。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    //定义两个栈</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    //进队都往第一个栈进。</div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    //出队列函数</div><div class="line">    public int pop() &#123;</div><div class="line">        //如果栈1不为空，把栈1值导入栈2，完成逆序</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        //栈2栈顶出队列</div><div class="line">        int first=stack2.pop();</div><div class="line">        //这里是重点：栈2的值都要倒回栈1，因为如果不倒回，出队列操作之后，栈2还有元素，但是之</div><div class="line">        //后进队列的元素又倒回栈2，这样就乱序了，倒回保证每次栈2中先进的都在下面，整体倒入栈2</div><div class="line">        //后肯定保证是先进的元素在栈顶</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        //</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：重建二叉树</title>
    <link href="http://yoursite.com/2017/05/05/%E5%89%91%E6%8C%87offer%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2017/05/05/剑指offer：重建二叉树/</id>
    <published>2017-05-05T09:16:00.000Z</published>
    <updated>2017-05-06T10:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。</p>
  <a id="more"></a>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道在二叉树的前序遍历中，第一个总是根值。中序遍历中，根节点的值在序列的中间。左子树的根节点位于根节点的左边，右子树的结点在根节点的右边，因此我们需要扫描中序遍历才能找到根节点的值。找到根结点之后，中序遍历分成两部分，分别是左右子树的中序遍历，而我们在前序遍历中根据左右子树的个数就能确定左右子树的前序遍历，因此我们就能递归的完成。具体步骤如下：</p>
<ol>
<li>先进行输入序列的检查。</li>
<li>把中序序列放入一个hashmap，值为key，索引为value，这样很方便的通过前序序列中的值得到在中序遍历中的索引，很巧妙，而且时间复杂度较低。</li>
<li>利用递归完成树重建，为了代码的简洁性，写了preIn函数完成功能。具体输入参数和意义如下注释部分。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</div><div class="line">    //为空则返回空，输入检查，还可检查两者长度是否相等。</div><div class="line">    if(pre==null||in==null)&#123;</div><div class="line">          return null;</div><div class="line">    &#125;   </div><div class="line">    java.util.HashMap&lt;Integer,Integer&gt; map=new java.util.HashMap&lt;Integer,Integer&gt;();</div><div class="line">    //中序遍历进map</div><div class="line">    for(int i=0;i&lt;in.length;i++)&#123;</div><div class="line">       map.put(in[i],i); </div><div class="line">    &#125;</div><div class="line">    //交给重建函数</div><div class="line">    return preIn(pre,0,pre.length-1,in,0,in.length-1,map);</div><div class="line">&#125;</div><div class="line">//p，n，map属于不变的，这样写代码简洁一点，变得是前序遍历和中序遍历在原序列中的起止索引。</div><div class="line">public TreeNode preIn(int[] p,int pi,int pj,int[] n,int ni,int nj,java.util.HashMap&lt;Integer,Integer&gt; map)&#123;</div><div class="line">    //前序遍历开始位置大于结束位置，返回空。</div><div class="line">    if(pi&gt;pj)&#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    //前序遍历开始位置就是根节点。</div><div class="line">    TreeNode head =new TreeNode(p[pi]);</div><div class="line">    //获得根节点在中序序列中的索引位置</div><div class="line">    int index=map.get(p[pi]);</div><div class="line">    //递归左子树，前序遍历pi自增1就行，结束位置算法是（pi+1）+（index-1-ni），因为</div><div class="line">    //index-1为中序遍历结束位置减去ni开始位置就是中序遍历的个数，在加上pi+1就是前序遍历</div><div class="line">    //结束为止</div><div class="line">    head.left=preIn(p,pi+1,pi+index-ni,n,ni,index-1,map);</div><div class="line">    //右子树的前序开始位置为左子树结束位置自增1，结束位置是pj，中序遍历开始是根节点位置自</div><div class="line">    //增1，结束位置是nj</div><div class="line">    head.right=preIn(p,pi+index-ni+1,pj,n,index+1,nj,map);</div><div class="line">    //重建完成返回</div><div class="line">    return head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;树也是一种重要的数据结构，它的逻辑是：除了根节点之外每个节点都只有一个父节点，根节点没有父节点，除了叶节点之外所有的节点都有一个或多个字节点。我们经常用到的是二叉树（还包括一些特殊的二叉树：二叉搜索树、大小根堆、红黑树等使用也广泛），它的遍历方式有前序遍历、中序遍历、后序遍历、宽度优先遍历。知道中序遍历和前后遍历任意其他一个，我们就能重建二叉树，这题就是已经前中序要求重建二叉树。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/05/04/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/05/04/剑指offer：从尾到头打印链表/</id>
    <published>2017-05-04T12:41:39.000Z</published>
    <updated>2017-05-06T12:14:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;补充说明：使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。在Java中我们用自定义类来表示链表，本题就给出了链表默认类。—-源自<em>百度百科</em>，觉得讲的很清楚。</p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;从头到尾输出链表比较简单，因为是题目要求是打印且是从尾到头，打印一般不允许我们改原链表结构的，所以反向链表在从头打印不行的，我们有两个思路：</p>
<ol>
<li>考虑用递归来实现，链表最后一个节点的next节点为空，这也是我们递归结束条件。如果链表当前节点的next不为空，我们递归先打印它的next节点，但是递归都怕栈溢出。</li>
</ol>
<ol>
<li>考虑到这个类似先进后出，可用数据结构栈来实现这种顺序,但是没有递归简洁，而且先要遍历一遍存入栈，然后在出栈。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> import java.util.ArrayList;</div><div class="line"> public class Solution &#123;</div><div class="line"> </div><div class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        //递归结束条件  </div><div class="line">        if(listNode!=null)&#123;</div><div class="line">            //递归打印它的next数组</div><div class="line">            this.printListFromTailToHead(listNode.next);</div><div class="line">            arrayList.add(listNode.val);</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Stack;</div><div class="line">public class Solution &#123;</div><div class="line">    </div><div class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</div><div class="line">        Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;();</div><div class="line">        //链表依次进栈</div><div class="line">        while(listNode!=null)&#123;</div><div class="line">            s.push(listNode.val);</div><div class="line">            listNode=listNode.next;</div><div class="line">        &#125;</div><div class="line">        //依次出栈到输出动态数组完成逆序打印</div><div class="line">        while(!s.empty())&#123;</div><div class="line">            arrayList.add(s.pop());</div><div class="line">        &#125;</div><div class="line">        return arrayList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;链表是常见的数据结构，上面篇已经讲了字符串和数组，这题就有关链表，从数据结构中我们知道了链表的基本性质：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：替换空格</title>
    <link href="http://yoursite.com/2017/05/03/%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2017/05/03/剑指offer：替换空格/</id>
    <published>2017-05-03T07:23:15.000Z</published>
    <updated>2017-05-06T10:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
  <a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;C／C++中每个字符串都已字符’\0’作为结尾，这样我吗就能很方便的找到字符串的末位，但是这个特点导致字符串都有一个额外的开销。而在Java和C#中，String是不可变的，一旦试图改变，将产生一个新的实例。所以要活用StringBuilder和StringBuffer。可参考这个博文：<a href="http://blog.csdn.net/qh_java/article/details/46382265" target="_blank" rel="external">从源码角度分析Java三种字符串</a>。</p>
<p>&#160; &#160; &#160; &#160;用Java实现本题，输入的是一个StringBuffer，我们可以先定义一个返回字符串StringBuffer类型，遍历一遍字符串，使用charAt（int i）方法，如果当前字符没空字符，则使用append（char c）添加给定字符，如果不是则添加该字符。最后把StringBuffer变成String返回。使用toStirng（）方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>public String replaceSpace(StringBuffer str) {
    StringBuilder newstr =new StringBuilder();
    for(int i=0;i&lt;str.length();i++){
        if(str.charAt(i)==&apos; &apos; )
            newstr.append(&quot;%&quot;).append(&quot;2&quot;).append(&quot;0&quot;);
        else
           newstr.append(str.charAt(i));
    }
           return newstr.toString();
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：二维数组中的查找</title>
    <link href="http://yoursite.com/2017/05/02/%E5%89%91%E6%8C%87offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/05/02/剑指offer：二维数组中的查找/</id>
    <published>2017-05-02T08:28:06.000Z</published>
    <updated>2017-05-06T10:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。</p>
  <a id="more"></a>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;遍历数组能解决问题，但是由于所给数组已经部分排序，我们可以利用这个排序规则进行不必要的比较剔除，进行优化。试想如果起点是左下角，同目标值比较，如果大于目标值，整行我们就不用比较了，如果小于目标值，本行之前也都不用比较了。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#160; &#160; &#160; &#160;以右上角为起点，代码如下：</p>
<pre><code>public boolean Find(int target, int [][] a) {
    // 右上角初始值，第一行最后一列。
    int j=a[0].length-1;
    int i=0;
    //循环条件
    while((j&gt;=0)&amp;&amp;i&lt;a.length){
        //大于目标值，该行之后肯定都大于目标值，只会在该行，减少列数查找
        if(a[i][j]&gt;target)
            --j;
        //小于目标指，则该行全小于目标值，往下一行查找
        else if(a[i][j]&lt;target)
            ++i;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre><p>   &#160; &#160; &#160; &#160;以左下角为起点，代码如下： </p>
<pre><code>    public boolean Find(int target, int [][] a) {
    //左下角初始值，最后一行，第一列
    int i=a.length-1;
    int j=0;
    //循环条件
    while((i&gt;=0)&amp;&amp;j&lt;a[0].length){
        //大于目标值则该行都大于目标值，往上一行查找。
        if(a[i][j]&gt;target)
            --i;
        //小于目标值，则该行之前都小于目标值，结果只会在该行，再增加列数查找
        else if(a[i][j]&lt;target)
            ++j;
        //相等返回true
        else
            return true;
    }
    //循环结束还未返回true，则返回false。
    return false;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;剑指offer是非常经典的算法面试题，之前在牛客网上做过一遍，现在做第二遍并且分析记录。博客中还会出现数据结构和经典算法的篇幅，但是剑指offer单独拿出来，总共60多个题，分析一下，到时候也可以给师弟网友学习过程中作为参考。我自己也能熟悉面试题，巩固算法知识，保持编程状态。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（二）</title>
    <link href="http://yoursite.com/2017/02/10/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/10/Java基础之面向对象（二）/</id>
    <published>2017-02-10T07:25:36.000Z</published>
    <updated>2017-05-08T02:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（二）"><a href="#Java面向对象特性（二）" class="headerlink" title="Java面向对象特性（二）"></a>Java面向对象特性（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;本篇继续讲面向对象特性，自动装箱和拆箱，抽象和接口，内部类和lambda表达式，枚举类型等方面。</p>
<h2 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h2><p>&#160; &#160; &#160; &#160;JDK 1.5之前，Java有8个基本数据类型不能当前Object类型，之后就才用自动装箱和拆箱，可以把一个基本数据类型直接赋值给包装类变量，也可以把包装类对象直接复制给一个对应的基本数据类型。</p>
<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><p>&#160; &#160; &#160; &#160;用static关键字修饰的成员就是类成员，static语义代表的是修饰的对象属于整个类而不属于任何实例。</p>
<p>&#160; &#160; &#160; &#160;Java中只能包括五种：成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）、以static修饰的成员就是类成员，他能修饰除构造器之外的其他四种。</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>&#160; &#160; &#160; &#160;在一些特殊场景下，要求不允许自由创建该类的对象，而只允许为该类创建一个对象，为了避免该类被自由创建，类的构造器使用private修饰，从而把该类的所有构造器隐藏起来。但是还要有一个public方法作为该类的访问点，用于创建该类的对象，且该方法必须使用static修饰，除此之外，该类还不许知道已经缓存过已经创建的对象，否则该类无法知道是否创建过该对象。下面就手写代码实现一个单例类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static Singleton instance;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">  </div><div class="line">    public static Singleton getInstance() &#123;  </div><div class="line">    if (instance == null) &#123;  </div><div class="line">        instance = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    return instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;但是这也只是懒汉，单线程情况，还有几种写法参考博客：<a href="https://www.oschina.net/code/snippet_107039_6062" target="_blank" rel="external">单例的5种写法</a>。</p>
<h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><p>&#160; &#160; &#160; &#160;final关键字可以修饰类、变量和方法，用于它修饰的类，方法和变量不可变，类似C#中的sealed。修饰变量包括成员变量和局部变量和形参。准确说是一旦赋类初始值就不能被改变。final还可以完成C中宏定义的类似功能。</p>
<h3 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h3><p>&#160; &#160; &#160; &#160;final修饰的成员变量必须由程序员显式的指定初始值。</p>
<h3 id="final局部变量"><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3><p>&#160; &#160; &#160; &#160; 系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。但是用final修饰局部变量时，既可以在定义时，指定默认初始值，也可以不指定。</p>
<h3 id="final修饰基本变量和引用变量区别"><a href="#final修饰基本变量和引用变量区别" class="headerlink" title="final修饰基本变量和引用变量区别"></a>final修饰基本变量和引用变量区别</h3><p>&#160; &#160; &#160; &#160;当使用final修饰基本变量时，不能对基本变量类型进行重新赋值，但对引用来说，仅仅是一个引用地址，final只能保证引用类型变量指定的地址不会改变，一直引用一个对象，但这个对象完全可以发生改变。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>&#160; &#160; &#160; &#160;不想子类重写的可以用final修饰，比如Object中的getClass（）方法。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>&#160; &#160; &#160; &#160;final类不能使用子类，比如Math类就是。保证不能被继承。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>&#160; &#160; &#160; &#160;当编写一个类时候，常常会给类定义一些方法，比如形状类Shape，应该提供一个计算周长的方法，但是Shape类型不同计算周长方式不同，这时我们可以使用抽象方法，只有方法签名，没有方法实现。</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ol>
<li>都必须使用abstract修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，<font color="red">无法使用new来调用构造器实例对象，即使不包含抽象方法。</font></li>
<li>抽象类可以包含成员变量、方法、构造器、初始化块、内部类5个成分。主要作用是被其子类调用。</li>
<li>含有抽象方法的类：包括直接定义来一个抽象方法，继承一个抽象父类，但没有完全实现父类包含的抽象方法，或者实现了一个接口但没有完全实现接口包含的抽象方法这三种情况）只能被定义为抽象类。</li>
<li>不能用来修饰成员变量、局部变量、构造器。</li>
<li>static和abstract不同时修饰一个方法，即没有所谓的类静态抽象方法。但也不是绝对互斥，它们可以修饰内部类。</li>
<li>private和abstract不同时修饰方法。</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>&#160; &#160; &#160; &#160;在Java8中对接口进行了改进，允许接口中定义默认方法，默认方法可以提供方法实现。默认方法必须使用default修饰，且不能被static修饰。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&#160; &#160; &#160; &#160;接口是从多个相似类中抽象出来的规范，规范了它实现类的基本行为规范。接口使用interface关键字。仿佛默认使用public修饰。</p>
<p>&#160; &#160; &#160; &#160;Java8中允许接口中定义类方法，必须使用statci修饰，该方法可以使用接口来调用。</p>
<p>&#160; &#160; &#160; &#160;接口成员默认使用public static final修饰。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>接口支持多继承；</li>
<li>接口不能创建实例；</li>
<li>接口的实现类 implents；实现类可实现多个接口。</li>
</ol>
<h2 id="抽象和接口的比较"><a href="#抽象和接口的比较" class="headerlink" title="抽象和接口的比较"></a>抽象和接口的比较</h2><p>&#160; &#160; &#160; &#160;一般接口来控制行为规范，抽象类用来定型。当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>参考这篇博客：<a href="http://www.cnblogs.com/yongjiapei/p/5494894.html" target="_blank" rel="external">抽象和接口的区别</a>。</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><h3 id="实现简单工厂模式"><a href="#实现简单工厂模式" class="headerlink" title="实现简单工厂模式"></a>实现简单工厂模式</h3><p><a href="http://www.cnblogs.com/toutou/p/4899388.html" target="_blank" rel="external">详解工厂模式三种类型</a></p>
<h3 id="实现命令模式"><a href="#实现命令模式" class="headerlink" title="实现命令模式"></a>实现命令模式</h3><p><a href="http://blog.csdn.net/jason0539/article/details/45110355" target="_blank" rel="external">Java命令模式实现</a></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><ol>
<li>非静态内部类可以访问外部private成员。</li>
<li>优先在局部变量中寻找。</li>
<li>外部不能访问非静态内部类的private成员。</li>
<li>非静态内部类中不能定义静态成员。</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ol>
<li>静态内部类中可以包含静态、非静态成员都可以。</li>
<li>静态类不能访问外部成员，只能是访问静态成员。</li>
<li>静态内部类是外部类的一个静态成员，因此外部类的所有成员可以使用静态内部类来定义，创建对象，但是不能直接访问静态内部类的成员。</li>
<li>接口中也能定义内部类，接口中只能是静态内部类，默认使用public static。</li>
</ol>
<h2 id="内部类的使用"><a href="#内部类的使用" class="headerlink" title="内部类的使用"></a>内部类的使用</h2><ol>
<li>外部类内部使用内部类：和普通类没有太大区别，唯一区别是：不要在外部类中的静态成员中使用非静态的内部类。</li>
<li>在外部类以外使用非静态内部类：如果希望被访问，不能使用private。</li>
<li>外部类以外访问静态内部类，无须实例外部类。</li>
<li>局部内部类，在方法里，只能在方法内使用。</li>
</ol>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>&#160; &#160; &#160; &#160;适合创建那种只需要一次使用的类，类如命令模式中的command对象。匿名内部类必须继承一个父类或实现一个接口，但最多继承一个父类或实现一个接口。不允许为抽象类，不能定义构造器，因为没有类名，但可以定义初始化块来完成构造器要完成的事情。</p>
<p>&#160; &#160; &#160; &#160;在Java8之前，Java要求局部内部类、匿名内部类访问的局部变量必须使用final修饰，从Java8开始这个限制被取消了，Java8更加智能，自动添加final。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html" target="_blank" rel="external">匿名内部类总结</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>&#160; &#160; &#160; &#160;允许用更简单的代码来创建只有一个抽象方法的接口，即函数式接口。lambda表达式完全可用于简化创建匿名内部类对象。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>&#160; &#160; &#160; &#160;早期会用简单的静态变量来表示枚举，但是类型不安全，没有命名空间，意义不明确，后来用类来封装，但是额外要写代码，JDK1.5之后增加了对枚举类的支持。</p>
<p>&#160; &#160; &#160; &#160;参考这篇博客：<a href="http://www.cnblogs.com/oumyye/p/4232532.html" target="_blank" rel="external">lambda表达式总结</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（二）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（二）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（二）&quot;&gt;&lt;/a&gt;Java面向对象特性（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之面向对象（一）</title>
    <link href="http://yoursite.com/2017/02/08/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/08/Java基础之面向对象（一）/</id>
    <published>2017-02-08T04:38:25.000Z</published>
    <updated>2017-05-07T07:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象特性（一）"><a href="#Java面向对象特性（一）" class="headerlink" title="Java面向对象特性（一）"></a>Java面向对象特性（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。</p>
  <a id="more"></a>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>&#160; &#160; &#160; &#160;区分类和对象，由类实例出对象，怎么去定义一个类，怎么通过类的构造器实例一个对象。类中有属性和方法。方法有构造方法和普通方法。属性有成员变量和局部变量。构造器没有返回值，返回值时隐式的。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>&#160; &#160; &#160; &#160;如果没有构造器，会默认提供一个无参数的构造器，构造器最大的用处是在创建对象时执行，创建一个对象的时候会执行初始化：所有基本类型0，布尔为false，引用类型为null。构造器也不是完全负责创建Java对象，new的时候已经开辟了内存空间，只不过智能字啊构造器中通过this使用，构造器用来返回一个对象，通常还会赋值给一个引用变量。</p>
<p>&#160; &#160; &#160; &#160;构造器也可以像方法一样重载。</p>
<h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>&#160; &#160; &#160; &#160;方法在逻辑上要么属于类，要么属于对象。方法是类或对象的行为特征的抽象。类似传统结构化程序中的函数。</p>
<p>&#160; &#160; &#160; &#160;方法的参数可以指定个数，也可以可变个数，就是当成数组传入。参数传递机制有值传递和引用传递。基本类型是值传递，引用类型是引用传递。</p>
<p>&#160; &#160; &#160; &#160;方法体内调用他自己，该方法就是递归方法。包含了一种隐式的循环，所以理论上递归都可以转为循环。</p>
<p>&#160; &#160; &#160; &#160;类中方法是可以重载的，就是允许方法名一样，但是参数不一样。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>&#160; &#160; &#160; &#160;类中的变量分为成员变量和局部变量，成员变量不在方法体内，分为静态和非静态的，即类成员和实力成员变量，而局部变量一般包括形参、方法的局部变量（定义在方法内）、代码块的局部变量（在代码块内，例如for循环内部）。</p>
<p>&#160; &#160; &#160; &#160;这些的不同必然导致了变量的访问方式、作用范围和生命周期等方面必然有不同。</p>
<p>&#160; &#160; &#160; &#160;局部变量必须显式的初始化才能使用，而成员变量类加载的时候已经赋了初值。局部变量不属于任何实例或者类，他在方法的栈内存中，往往是基本类型和对象的引用。方法执行完就释放。</p>
<p>&#160; &#160; &#160; &#160;了解这些之后我们要合适选择变量类型。准确控制变量的作用域。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>&#160; &#160; &#160; &#160;它指将对象的状态信息部分隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作和访问。具体该怎么实现呢，适用访问控制符。</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>&#160; &#160; &#160; &#160;有下面四种private、default（friendly）、protected、public四种，比较如下图：</p>
<p><img src="http://img.blog.csdn.net/20160908104619224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>&#160; &#160; &#160; &#160;有这三个要掌握：package、import、import static；Java默认导入java.lang包下的所有类。下面列出常用包：</p>
<p> <img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E5%8C%85.png" alt=""></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>&#160; &#160; &#160; &#160;Java是单继承多接口，用关键字extends实现。子类继承负累所有成员变量和方法，值得指出的是：子类不能获得父类的构造器。</p>
<h3 id="重写（覆盖）父类方法"><a href="#重写（覆盖）父类方法" class="headerlink" title="重写（覆盖）父类方法"></a>重写（覆盖）父类方法</h3><p>&#160; &#160; &#160; &#160;override，遵守两同两小一大原则：方法名、参数相同；子类返回值类型应该比父类更小或者相等、子类抛出的异常也应该比父类更小或者相等；子类方法的访问权限应该比父类更大或者相等。而且要么都是类方法，要么都是实例方法。</p>
<h3 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h3><pre><code>super....//使用父类方法或属性
this....// 使用类本身方法或属性
</code></pre><h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><p>&#160; &#160; &#160; &#160;从运行过程上看，创建任何对象时总是从该类所在继承树的最顶层类的构造器开始执行，然后依次向下执行，最后才执行本来的构造器。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>&#160; &#160; &#160; &#160;Java引用变量有两个类型，一个是编译时类型，一个时运行时类型。编译类型由声明该变量的类型决定，运行时类型由实际赋值给变量的类型决定，如果出现不一致，就可能出现所谓的多态。例如：</p>
<pre><code>SuperClass base=new SubClass();
</code></pre><p>&#160; &#160; &#160; &#160;因为子类是一个特殊的父类，因此允许把一个子类对象直接赋值给一个父类的引用类型。无须任何类型转换，精确的说时向上转型，向上转型由系统自动完成。但是编译时父类对象无法调用子类方法（可以利用反射来执行该方法）。</p>
<h2 id="强制类型转换和instanceof-运算符"><a href="#强制类型转换和instanceof-运算符" class="headerlink" title="强制类型转换和instanceof 运算符"></a>强制类型转换和instanceof 运算符</h2><pre><code>double d=113.4
long l=(long)d;
Objext hello=&quot;hello&quot;;
if(hello instanceof Object){
....
}
if(hello instanceof String){
....
}
</code></pre><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>&#160; &#160; &#160; &#160;继承是实现类复用的重要手段，但继承带来一个最大的坏处：破坏了封装，相比之下，组合也是实现类复用的重要方式。</p>
<p>&#160; &#160; &#160; &#160;继承在高可用的同时，暴漏了父类的实现细节，且子类还可以任意篡改，所以父类不想子类改变的属性方法应该使用private修饰符，还可以通过final修饰符控制不让子类改变。</p>
<p>&#160; &#160; &#160; &#160;被final修饰的类时不可变的，不能当作父类，如String。</p>
<h2 id="初识化块"><a href="#初识化块" class="headerlink" title="初识化块"></a>初识化块</h2><p>&#160; &#160; &#160; &#160;初始化块是类出现的第四种成员，前面依次由成员变量、方法和构造器，一个类里可以有多个初始化块。初始化块的修饰符只能是static，而且创建对象时，总是先执行初始化块，按出现顺序在执行构造器。</p>
<p>&#160; &#160; &#160; &#160;从某种程度上看，初始化块是构造器的补充。初始化块总是在构造器执行之前执行，系统通用可食用初始化块啦进行对象的初始化操作。</p>
<p>&#160; &#160; &#160; &#160;静态初始化块：在类加载的时候执行，而不是像之前那种在对象加载的时候执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本章主要介绍了Java面向对象的基本知识，包括如何定义类，如何为类成员添加成员变量、方法，以及如何创建类的对象。深入分析对象和引用变量之间的关系，方法的参数传递机制、重载，访问控制符等，三种面向对象特性的分析。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java面向对象特性（一）&quot;&gt;&lt;a href=&quot;#Java面向对象特性（一）&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象特性（一）&quot;&gt;&lt;/a&gt;Java面向对象特性（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;后面准备整理一下Java基础、JVM和并发编程的知识，后面再是ssm框架。这些都是基础部分，也是最重要的部分之一。本篇从Java语言的面向对象特性开始讲诉，Java的这个特点和C#很像。Java主要有封装、继承、多态这三个特性，抽象不是特性，但是也很重要。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象特性" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（五）</title>
    <link href="http://yoursite.com/2017/02/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/05/深入理解mysql（五）/</id>
    <published>2017-02-05T11:35:48.000Z</published>
    <updated>2017-05-07T03:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（五）"><a href="#mysql学习笔记（五）" class="headerlink" title="mysql学习笔记（五）"></a>mysql学习笔记（五）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。</p>
  <a id="more"></a>
<h2 id="sql语句的技巧"><a href="#sql语句的技巧" class="headerlink" title="sql语句的技巧"></a>sql语句的技巧</h2><h3 id="group-by和having"><a href="#group-by和having" class="headerlink" title="group by和having"></a>group by和having</h3><p>&#160; &#160; &#160; &#160;在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度.例子如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""></p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""><br>&#160; &#160; &#160; &#160;<font color="red">在group by 后面增加 order by null 就可以防止排序.</font></p>
<p>tips：mysql中group by having 用法需要注意的事项: </p>
<ol>
<li><p>GROUP BY：<br>group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by后面。<br>比如 select name,sum(point) from table_name<br>这样sql语句会报错，必须写成:<br>select name,sum(point) from table_name GROUP BY name </p>
</li>
<li><p>HAVING<br>把 HAVING 加入 SQL 的原因是，WHERE 无法应用于合计函数，而如果没有 HAVING，就无法测试结果条件。<br>select name,sum(point)<br>from table_name GROUP BY name<br>HAVING sum(point)&gt;1000 </p>
</li>
<li><p>having通常和group by联合使用.</p>
</li>
</ol>
<p>参考连接：<a href="http://blog.csdn.net/bingogirl/article/details/52559302" target="_blank" rel="external">GROUP BY和HAVING</a></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>&#160; &#160; &#160; &#160;有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p>
<pre><code>select * from dept, emp where dept.deptno=emp.deptno; //简单处理方式

select * from dept left join emp on dept.deptno=emp.deptno; //左外连接，效果更佳！
</code></pre><p>参考这篇博客：<a href="http://www.cnblogs.com/BeginMan/p/3754322.html" target="_blank" rel="external">mysql三种连接查询总结和性能分析</a></p>
<h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p> 参考这篇博文：<a href="http://www.cnblogs.com/glory-jzx/archive/2012/07/19/2599215.html" target="_blank" rel="external">exists用法</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>&#160; &#160; &#160; &#160;这里放几个别人整理好的sql优化，从细节上我们要把握。</p>
<ol>
<li><a href="http://www.cnblogs.com/ATree/archive/2011/02/13/sql_optimize_1.html" target="_blank" rel="external">优化sql查询</a>。</li>
</ol>
<ol>
<li><a href="http://www.jb51.net/article/39221.htm" target="_blank" rel="external">sql优化常用的30的技巧</a>。</li>
</ol>
<h2 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h2><ol>
<li><p>myisam 存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。（要定期碎片整理，因为删除了数据，MYD文件不会变小，整理可用optimize table XXX）。</p>
</li>
<li><p>INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p>
</li>
</ol>
<ol>
<li>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. 重启mysql就没有了。。。没有持久化机制，不像redis。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>&#160; &#160; &#160; &#160;下面从几个方面来比较几个存储引擎。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt=""></p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>&#160; &#160; &#160; &#160;<a href="http://www.cnblogs.com/100thMountain/p/4692008.html" target="_blank" rel="external">mysql字段类型选择</a></p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><p>&#160; &#160; &#160; &#160;分水平分表和垂直分表。5.1版本之后才用分区。</p>
<p>&#160; &#160; &#160; &#160;<a href="http://www.2cto.com/database/201503/380348.html" target="_blank" rel="external">mysql分表分区详解</a></p>
<h2 id="读写分离、负载均衡、主从复制"><a href="#读写分离、负载均衡、主从复制" class="headerlink" title="读写分离、负载均衡、主从复制"></a>读写分离、负载均衡、主从复制</h2><p>&#160; &#160; &#160; &#160;这些我们在以后分布式系统构建中在深入学习。</p>
<p><img src="http://images2015.cnblogs.com/blog/47685/201606/47685-20160605035114867-448644269.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们就分项的讲诉了许多的优化策略和原理方法，当然并不是全部。要记住这些方法，随时使用。可以参考这篇博文：<a href="http://blog.csdn.net/zls986992484/article/details/52860496" target="_blank" rel="external">mysql优化详解</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（五）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（五）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（五）&quot;&gt;&lt;/a&gt;mysql学习笔记（五）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（四）</title>
    <link href="http://yoursite.com/2017/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/22/深入理解mysql（四）/</id>
    <published>2017-01-22T12:34:17.000Z</published>
    <updated>2017-05-06T12:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（四）"><a href="#mysql学习笔记（四）" class="headerlink" title="mysql学习笔记（四）"></a>mysql学习笔记（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。</p>
  <a id="more"></a>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>&#160; &#160; &#160; &#160;创建索引可以大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="适合建立索引的情况"><a href="#适合建立索引的情况" class="headerlink" title="适合建立索引的情况"></a>适合建立索引的情况</h2><p>一般来说，应该在这些列上创建索引：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h2 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h2><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">此处为参考链接</a>。</p>
<h2 id="索引的使用分析"><a href="#索引的使用分析" class="headerlink" title="索引的使用分析"></a>索引的使用分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>&#160; &#160; &#160; &#160;下图说明利用这个指令出现的每项及其含义：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/explain.png" alt=""></p>
<h3 id="使用索引的几个注意事项"><a href="#使用索引的几个注意事项" class="headerlink" title="使用索引的几个注意事项"></a>使用索引的几个注意事项</h3><p>&#160; &#160; &#160; &#160;我们把dept这张表的deptno列设为主键，然后在把dname和loc列设为复合索引。代码如下：</p>
<pre><code>//添加主键
alter table dept add primary key(deptno);
//  dname 左边的列,loc就是右边的列
alter table dept add index my_ind (dname,loc); 
</code></pre><ol>
<li>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<pre><code>explain select * from dept where loc=&apos;aaa&apos;\G；//此处就不会使用到索引
</code></pre></li>
</ol>
<ol>
<li><p>对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引,‘aaa%’ 会使用到索引。</p>
<p> explain select * from dept where dname like ‘%aaa’\G</p>
<p> 不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 _这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</p>
<p>这两个语句执行比较就可以等到结果。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。情况特殊，比如空表或者记录只有一条的时候。</p>
</li>
</ol>
<h3 id="查询索引使用情况"><a href="#查询索引使用情况" class="headerlink" title="查询索引使用情况"></a>查询索引使用情况</h3><p>&#160; &#160; &#160; &#160;如何查看索引使用的情况，就像看缓存命中率一样:</p>
<pre><code>show status like ‘Handler_read%’;
</code></pre><p>tips：</p>
<pre><code>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。

handler_read_rnd_next:这个值越高，说明查询低效。
</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（四）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（四）&quot;&gt;&lt;/a&gt;mysql学习笔记（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（三）</title>
    <link href="http://yoursite.com/2017/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/18/深入理解mysql（三）/</id>
    <published>2017-01-18T09:26:32.000Z</published>
    <updated>2017-05-06T12:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（三）"><a href="#mysql学习笔记（三）" class="headerlink" title="mysql学习笔记（三）"></a>mysql学习笔记（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。<br>  <a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">索引能使查询变快的原理</font>：先建了一个索引文件，就是MYI文件，然后建立查找二叉树（也叫B树，二叉搜索树，二叉排序树）。利用了二叉树算法，使搜索性能逼近二分查找，但是他比连续内存空间的二分查找优点是，插入和删除不需要移动大量数据，通常是常数开销。记录下了对应索引数值的物理位置，所以数据库换了路径，索引也失效了。</p>
<p>&#160; &#160; &#160; &#160;学会用并利用explain来分析语句。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png" alt=""></p>
<h2 id="建立适当的索引"><a href="#建立适当的索引" class="headerlink" title="建立适当的索引"></a>建立适当的索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>&#160; &#160; &#160; &#160;当一张表，把某个列设为主键的时候，则该列就是主键索引。主键不能为null且不允许重复。</p>
<pre><code>create table aaa
(id int unsigned primary key auto_increment ,
name varchar(32) not null defaul ‘’);
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>&#160; &#160; &#160; &#160;这是id 列就是主键索引。</p>
<p>&#160; &#160; &#160; &#160;如果你创建表时，没有指定主键索引，也可以在创建表后，在添加指令:</p>
<pre><code>alter table 表名 add primary key (列名);
</code></pre><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;举例:</p>
<pre><code>create table bbb (id int , name varchar(32) not null default ‘’);

alter table bbb add primary key (id);
</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;添加之后发现库文件MYI文件变大。我们在我们测试样本的emp库建立主键索引，且前后查询对比如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.85 sec)</div><div class="line"></div><div class="line">mysql&gt; alter table emp add primary key(empno);</div><div class="line">Query OK, 4000000 rows affected (9.47 sec)</div><div class="line">Records: 4000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;发现时间明显变少，这就是主键索引的作用，按主键单位时间定为到准确位置，而不是从头开始找。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>&#160; &#160; &#160; &#160;一般来说，普通索引的创建，是先创建表，然后在创建普通索引。</p>
<p>&#160; &#160; &#160; &#160;比如:</p>
<pre><code>//先建表
create table ccc(
id int unsigned,
name varchar(32)
)
//添加索引
create index 索引名 on 表 (列1,列名2);
</code></pre><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><p>&#160; &#160; &#160; &#160;全文索引，主要是在很针对文件、文本的检索、比如文章，全文索引仅针对MyISAM有用。我们在测试样本temp库中创建下表，并插入测试数据如下：</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; CREATE TABLE articles (
    -&gt;        id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&gt;        title VARCHAR(200),
    -&gt;        body TEXT,
    -&gt;        FULLTEXT (title,body)
    -&gt;      )engine=myisam charset utf8;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO articles (title,body) VALUES
    -&gt;      (&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),
    -&gt;      (&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),
    -&gt;      (&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),
        -&gt;      (&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),
    -&gt;      (&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),
    -&gt;      (&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0
</code></pre><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>然后使用下面命令看是否成功,其中\G代表按行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;使用explain来分析一个错误使用全文索引的语句。</p>
<pre><code>mysql&gt; explain select * from articles where body like &quot;%mysql%&quot;\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
         type: ALL
possible_keys: NULL
      key: NULL
  key_len: NULL
      ref: NULL
     rows: 6
 filtered: 16.67
    Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>可看到possible_keys: NULL，key: NULL，说明没用到，下面例子就看到使用到了title。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><font color="red">正确的用法：WHERE  MATCH(title,body) against(‘database’);</font>


<pre><code>mysql&gt; explain select * from articles where match(title,body)     against(&apos;database&apos;)\G; 
*************************** 1. row ***************************
       id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
     type: fulltext
possible_keys: title
          key: title
      key_len: 0
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>&#160; &#160; &#160; &#160;说明：</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</li>
<li>使用方法是 match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select match(title,body) against(&apos;a&apos;) from articles;</div><div class="line">+--------------------------------+</div><div class="line">| match(title,body) against(&apos;a&apos;) |</div><div class="line">+--------------------------------+</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">+--------------------------------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>&#160; &#160; &#160; &#160;当表的某列被指定为unique约束时，这列就是一个唯一索引。按照以下方式建表，name列就是唯一索引。<font color="red">唯一索引允许为空，而且允许多个。</font></p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; create table ddd(id int primary key auto_increment , name varchar(32)     unique);
Query OK, 0 rows affected (0.02 sec)
</code></pre><h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;在创建表后，再去创建唯一索引，见如下指令：</p>
<pre><code>create table eee(id int primary key auto_increment, name varchar(32));

create unique index 索引名  on 表名 (列表..);
</code></pre><h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><p>desc 表名 【该方法的缺点是：　不能够显示索引名.】</p>
<p>show index(es) from 表名</p>
<p>show keys from 表名</p>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; desc articles</div><div class="line">    -&gt; ;</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| Field | Type             | Null | Key | Default | Extra          |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| title | varchar(200)     | YES  | MUL | NULL    |                |</div><div class="line">| body  | text             | YES  |     | NULL    |                |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show keys from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>alter table 表名 drop index 索引名; </p>
<p>如果删除主键索引。</p>
<p>alter table 表名 drop primary key </p>
<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p>先删除再重新创建。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节介绍的如何操作索引和索引能加快查询的原理。下篇我们看看怎么去分析索引的性能，比如explain用法，然后我们该怎么去适用索引最恰当。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（三）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（三）&quot;&gt;&lt;/a&gt;mysql学习笔记（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。&lt;br&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（二）</title>
    <link href="http://yoursite.com/2017/01/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/01/12/深入理解mysql（二）优化/</id>
    <published>2017-01-12T05:44:47.000Z</published>
    <updated>2017-05-05T09:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（二）"><a href="#mysql学习笔记（二）" class="headerlink" title="mysql学习笔记（二）"></a>mysql学习笔记（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。</p>
  <a id="more"></a>
<h2 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h2><p>对mysql优化时一个综合性的技术，主要包括：</p>
<ol>
<li><p>表的设计合理化(符合3NF)</p>
</li>
<li><p>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]</p>
</li>
<li>分表技术(水平分割、垂直分割)</li>
<li>读写[写: update/delete/add]分离</li>
<li>存储过程 [模块化编程，可以提高速度]</li>
<li>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]</li>
<li>mysql服务器硬件升级</li>
<li>定时的去清除不需要的数据,定时进行碎片整理(MyISAM) </li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF</p>
<p>&#160; &#160; &#160; &#160;1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p>
<p>&#160; &#160; &#160; &#160;2NF: 表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现。</p>
<p>&#160; &#160; &#160; &#160;3NF: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足3NF:</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/3NF.png" alt=""></p>
<p>需要修改成以下，消除依赖：<br><img src="http://opb7t58xj.bkt.clouddn.com/3NF2.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;反3NF : 但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 </p>
<p>案例 ：<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8F%8D3NF.png" alt=""></p>
<h3 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h3><p>&#160; &#160; &#160; &#160;查看mysql配置参数。我的运行环境是Mac，mysql5.7.18，如下图：<br><img src="http://opb7t58xj.bkt.clouddn.com/showstatus.png" alt=""><br>从图中可知，有356个变量，其中我们需要熟悉一部分，知道它代表的意义，可用下面指令查具体的：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/show%20like.png" alt=""></p>
<p>注意：这里结束符非常重要，区分中英文符号，是结束一条命令的标志。。。。。存储过程中还要改。因为存储过程中就有分号。</p>
<p>这里放两个链接：<a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">mysql 命令大全</a>，<a href="http://blog.itpub.net/15480802/viewspace-764968/" target="_blank" rel="external">mysql较为重要的状态变量</a>。</p>
<p>&#160; &#160; &#160; &#160;那我们如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)，比如首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)。实现如下：</p>
<p><em>show status</em></p>
<ol>
<li><p>常用的:<br>show status like ‘uptime’ ;<br>show  stauts like ‘com_select’  show stauts like ‘com_insert’ …类推 update  delete</p>
</li>
<li><p>show [session|global] status like …. 如果你不写  [session|global] 默认是session 会话，指取出当前窗口的执行，如果你想看所有(从mysql 启动到现在，则应该 global)</p>
</li>
<li><p>show status like ‘connections’; </p>
</li>
<li><p>show status like ‘slow_queries’;//显示慢查询次数</p>
</li>
</ol>
<h3 id="压力测试脚本生成"><a href="#压力测试脚本生成" class="headerlink" title="压力测试脚本生成"></a>压力测试脚本生成</h3><p>&#160; &#160; &#160; &#160;如何去定位慢查询呢，我们想还原一个场景，那我们就要构建一个大表(400 万)，我们采用存储过程构建，默认情况下，mysql认为10秒才是一个慢查询.所以我们要修改mysql的慢查询时间.使用以下命令：</p>
<p>show variables like ‘long_query_time’ ; //可以显示当前慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/60AEBD45-4A1C-4709-90F9-04324FBB4197.png" alt=""></p>
<p>set long_query_time=1 ;//可以修改慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/manchaxun.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;而且我们构建的大表中记录是有要求的,为了满足真实性，我们采取了随机生成的方法 ，使记录不同从而使测试效果和真实的相差不大。存储过程源码我放在了GitHub上，地址如下，无耻的求个star或者fork：<a href="https://github.com/wustzoujing/BetterMysqlTestDemo" target="_blank" rel="external">wustzoujing/BetterMysqlTestDemo</a>；简要的记录下我的执行过程；<br>首先写了两个随机函数，产生指定长度的两个字符串或者数字。其中rand_string()执行结果如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;上图可以知道：其中dual是亚元表，就是空表，已经随机生成了6位字符串。接下来看看存储过程执行成功如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/cunshuguochen.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;最后我们调用存储过程，执行几分钟后，看下结果，已经插入成功。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/shuju.png" alt=""></p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>这时我们已经有慢查询的次数了，就是插入数据这条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;long_query_time&apos;</div><div class="line"></div><div class="line">    -&gt; ;</div><div class="line">    </div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| Variable_name   | Value    |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| long_query_time | 1.000000 |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;然后我们需要开启慢查询日志（不同操作系统不同设置方式和文件路径，百度应该有很多），然后重启mysql，上面就会记录着我们的慢查询语句是什么。如下图，这是我的结果。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-05%20%E4%B8%8B%E5%8D%885.16.25.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们主要是形成测试样本，利用慢查询工具，这只是一个例子，还有很多命令方法工具帮助我们来找出问题，可以参考手册来。下篇博客讲讲发现问题了，我们如何优化。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（二）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（二）&quot;&gt;&lt;/a&gt;mysql学习笔记（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解mysql（一）</title>
    <link href="http://yoursite.com/2017/01/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/08/深入理解mysql（一）/</id>
    <published>2017-01-08T13:44:47.000Z</published>
    <updated>2017-05-05T05:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记（一）"><a href="#mysql学习笔记（一）" class="headerlink" title="mysql学习笔记（一）"></a>mysql学习笔记（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。</p>
  <a id="more"></a>
<h2 id="数据库的种类"><a href="#数据库的种类" class="headerlink" title="数据库的种类"></a>数据库的种类</h2><ol>
<li>对象数据库 应用领域：地理信息系统、科学与统计数据库、多媒体系统、XML文档仓库。</li>
<li>对象关系数据库 了解一下</li>
<li>关系数据库，例如mysql、oracle、sql server、db2等。我们以mysql为例深入了解关系数据库。</li>
<li>介于关系数据库与非关系数据库之间的MongoDB和完全的非关系数据库NoSql的Redis。Redis是我们了解的重点。</li>
</ol>
<h2 id="mysql数据库系统"><a href="#mysql数据库系统" class="headerlink" title="mysql数据库系统"></a>mysql数据库系统</h2><p>&#160; &#160; &#160; &#160;mysql由SQL接口、解析器、查询优化器、查询缓存（缓存和缓冲区）、存储引擎等几个子系统构成。</p>
<p><img src="http://img1.51cto.com/attachment/201308/111054362.png?_=3641983" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中还有几个部分解释如下：</p>
<p>connectors：与其他编程语言中的sql 语句进行交互，如php、java等；</p>
<p>Management Serveices &amp; Utilities：系统管理和控制工具；</p>
<p>Connection Pool (连接池)：管理缓冲用户连接，线程处理等需要缓存的需求。下面我们一个一个的来了解。</p>
<h3 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h3><p>&#160; &#160; &#160; &#160;SQL提供了从用户接收命令并把结果返回给用户的机制。关系数据库大都支持SQL标准，基本语句都类似，比如常规的CURD操作，sql server和mysql就差不多。mysql是一个多线程应用，它为每一个连接创建一个线程，每个线程执行都独立于其他线程。接收到SQL命令，解析各个部分存入一个类结构，查询结果通过有关数据写到网络通信协议上传输给客户端。</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器使用Lex和YACC实现，它能够把一条SQL语句分解为命令字、选项和参数等一系列最基本的语法元素，并将这些存入一个Lex类的结构中，后面查询步骤都会使用这个。规则使用Lex和YACC编写，在使用Bison编译成一个词法解析器。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>&#160; &#160; &#160; &#160;查询优化策略有很多，也可以设计优化算法，高阶程序员也可以自己写查询优化器代替mysql默认的。sql server使用的查询优化策略是基于开销的，根据一系列等价规则为给定查询生成一系列查询评估计划，然后根据关于执行这个查询所需要的关系和操作性能指标数据中选出开销最小的。mysql是混合使用多种优化技术的数据库系统，围绕着选取-投影-联结策略而设计出来的，从整体上能保证生成好的，但不能保证生成最好的查询语句。属于启发式查询优化机制。</p>
<p>&#160; &#160; &#160; &#160;具体的 <strong>选取-投影-联结</strong> 策略 ：即先更具有关的限制条件进行选取（select操作）以减少要处理的元组个数，再进行投影以减少被选取元组里的属性字段的个数，最后根据联结条件生成最终的查询结果。</p>
<ol>
<li>通过计算where子句里的表达式来横向排除多余的数据。</li>
<li>只保留在属性清单里面列出来的，以及在最后执行连接子句时还需要用到的属性字段，其他数据全部排除。</li>
<li>根据联结条件生成最终的查询结果。</li>
</ol>
<p>&#160; &#160; &#160; &#160;优化的第一步检查有关的表是否存在以及用户的访问权限。发现错误返回出错信息并把控制器交给线程管理器，也就是负责监听请求的listener，一旦找到了正确的表，就打开并应用适当的并发控制。<br>&#160; &#160; &#160; &#160;所有的维护和初识化任务完成后，优化器将利用Lex结构对命令中where条件进行处理，其结果作为临时表返回后续步骤做一步处理。如果查询命令里面有UNION操作法，优化器将以循环方式执行完所有的select操作之后再进行下一步。<br>&#160; &#160; &#160; &#160;优化器下一步时执行投影操作。这一步中间结果保存在临时表中且只保存指定列。最后检查Lex结构是否含有Join条件；如果有，调用join优化方法。</p>
<p>&#160; &#160; &#160; &#160;优化内容：对条件表达式进行简化和求值，消除死分支或恒真恒假条件。总之，在执行联结操作之前，优化器会尽量减小查询命令里的条件。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>&#160; &#160; &#160; &#160;查询的具体执行是由一组库方法实现，每种方法复制一种特点操作，例如CRUD。方法都有一个线程对象参数，可以让那些方法直接找到合线程访问相关的内部查询结构，加快执行速度。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>&#160; &#160; &#160; &#160;查询缓存，包括查询语句解析结果和查询结果本身。把频率最高的数据放在内存中能够快速的访问来加快。速度。mysql把数据封装成某个结构（不同对象缓存，用来封装的结构不同），再把数据保存为一个链表。缓存友表缓存（为了减少打开读取和关闭表，frm文件）、记录缓存（减少数据读写频率）、键缓存（缓存各索引的热度）、权限缓存（授权信息，存为先进后出的散列表）、主机名缓存（用栈）、其他类似联结缓存。缓存有自己的监控机制，利用LRU最近最少使用页面靠换策略。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>&#160; &#160; &#160; &#160;这个是重要的一环，也是mysql最佳功能之一。数据库使用者可以根据需求选择不同的存储引擎，存储引擎是关键的一部，也是数据库管理系统最底层的一个，直接与数据库文件进行交互，也就是对数据库进行IO操作。下面介绍mysql提供的一些存储引擎。</p>
<ol>
<li>MyISAM 是默认的存储引擎，它在ISAM上增加了一些新的缓存和索引机制。为了提高访问速度，这类表还普遍使用了数据压缩和索引优化技术。<font color="red">此外还准备了表级的锁定机制。所以适合检索读性能。</font></li>
<li>InnoDB 几乎总是用在需要支持事务的应用程序。支持ACID，InnoDB所有索引采用B-树结构，放在叶子节点里。改进了并发控制，提供行级的锁定。所以对频繁更新，添加，删除等类型数据库是首选存储引擎。</li>
<li>BDB提供页面即的锁。支持散列表、B-树。</li>
<li>内存存储引擎。HEAP表。</li>
<li>合并存储引擎。安装特定规则分成很多小表去存储一个大表，搜索的时候可以去搜索特定的小表而不是搜索体积庞大的大表。但是缺点是：只能用相同的myisam表，不允许替换操作，与普通表相比，使用索引访问效率要低。</li>
<li>档案。把大量数据保存为压缩格式，适合存放和检索那些不需要频繁更新的档案性或历史积累数据。比如系统日志。</li>
<li>联合存储引擎。适合用在分布式环境</li>
<li>群集／NDB 。 在一个高可用性和高性能的环境中使用多个mysql服务器提供数据库服务。</li>
<li>其他的包括：CSV、黑洞、定制的。</li>
</ol>
<p>##小结<br>&#160; &#160; &#160; &#160;了解了一下数据库的类型，和mysql的组成，对RDBS的设计有了大致的了解，那么后面将对在此基础上对mysql优化进行一个深度的学习和总结，并找demo来实战。下面对SQL 语句执行过程进行说明：</p>
<p>   &#160; &#160; &#160; &#160;数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。那么Mysql接受到SQL语句后，又是如何处理的呢？</p>
<p>   &#160; &#160; &#160; &#160;首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices&amp;Utilities）管理。当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：</p>
<ol>
<li><p>由SQL接口丢给后面的解释器（Parser），上面已经说到，解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。</p>
</li>
<li><p>解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。</p>
</li>
<li><p>确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。</p>
</li>
<li><p>这里有几点需要注意：</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;(1)如何缓存查询数据？</p>
<p>&#160; &#160; &#160; &#160;存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。</p>
<p>&#160; &#160; &#160; &#160;(2)buffer与cache的区别？</p>
<p>&#160; &#160; &#160; &#160;从上面的图可以看到，缓存那里实际上有buffer和cache两个，那它们之间是否有什么不同呢？简单的说就是，buffer是写缓存，cache是读缓存。</p>
<p>&#160; &#160; &#160; &#160;(3)如何判断缓存中是否已缓存需要的数据</p>
<p>&#160; &#160; &#160; &#160;这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那么缓存的优势又在哪里？？</p>
<p>&#160; &#160; &#160; &#160;实际上，并非如此，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。</p>
<p>链接参考：<a href="http://pmghong.blog.51cto.com/3221425/1281970" target="_blank" rel="external">mysql原理</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql学习笔记（一）&quot;&gt;&lt;a href=&quot;#mysql学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;mysql学习笔记（一）&quot;&gt;&lt;/a&gt;mysql学习笔记（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解mysql" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（四）</title>
    <link href="http://yoursite.com/2017/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/03/计算机网络学习笔记（四）/</id>
    <published>2017-01-03T10:33:32.000Z</published>
    <updated>2017-05-04T13:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-应用层（四）"><a href="#计算机网络-应用层（四）" class="headerlink" title="计算机网络-应用层（四）"></a>计算机网络-应用层（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;前面已经详细的讨论了计算机网络提供通信服务的过程。接下来讨论这些通信服务是如何提供给应用进程来使用的。每个应用层协议是为了解决某一类应用问题，问题的解决往往是通过位于不同主机的多个应用进程之间的通信和协同工作来完成的。应用层的协议许多都是基于客户服务器方式。即使是对等通信，实质也是一种特殊的客户服务器方式。</p>
  <a id="more"></a>
<p>&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7.jpg" alt=""></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><h4 id="DNS的由来"><a href="#DNS的由来" class="headerlink" title="DNS的由来"></a>DNS的由来</h4><p>&#160; &#160; &#160; &#160;DNS是因特网使用的命名系统，用来把便于使用的机器名字转换成IP地址。其实就是名字系统，之所以加上域，是因为命名系统中使用了很多的域。也不适合直接就使用域名系统，因为使用者方便了，机器处理起来就麻烦了，但是机器处理IP就比较方便，固定长度。</p>
<p>&#160; &#160; &#160; &#160;DNS被设计成为一个联机分布式数据库系统，并采用客户端服务器方式，大多数名字在本地进行解析，仅少量的需要在因特网上涌现，所以效率很高。</p>
<p>&#160; &#160; &#160; &#160;域名到IP地址的解析过程的要点如下：当某一个应用程序要把主机名解析为IP地址，该应用进程就跳用解析程序，并称为一个DNS客户，把待解析的域名放在DNS请求报文中，以 <strong>UDP</strong> 用户数据报方式发给本地域名服务器，本地域名服务器在查找域名后，把对应的ip地址放在回答报文中，应用程序获得目的主机的IP地址后即可进行通信。若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS中的另一个客户，向其他域名服务器发送查询请求。</p>
<h4 id="DNS的结构"><a href="#DNS的结构" class="headerlink" title="DNS的结构"></a>DNS的结构</h4><p>&#160; &#160; &#160; &#160;mail.cctv.com中mail、cctv、com分别为三级域名、二级域名、顶级域名。每个不要超过63个字符，其实最好不要超过12个方便记忆。不区分大小写，总共不超过255个。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493828954099&amp;di=d72c9e6fbec5a560b82ad6cce92d2359&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.eeing.com%2FUploadFile%2F20137810550682.jpg" alt=""></p>
<h3 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><h4 id="FTP和NFS"><a href="#FTP和NFS" class="headerlink" title="FTP和NFS"></a>FTP和NFS</h4><p>&#160; &#160; &#160; &#160;FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有的存取权限，它屏蔽了各计算机系统的细节，因而适合在于异构网络中任意计算机之间传送文件。分别有基于TCP和UDP的FTP，这是文件共享协议中的一大类，即复制整个文件；另外一类是联机访问，意味着允许多个程序同时对一个文件进行存取。和数据库系统不同的是用户不需要调用一个特殊的客户进程，而是由操作系统提供对原地共享文件进行访问的服务。</p>
<p>&#160; &#160; &#160; &#160;FTP主要功能是消除或减少在不同操作系统下处理文件的不兼容性。</p>
<p>&#160; &#160; &#160; &#160;FTP并非对所有数据传输都是最佳的，例如计算机A上运行的应用程序要在原地计算机B的很大一个文件末尾添加一行信息，使用FTP来回传很花时间。这时NFS网络文件系统就起作用了，NFS允许应用进程打开一个原地文件，并能在该文件的特定位置开始读写数据，在网络上传送的只是少量的修改数据。</p>
<h4 id="TFTP简单文件传送协议"><a href="#TFTP简单文件传送协议" class="headerlink" title="TFTP简单文件传送协议"></a>TFTP简单文件传送协议</h4><p>&#160; &#160; &#160; &#160;属于TCP／IP协议族，很小但是抑郁实现的文件传送协议。使用UDP协议，工作模式很像停止等待协议。端口号为69.</p>
<h4 id="远程终端协议-TELENT"><a href="#远程终端协议-TELENT" class="headerlink" title="远程终端协议 TELENT"></a>远程终端协议 TELENT</h4><p>&#160; &#160; &#160; &#160;用户用TELENT就可以在所在地使用TCP连接注册到远地的另一个主机上。其中有NVT网络虚拟终端，屏蔽了操作系统的差异。port：23</p>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>&#160; &#160; &#160; &#160;万维网是一个大规模联机式的信息储藏所，英文简称Web，万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，主动按序获取丰富的信息。1993年第一个图形界面的浏览器开发成功，叫做Mosaic，万维网是一个分布式的超媒体系统，它是超文本系统的扩展，就是所有网站的集合，用浏览器来访问其他站点的网站。万维网要解决的问题如下：</p>
<ol>
<li>怎么标志分布在整个因特网上的万维网文档？</li>
<li>用什么用的协议来实现万维网上各种链接？</li>
<li>怎样使用不同作战创作的不同风格的万维网文档都能在因特网上的各种主机上显示出来，同时使用户清楚知道什么地方存在着链接？</li>
<li>怎样使用户能够很方便的找到所需的信息？</li>
</ol>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>&#160; &#160; &#160; &#160;为了解决第一个问题，万维网使用统一资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内唯一标识符。</p>
<p>&#160; &#160; &#160; &#160;为了解决第二个问题，我们采用HTTP超文本传送协议，是一个应用层协议，使用TCP链接进行可靠的传送。</p>
<p>&#160; &#160; &#160; &#160;为了解决第三个问题，万维网使用HTML超文本标记语言，使设计者很方便地使用链接从本页面的某处链接到因特网的任何一个万维网页面</p>
<p>&#160; &#160; &#160; &#160;第四个问题，搜索工具应运而生，帮助我们在万维网上查找自己所需的信息。</p>
<p>&#160; &#160; &#160; &#160;下面看看在此实现思路基础上的具体的实现方式。</p>
<h4 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h4><p>&#160; &#160; &#160; &#160;一般形式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。其中协议一般是http、https、ftp等，主机是域名，或者主机的外网ip，端口和路径有时可以省略。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>&#160; &#160; &#160; &#160;HTTP协议定义了浏览器即万维网客户进程怎么样向万维网服务器请求万维网文档，以及服务器怎么样把文档传送给浏览器。HTTP是面向事务的应用层协议。通常基于TCP协议的，每个万维网网点都有一个服务器进程，不断监听TCP的端口80，以便发现是否有浏览器向他发出连接请求。一旦监听到建立TCP连接，通信结束后释放。交互必须遵循HTTP，它规定每次交互都由一个ASCII码串构成的请求和一个类MIME的响应。</p>
<p>tips：浏览器敲入百度网址到响应的过程。</p>
<h5 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h5><p>&#160; &#160; &#160; &#160;参考这篇博文：<a href="http://blog.csdn.net/zhangliang_571/article/details/23508953" target="_blank" rel="external">http请求报文和响应报文</a>。请求报文中请求方法Get和Post的区别，区别如下列出，响应报文中状态行有200 OK，404等等。这些参考博文，写的很好，分析清楚。</p>
<h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><p>1.提交方式</p>
<p>&#160; &#160; &#160; &#160;GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>  &#160; &#160; &#160; &#160;POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>  &#160; &#160; &#160; &#160;因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p>2.传输数据的大小：</p>
<p>   &#160; &#160; &#160; &#160;首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>
<p>   &#160; &#160; &#160; &#160;GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>   &#160; &#160; &#160; &#160;因此对于GET提交时，传输数据就会受到URL长度的限制。</p>
<p>   &#160; &#160; &#160; &#160;POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3.安全性：</p>
<p>&#160; &#160; &#160; &#160;POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>
<h6 id="常见响应"><a href="#常见响应" class="headerlink" title="常见响应"></a>常见响应</h6><p>200 OK：客户端请求成功。</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>
<p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p>
<p>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</p>
<p>500 Internal Server Error：服务器发生不可预期的错误。</p>
<p>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>&#160; &#160; &#160; &#160;分为静态html和动态html还有活动万维网文档。静态文档是固定的html，只用于显示。</p>
<p>&#160; &#160; &#160; &#160;动态文档就是指是文档内容在浏览器访问万维网时才由应用程序动态创建。所以我们需要增加一个应用程序来处理浏览器发来的数据，并动态创建文档。还要增加一个机制，用来使万维网服务器将浏览器发来的数据传送给这个应用程序，这个就叫做通用网关接口CGI。后来称为CGI程序，可以是使用Perl、REXX，JS，C，C++等语言，脚本语言和编程语言都有，为了方便找到CGI程序，都放在cgi／bin目录下。</p>
<p>&#160; &#160; &#160; &#160;后来动态文档也不能满足了，因为动态文档一旦建立，它所包含的信息内容页固定下来了，像动画这类的效果也无法提供，后来出现服务器推送，服务器不断运行和动态文档相关联的应用，定期更新信息，缺点是为了满足很多客户的请求，服务器就要运行很多推送程序。太多导致带宽不够，网络延时也很大。另一种就是活动文档技术，每当浏览器请求一个活动文档，服务器就返回一段程序副本，使程序在浏览器端进行，像Java的applet应用，html中嵌入一个java小程序。</p>
<h4 id="信息检索系统"><a href="#信息检索系统" class="headerlink" title="信息检索系统"></a>信息检索系统</h4><p>&#160; &#160; &#160; &#160;搜索引擎，全文检索与分类目录搜索。垂直搜索引擎，元搜索引擎。</p>
<p>&#160; &#160; &#160; &#160;谷歌搜索核心技术就是PageRank，最搜索出来的结果按重要性进行排序。Google 论文老三篇 GFS, MapReduce, BigTable 不再赘述，近年 Google 在这些方面的研发和进步没有停滞甚至在加快。当然百度也在努力追赶，百度不仅使用 Hadoop, 而且基于 Hadoop 做了大量改进和扩展，并贡献回 Hadoop 开源社区。后面准备进行一些爬虫的实践。</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="SMTP、POP3、IMAP"><a href="#SMTP、POP3、IMAP" class="headerlink" title="SMTP、POP3、IMAP"></a>SMTP、POP3、IMAP</h4><p>&#160; &#160; &#160; &#160;简单邮件传送协议，只能传送可打印的7位ASCII码邮件，后来又出现MIME通用互联网邮件扩充，后来还进行了修订。</p>
<p>&#160; &#160; &#160; &#160;电子邮件系统应该具有三个重要的组成构件，用户代理，邮件服务器，以及邮件发送协议。区别：IMAP在服务器保存副本。参考博文：<a href="http://blog.csdn.net/ladybai/article/details/509882050" target="_blank" rel="external">电子邮件协议之SMTP、POP3和IMAP</a>。</p>
<h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><p>&#160; &#160; &#160; &#160;基于UDP，为了把协议软件做成通用的和便于移植，协议软件的编写者不会把所有细节都固定在源代码中。相反会把协议软件参数化。前身是BOOTP引导程序协议，需要人工参与，DHCP是即插即用，对服务器和客户端都适用。</p>
<h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><p>被管对象上运行的SNMP服务器不断监听来自管理站的SNMP客户端请求，一旦发现立即返回管理站所需信息，或者执行某个动作。</p>
<h3 id="跨越网络的应用进程通信"><a href="#跨越网络的应用进程通信" class="headerlink" title="跨越网络的应用进程通信"></a>跨越网络的应用进程通信</h3><p>当很多的应用层协议还不能满足我们的需求，于是开放了相关的系统调用和应用程序编程接口，即网络socket编程。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-应用层（四）&quot;&gt;&lt;a href=&quot;#计算机网络-应用层（四）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-应用层（四）&quot;&gt;&lt;/a&gt;计算机网络-应用层（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;前面已经详细的讨论了计算机网络提供通信服务的过程。接下来讨论这些通信服务是如何提供给应用进程来使用的。每个应用层协议是为了解决某一类应用问题，问题的解决往往是通过位于不同主机的多个应用进程之间的通信和协同工作来完成的。应用层的协议许多都是基于客户服务器方式。即使是对等通信，实质也是一种特殊的客户服务器方式。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（三）</title>
    <link href="http://yoursite.com/2016/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/22/计算机网络学习笔记（三）/</id>
    <published>2016-12-22T00:09:00.000Z</published>
    <updated>2017-05-03T11:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-运输层（三）"><a href="#计算机网络-运输层（三）" class="headerlink" title="计算机网络-运输层（三）"></a>计算机网络-运输层（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;运输层是整个网络体系结构中的关键层次。TCP／IP体系中运输层最重要的两个协议：UDP和TCP。TCP是保证可靠的交付，UDP是尽最大努力的交付。重点是TCP的各种机制是如何保证可靠交付，在面向连接的可靠服务、流量控制、拥塞控制等方面作出了何种的努力，以及TCP连接的三次握手和断开连接的四次挥手以及为什么这样设计。本节篇幅很长，多图，内容很关键。</p>
  <a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>&#160; &#160; &#160; &#160;从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它是面向通信部分的最高层，也是用户功能的最低层。当网络的边缘部分的两个主机利用网络的核心部分的功能进行端到端的通信时，<font color="red">只有主机的协议栈才有运输层</font>，而网络核心部分中的路由器在转发分组的时候都只用到了下三层的功能。<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;从上图可知：从IP层来说，通信的是主机，但是两个主机之间通信的说法还不够清楚，这是因为，真正进行通信的实体是两个主机上的进程，从运输层来看并不是主机而是主机上的进程。</p>
<p>&#160; &#160; &#160; &#160;运输层提供应用进程之间的逻辑通信。意思是：运输层之间的通信好像是沿着水平方向传送数据，但实际并没有物理连接。数据在多个层次之间传送。（网络层是主机之间的逻辑通信），如之前所讲运输层还进行差错检测等，运输层向高层屏蔽了下面网络核心的细节，它使应用进程看见的好像是两个运输实体之间一条端到端的逻辑通信，当然运输层协议不同对上层的表现也很大不同。</p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><h4 id="概述和相关应用"><a href="#概述和相关应用" class="headerlink" title="概述和相关应用"></a>概述和相关应用</h4><p>&#160; &#160; &#160; &#160;运输层的两个主要协议：用户数据报协议UDP和传输控制协议TCP。UDP面向无连接，不提供可靠交付，但是却是一种最有效的工作方式。TCP提供面向连接的，可靠的服务。TCP不提供多播服务，依赖额外的开销进行，确认、流量控制、计时器、连接管理等，协议数据单元的首部变大，也占用了很多处理机资源。下面给出两种协议在应用层的相关应用。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%BA%94%E7%94%A8.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;两者之间的区别如下：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20151018103115179" alt=""></p>
<h4 id="端口的由来"><a href="#端口的由来" class="headerlink" title="端口的由来"></a>端口的由来</h4><p>&#160; &#160; &#160; &#160;运输层和应用层采用了复用和分用，应用层所有的应用进程都可以利用运输层传到IP层，运输层从IP层收到数据后在指定某个进程交付通信。现在重点是给每个应用进程赋予一个非常明确的标志。然而不同的操作系统有不同的进程标识符（一个不大的整数），所以TCP／IP体系对进程统一标志。即使是这样，还存在问题，比如要和因特网上的某个邮件服务器通信，我在不知道对方的进程没法完成通信，显然是不科学的，解决方法是：<font color="red">在运输层使用<em>协议端口号</em>，虽然说通信终点是应用进程，但是我们只用把数据送到指定端口，剩下来的工作交给TCP去完成。</font>常见的端口号如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7.jpg" alt=""></p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.无连接，减小了开销和时延。</p>
<p>2.最大努力交付，不保证可靠交付，不需要维持复杂的状态连接表。</p>
<p>3.面向报文，对于应用层的报文，只添加首部，保留边界，一次性交付，所以应用程序要选择合适大小的报文，太长或太短都会降低IP层效率，长了会分片，短了首部相对就太长。</p>
<p>4.没有拥塞控制，支持一对一，一对多，多对多的交互通信，首部开销小。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/UDP.png" alt=""></p>
<h5 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h5><p>&#160; &#160; &#160; &#160;UDP首部较为简单，包含四个部分，其中伪首部是计算检验和时临时添加，并不向上或向下传递，如下图：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png" alt=""></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1.面向连接。先建立连接在通信，最后释放连接。就像打电话一样。</p>
<p>2.连接只能是一对一点对点。</p>
<p>3.提供可靠交付，无差错、不丢失、不重复、按序到达。</p>
<p>4.全双工通信，双方任何时候都能发送，两端都设有发送和接收缓存。</p>
<p>5.面向字节流。TCP并不知道所传数据的含义，统一当成无结构的字节流，存在发送方发送10个数据块，接收方只用了4个数据块就把收到的字节流交付给应用层。当然接收方的应用程序必须有能力识别收到的字节流并还原成应用层数据。</p>
<h4 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h4><h5 id="停止等待协议–应用：ARQ自动重传请求"><a href="#停止等待协议–应用：ARQ自动重传请求" class="headerlink" title="停止等待协议–应用：ARQ自动重传请求"></a>停止等待协议–应用：ARQ自动重传请求</h5><p>&#160; &#160; &#160; &#160;每发送完一个分组就停止发送，等待对方确认，收到确认在发送下一个分组。</p>
<p>&#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;如果出现差错，就要<font color="red">超时重传</font>，为了实现这一功能，需要做以下工作：</p>
<p>&#160; &#160; &#160; &#160;1.设计超时计时器，且超时时间比平均往返时间更长。（超时时间设定是个复杂问题）</p>
<p>&#160; &#160; &#160; &#160;2.必须保留已发送分组的副本。</p>
<p>&#160; &#160; &#160; &#160;3.对发送的分组编号，才知道哪个没发送成功。</p>
<p>&#160; &#160; &#160; &#160;4.确认丢失和确认迟到。也许超时之后，接收方还是收到了，这时候就会丢弃重复的分组，进行确认，分为确认丢失和确认迟到，所以说，发送方总是会收到确认，如果总是收不到说明通信线路太差不能通信。</p>
<h5 id="TCP首部格式（重点）"><a href="#TCP首部格式（重点）" class="headerlink" title="TCP首部格式（重点）"></a><font color="red">TCP首部格式（重点）</font></h5><p>&#160; &#160; &#160; &#160;虽然TCP是面向字节流的，但是TCP传送的数据单元缺失报文段。20+4N的格式，20是固定的，根据需要以4N字节增加。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/TCP%E9%A6%96%E9%83%A8.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;</p>
<ol>
<li><p>源端口和目的端口，各占2个字节，分别写入源端口号和目的端口号。</p>
</li>
<li><p>序号 占4个字节，范围时0到2^32-1，采用mod 2^32运算。</p>
</li>
<li><p>确认号 期望收到对方下一个报文段的第一个数据字节的序号。</p>
</li>
<li><p>数据偏移  占4位，指定TCP报文段的首部长度，4位二进制最大时十进制15，以4歌字节为计算单位，所以，首部最大长度时60，即选项长度最大60。</p>
</li>
<li><p>保留为今后使用，预留字段6位，目前为0。</p>
</li>
<li><p>紧急URG URG为1则高优先级传送，而不需要排队，和紧急指针配合使用。</p>
</li>
<li>确认ACK 仅等于1才有效，确认连接后所有传送的报文段都必须把ACK置为1。</li>
<li>推送 PSH 希望立即收到对方响应，这时要把PSH置为1，立即创建报文传出去，接收方不在进入缓存而直接进入应用进程。但很少使用。</li>
<li>复位RST 当RST=1时，表明TCP连接出现严重差错需要立即释放。</li>
<li>同步SYN 当SYN=1而ACK=0时表明这是一个连接请求，SYN置为1表示这是一个连接请求或者连接接受报文。</li>
<li>终止FIN 用来释放一个连接。置为1时释放连接。</li>
<li>窗口 占2个字节，所以窗口值是0到2^16-1之间的整数，窗口值作为接收方让发送方设置其发送窗口的依据。表明现在允许对方发送的数据量，动态变化。</li>
<li>检验和 2个字节，检验的范围包括首部和数据这两部分。同样和UDP一样要加上12个字节的伪首部，伪首部的协议号17修改为6（TCP的协议号），长度字段，如果使用ipv6相应地方也要改变。</li>
<li>紧急指针 2个字节，仅在URG=1才有意义，指定本报文段中的紧急数据所在位置。</li>
<li>选项 长度可变，最多40，4个为基本单位。选项中有窗口扩大、时间戳、选择确认等。</li>
</ol>
<h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><ol>
<li><p>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>数据合理分片和排序：<br>UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.<br>tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</p>
</li>
<li><p>流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
</li>
<li><p>拥塞控制：当网络拥塞时，减少数据的发送。</p>
</li>
</ol>
<p>还可以参考这个博客：<a href="http://blog.csdn.net/shawjan/article/details/45117945" target="_blank" rel="external">如何讲清楚TCP的可靠性传输</a>。</p>
<h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><h5 id="为什么使用窗口"><a href="#为什么使用窗口" class="headerlink" title="为什么使用窗口"></a>为什么使用窗口</h5><p>&#160; &#160; &#160; &#160;因为发送端希望在收到确认前，继续发送其它报文段。比如说在收到0号报文的确认前还发出了1-3号的报文，这样提高了信道的利用率。但可以想想，0-4发出去后可能要重传，所以需要一个缓冲区维护这些报文，所以就有了窗口。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190409249-1100672672.png" alt=""></p>
<h5 id="窗口怎么实现"><a href="#窗口怎么实现" class="headerlink" title="窗口怎么实现"></a>窗口怎么实现</h5><h6 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h6><p>&#160; &#160; &#160; &#160;接收窗口”大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。图中，接收窗口是31~50，大小为20。</p>
<ol>
<li>在接收窗口中，黑色的表示已收到的数据，白色的表示未收到的数据。</li>
<li>当收到窗口左边的数据，如27，则丢弃，因为这部分已经交付给主机；</li>
<li>当收到窗口左边的数据，如52，则丢弃，因为还没轮到它；</li>
<li>当收到已收到的窗口中的数据，如32，丢弃；</li>
<li>当收到未收到的窗口中的数据，如35，缓存在窗口中。</li>
</ol>
<p>tips：按序到达的、但尚未被接收应用程序读取的数据和未按序到达的数据</p>
<p>　　<br>　　<img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190456874-770659297.png" alt=""></p>
<h6 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h6><p>发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制，暂时可以理解为swnd= rwnd =20。图中分为四个区段，其中P1到P3是发送窗口。发送窗口以字节为单位。为了方便画图，图中展示得像以报文为单位一样。但这不影响理解。</p>
<p><img src="http://images2015.cnblogs.com/blog/476810/201605/476810-20160508190555749-856898339.png" alt=""></p>
<p>tips：发送应用程序传送给发送方TCP准备发送的数据和TCP已经发送出但尚未收到确认的数据</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>强调以下三点：</p>
<ol>
<li>虽然A的发送窗口是根据B接受窗口设置的，但在同一时刻，A和B的窗口大小并不一定一样，这是因为传送需要一个时延而且是不确定的。发送方A还可能根据当时的网络拥塞减小窗口数值。</li>
<li>对于不按序到达的数据该如何处理，TCP标准并无明确规定，如果接收方一律丢弃，那么管理相对简单，但是对网络资源利用率下降，所以通常是对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到后再交付给上层进程。</li>
<li>TCP要求接收方必须有 <strong>累积确认</strong> 的功能，这样可以减少传输开销。因为只确认收到最后一个分组代表之前的全都正确传输。可以在合适的时候发送确认，不会导致不必要的重传，TCP规定确认推迟时间不超过0.5秒。</li>
</ol>
<h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><p>&#160; &#160; &#160; &#160;TCP采用了一种自适应的算法，它记录RTT，加权平均的RTTs，超时重传时间：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;RTO=RTTs+4*RTTD</p>
<p>&#160; &#160; &#160; &#160;RTTD第一次测量时为RDDs的一半，在使用下式计算甲醛平均的RTTD：</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160;RTTD=（1-x）*（旧的加权平均RTTD）+x|RTTs-新的RTT|</p>
<p>&#160; &#160; &#160;&#160;其中x建议为0.25.</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p> &#160; &#160; &#160;&#160;有一种情况可能导致死锁。B向A发送零窗口报文段，然后就有缓存空间了，又向A发送一定长度的报文，但是A收到零窗口报文之后一直等待非零窗口的通知，B传的数据就丢失了，A和B一直都在等待，出现死锁。</p>
<p> &#160; &#160; &#160;&#160;解决：TCP为每个连接设置一个持续计时器。只要连接一方接收到零窗口的通知，就启动，若在设置时间内到期，就发送一个零窗口一个字节的探测报文段，对方给出现在的窗口值。</p>
<p> &#160; &#160; &#160;&#160;合适时间确认的选择：接收方等待一段时间或者等到缓存已有一半空闲空间。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>&#160;&#160;&#160;&#160; 网络资源（链路容量即带宽、交换节点种缓存和处理机）呈现供应不足，整个网络性能就会变坏。吞吐量随着负荷增加而下降。这就是拥塞。</p>
<p>&#160;&#160;&#160;&#160;拥塞控制和流量控制息息相关，但也有一些差别，拥塞控制是防止过多的数据注入到网络导致路由器或者链路的过载，是全局性的把控，流量控制往往只点到点通信量的控制，是端到端的问题。</p>
<p>&#160;&#160;&#160;&#160;几种拥塞控制方法：慢开始、拥塞避免、快重传、快恢复等还有相关改进。</p>
<h3 id="TCP连接建立和释放"><a href="#TCP连接建立和释放" class="headerlink" title="TCP连接建立和释放"></a>TCP连接建立和释放</h3><p><a href="http://blog.csdn.net/renzhenhuai/article/details/12105457" target="_blank" rel="external">什么是三次握手和四次挥手</a>。</p>
<p><a href="http://blog.csdn.net/xifeijian/article/details/12777187" target="_blank" rel="external">为什么要三次握手和四次挥手</a>。</p>
<h3 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h3><p>&#160; &#160; &#160; &#160;Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>&#160; &#160; &#160; &#160;注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.my.csdn.net/uploads/201204/10/1334044170_5136.jpg" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-运输层（三）&quot;&gt;&lt;a href=&quot;#计算机网络-运输层（三）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-运输层（三）&quot;&gt;&lt;/a&gt;计算机网络-运输层（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;运输层是整个网络体系结构中的关键层次。TCP／IP体系中运输层最重要的两个协议：UDP和TCP。TCP是保证可靠的交付，UDP是尽最大努力的交付。重点是TCP的各种机制是如何保证可靠交付，在面向连接的可靠服务、流量控制、拥塞控制等方面作出了何种的努力，以及TCP连接的三次握手和断开连接的四次挥手以及为什么这样设计。本节篇幅很长，多图，内容很关键。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（二）</title>
    <link href="http://yoursite.com/2016/12/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/15/计算机网络学习笔记（二）/</id>
    <published>2016-12-15T00:36:05.000Z</published>
    <updated>2017-05-04T13:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;接下来会介绍最重要的几层，就是网络层（IP），运输层（TCP，UDP），应用层（HTTP，DNS，STMP等）。IP的分配，子网掩码，IP协议确保数据流主机到主机，而计算机通信代表的是计算上进程之间的通信，所以TCP，UDP提出端口概念，一个进程占用一个端口，这样就实现了准确的通信。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;TCP和UDP两者的不同是：TCP先建立连接且利用相关技术保证了可靠的传输，而UDP只是尽最大限度的进行传输，是面向非连接的，是不可靠的，两者在应用层都有相关利用。另外，ip+：+port就是套接字socket。所谓的socket通信中的socket是一个编程api，设计之初它的思想是不止用于TCP／IP协议，一般的用法是它指定源套接字和目的套接字，再指定使用的协议，这样就能实现通信，它能实现TCP／IP协议的通信，具体在后面章节结合图和实例阐述。</p>
<h1 id="计算机网络-网络层（二）"><a href="#计算机网络-网络层（二）" class="headerlink" title="计算机网络-网络层（二）"></a>计算机网络-网络层（二）</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>即虚电路服务和数据报服务。</p>
<p>&#160; &#160; &#160; &#160;虚电路：面向连接的，建立虚电路，以保证双方通信所需的一切资源，这是一条逻辑上的连接，不同于电话交换的物理连接，如果再使用可靠的网络传输协议，就可使所发送的分组无差错按步序到达终点。</p>
<p>&#160; &#160; &#160; &#160;数据报服务：无连接的通信方式，只提供尽最大能力交付的数据报服务。</p>
<p>&#160; &#160; &#160; &#160;这两种方式，在当时很有争议，焦点就是到底可靠的交付是在网络层还是运输层，有人觉得借助电信网成功经验，而互联网先驱却提出崭新的设计思路：<font color="red">交给上层即计算机来进行差错处理，充分利用了计算机的处理能力。</font>多年实践证明，当时决定在交给上层去实现可靠传输就是正确决定。由于在网络层要保证可靠的传输成本很大，而现在只需成本较低的路由器就行。将可靠的交付交给运输层来解决，即我们的TCP协议。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494293515&amp;di=f0143bb189d8a9c8cde2a47f038d8133&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fblog.chinaunix.net%2Fattachment%2F201402%2F14%2F26275986_1392346156Z19P.png" alt=""></p>
<h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>&#160; &#160; &#160; &#160;进行网络的互连可能借助以下设备：物理层-集线器；数据链路层-交换机；网络层-路由器；更高层-网关。而从网络层看使用集线器和交换机只是扩大了当前网络，并没有进行网络互连，从网络层来看它仍是一个网络。而网关比较复杂，所以一般采用<font color="red">路由器</font>进行网络互连。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">TCP／IP体系中在网络层采用了标准化协议，即使互连的网络是异构的，在网络层看了它好像是一个统一的网络，但是是逻辑互连，内部差异性仍然存在。</font></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>&#160; &#160; &#160; &#160;文档：RFC791；整个因特网是一个单一的，抽象的网络。IP地址就是给因特网上的每一个主机或路由器的每一个借口分配一个在全世界范围内唯一的32位标识符。IP地址表示为：{&lt;网络号&gt;,&lt;主机号&gt;}。分类如下图：</p>
<p>&#160; &#160; &#160; &#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1494294197&amp;di=f001c8f32c69d084119f3968d732d922&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fwww.bo56.com%2Fwp-content%2Fuploads%2F2014%2F11%2Fip_class.png" alt=""></p>
<h3 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h3><p>&#160; &#160; &#160; &#160;物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。它们分别在IP数据报和MAC帧的首部。如下图所示：</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493700242235&amp;di=3a2d74e813de29bb1f389b000b2f6e86&amp;imgtype=0&amp;src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F672098%2F201501%2F082256050466766.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;<font color="red">尽管互连在一起的网络硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层的这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或者路由器之间的通信。</font>关于这方面有重要的两个协议。ARP和RARP。</p>
<h3 id="ARP和RARP协议"><a href="#ARP和RARP协议" class="headerlink" title="ARP和RARP协议"></a>ARP和RARP协议</h3><p>&#160; &#160; &#160; &#160;地址解析协议ARP，和逆地址解析协议RARP。来实现IP地址和硬件地址的相互转换。<font color="red">现在RARP的功能在DHCP中已经完成，所以没人再单独使用了。</font></p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>&#160; &#160; &#160; &#160;ARP高速缓存，请求的时候广播，得到结果保存到缓存中，且定时更新，因为如果请求的主机网络适配器坏了，它的硬件地址也就坏了，改变了，定时更新防止这种情况。</p>
<p>详细细节参考这篇博文。<a href="http://www.cnblogs.com/luckyxiaoxuan/p/3395527.html" target="_blank" rel="external">ARP协议详解</a></p>
<h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p><img src="http://opb7t58xj.bkt.clouddn.com/3B60552E-D2CB-41B7-B487-247D91DB9423.png" alt=""></p>
<p>（1） 版本（version）：包含IP地址的版本号，4个比特。</p>
<p>（2） 首部长度（header length）：表示IP数据报头长度，4个比特。</p>
<p>（3） 优先级与服务器类型（priority and type of service）:用于表示数据包的优先级和服务器类型，8个比特。</p>
<p>（4） 总长度（total length）：表示整个IP数据包的长度，16个比特（两个字节）。</p>
<p>（5） 标识符（identification）：用于表示IP数据包的标识符，16个比特。</p>
<p>（6） 标志（flags）：标志字段，3个比特。</p>
<p>（7） 段偏移量（fragment offset）：用于表示段的偏移量。</p>
<p>（8） TTL(time to time)：表示IP数据包的生命周期，8个比特。当TTL为0时，该数据包将被丢弃。TTL还对应一个数据报通过的路由器的数目。一个数据报每经过一个路由器，TTL值就会减一。</p>
<p>（9） 协议号：（protocol）：协议字段，8个比特，表示IP数据段封装的协议，是TCP还是UDP，TCP的协议号是6，UDP的协议号是17。</p>
<p>（10） 首部校验和（header chechsum）：用于表示校验和，16个比特。</p>
<p>（11） 源地址（SA，source ip address）：32比特位，表示数据包的源地址</p>
<p>（12） 目的地址（DA，destination ip address），32个比特位，表示数据报道目的地址。</p>
<p>（13） 可选项,内容其实很丰富，用来支持排错、测量以及安全等措施1-40个字节。</p>
<h3 id="子网划分、路由表、超网——解决怎么转发"><a href="#子网划分、路由表、超网——解决怎么转发" class="headerlink" title="子网划分、路由表、超网——解决怎么转发"></a>子网划分、路由表、超网——<strong>解决怎么转发</strong></h3><h4 id="原始做法："><a href="#原始做法：" class="headerlink" title="原始做法："></a>原始做法：</h4><p>&#160; &#160; &#160; &#160;<em>数据报在网络层怎么转发</em>：分组转发算法。数据报在IP层转发分组就是从一个路由器转发到下一个路由器，直到到达目的主机。路由器中有路由表保存下面两个信息：（目的网络地址，下一跳地址），也有默认路由，中间可能经过多次的间接交付。</p>
<p>&#160; &#160; &#160; &#160;<em>存在的问题</em>：因为，第一：IP地址空间的利用率有时很低；第二：路由表太大导致性能变坏；第三：两级IP地址不够灵活。</p>
<p>&#160; &#160; &#160; &#160;<em>策略</em>：<font color="red">划分子网，采用三级IP地址。</font>IP地址表示为{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}，子网在外看仍然表现成一个网络，内部确感觉划分了若干个子网。增加灵活性，减少主机数。子网掩码：和IP按位与运算得到网络地址。在路由表中加入<font color="red">子网掩码信息</font>。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/ziwangyanma.png" alt=""></p>
<h4 id="在划分子网情况下，路由器转发分组算法"><a href="#在划分子网情况下，路由器转发分组算法" class="headerlink" title="在划分子网情况下，路由器转发分组算法"></a>在划分子网情况下，路由器转发分组算法</h4><p>（1）从分组的首部提取目的IP地址D</p>
<p>（2）先用与该路由器直接相连的网络的子网掩码与D进行与运算，看结果是否与相应的网络 地址相匹配。若匹配，则进行直接交付。否则就是间接交付，马上执行3</p>
<p>（3）若路由表中有一条到目的主机D的特定路由，则将分组转发给其指明的下一跳路由器。否则执行4</p>
<p>（4）对路由表中每一行的子网掩码和D进行与运算，若结果与该行的目的网络地址匹配，则将分组传给该行指明的下一跳路由器。否则执行5</p>
<p>（5）若路由表中有一个默认路由，则将分组传给路由表中指明的默认路由器。否则执行6</p>
<p>（6）报告转发分组出错。</p>
<h4 id="CIDR-无分类编址（构造超网）"><a href="#CIDR-无分类编址（构造超网）" class="headerlink" title="CIDR 无分类编址（构造超网）"></a>CIDR 无分类编址（构造超网）</h4><p>出现问题：IP地址都快分完了。</p>
<p>解决办法：CIDR，特点：消除传统的A、B、C类地址以及划分子网的概念，回到二级地址，网络前缀+主机号，还可采用斜线法，斜线数字代表前缀中1的个数。</p>
<h4 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h4><p>&#160; &#160; &#160; &#160;两者比较可参考这个博文：<a href="http://tech.hexun.com/2015-01-10/172249335.html" target="_blank" rel="external">ipv4和ipv6之间区别比较</a>，但是当前主流的仍然是v4，为什么，这个我看了下知乎上的答案：<a href="http://tech.hexun.com/2015-01-10/172249335.html" target="_blank" rel="external">IPv6的概念都出来好久了，为什么现在的主流还是IPv4？</a>,感觉主要是已经大范围的使用，如果要更新，很多软硬件需要换代，这样成本太高。。。</p>
<h3 id="ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠"><a href="#ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠" class="headerlink" title="ICMP网际控制报文协议——解决怎么尽最大限度的保证可靠"></a>ICMP网际控制报文协议——<strong>解决怎么尽最大限度的保证可靠</strong></h3><p>&#160; &#160; &#160; &#160;为了更有效的转发IP数据和提高交付机会，使用ICMP，IP层协议。应用于IP主机和路由器之间传递控制消息。它的应用有常用<font color="red">ping</font>。<br>详细细节参考博文：<a href="http://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" target="_blank" rel="external">ping原理和ICMP协议</a>，<a href="http://network.chinabyte.com/23/13155523.shtml" target="_blank" rel="external">ICMP协议基础讲解</a>。</p>
<h3 id="因特网路由选择协议——解决路由选择"><a href="#因特网路由选择协议——解决路由选择" class="headerlink" title="因特网路由选择协议——解决路由选择"></a>因特网路由选择协议——<strong>解决路由选择</strong></h3><p>&#160; &#160; &#160; &#160;目前的因特网中，一个大的ISP（信息服务提供者）就是一个AS（自治系统），分两类内部网关协议IGP和外部网关协议EGP，自治系统之间的路由也叫做域间路由选择，内部叫做域内路由选择。</p>
<h4 id="内部网关协议RIP和OSPF"><a href="#内部网关协议RIP和OSPF" class="headerlink" title="内部网关协议RIP和OSPF"></a>内部网关协议RIP和OSPF</h4><p>&#160; &#160; &#160; &#160;两者的内容和比较可以参考博文：<a href="http://www.2cto.com/net/201210/161420.html" target="_blank" rel="external">RIP和OSPF的区别比较</a>。</p>
<h4 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h4><p>BGP是不同自治系统的路由器之间交换路由信息的协议。只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要找到一条最佳。</p>
<p><a href="http://blog.csdn.net/cogbee/article/details/35228467" target="_blank" rel="external">动态路由选择三个协议之间比较</a></p>
<h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>&#160; &#160; &#160; &#160;在因特网上进行多播，比如90个主机接收视频节目，并不能去一个个去发送，应该是发送一次，收听的人都收到。能运行多播协议的路由器叫多播路由器。</p>
<h4 id="多播所用到的协议"><a href="#多播所用到的协议" class="headerlink" title="多播所用到的协议"></a>多播所用到的协议</h4><p>&#160; &#160; &#160; &#160;IP多播需要两种协议：网际组管协议IGMP和多播路由选择协议（尚未标准化）</p>
<h3 id="VPN和NAT"><a href="#VPN和NAT" class="headerlink" title="VPN和NAT"></a>VPN和NAT</h3><p>&#160; &#160; &#160; &#160;有的时候有些机构的很多部分分布在相距较远的地点。不同地点有自己的专用网，如果这些专用网要进行通信的话那么就有两种方式。一种是租用电信公司的线路，但是这样费用较高；另外一种就是建立VPN。</p>
<p><img src="http://up.2cto.com/2013/0805/20130805084039266.jpeg" alt=""></p>
<p>&#160; &#160; &#160; &#160;显然，每个场所至少要有一个路由器具有合法的全球IP地址，如图中R1、R2。这两个路由器和因特网的接口地址必须是合法的全球地址，在专用网内部的接口地址则是专用网的本地地址。如果场所A中的主机需要和场所B中的主机进行通信的话，那么就需要经过R1、R2。</p>
<p>&#160; &#160; &#160; &#160;现在有一个问题就是，在专用网内部的主机有一个专用地址，但是又想和因特网上的主机通信，那么该怎么办？</p>
<p>&#160; &#160; &#160; &#160;网络地址转换NAT(Network Address Translation)，就用来解决这个问题。这种方法首先需要在专用网连接到因特网的路由器上安装NAT软件。就是当专用网的主机和外部网进行通信的时候，数据包经过NAT路由器的时，NAT路由器将专用网地址转换为一个全球地址，然后并记录下这个转换对。当收到发往某全球地址的数据包时候，再将此数据包转发到内部网中得某主机（与该地址对应的内部主机）。如下图：<br><img src="http://up.2cto.com/2013/0805/20130805084048370.jpeg" alt=""></p>
<p>&#160; &#160; &#160; &#160;如果NAT路由器有N个全球地址的话，那么就可以支持专用网内部N台主机同时与因特网进行通信。这样就可以使得专用网内较多的主机轮流使用这N个全球地址。注意：因为地址转换的关系，所以通过NAT路由器的通信必须由专用网内的主机发起。理解???因为一开始不知道如何转换。所以专用网内部的主机是不可以作为服务器的。</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;接下来会介绍最重要的几层，就是网络层（IP），运输层（TCP，UDP），应用层（HTTP，DNS，STMP等）。IP的分配，子网掩码，IP协议确保数据流主机到主机，而计算机通信代表的是计算上进程之间的通信，所以TCP，UDP提出端口概念，一个进程占用一个端口，这样就实现了准确的通信。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（一）</title>
    <link href="http://yoursite.com/2016/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/08/计算机网络学习笔记（一）/</id>
    <published>2016-12-08T01:05:46.000Z</published>
    <updated>2017-05-05T12:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-概述（一）"><a href="#计算机网络-概述（一）" class="headerlink" title="计算机网络-概述（一）"></a>计算机网络-概述（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;非计算机专业，有过计算机网络的课程，但是理解的很浅显，最近从很多的学习过程中感觉这方面确实要加强，因为主要的学习方向是Java Web，但是却连计算机网络的知识都不扎实，确实也说不过去，希望能系统的学习一下，查阅了网上的资料，下载了相关视频，书籍和ppt，学的是《计算机网络》谢希仁版的教材，下面记录学习中的重点部分和理解。</p>
  <a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="传统网络的意义"><a href="#传统网络的意义" class="headerlink" title="传统网络的意义"></a>传统网络的意义</h3><p>&#160; &#160; &#160; &#160;网络通常指的是最主要的三种网络，分别是电信网络、有线电视网络、计算机网络（核心）。想象一下以前家里电信网络可以链接互联网，通过调制解调器，然后现在家里电视机可以联网，机顶盒插网线。相互之间都可以通信。</p>
<h3 id="电路交换、报文交换、分组交换的比较"><a href="#电路交换、报文交换、分组交换的比较" class="headerlink" title="电路交换、报文交换、分组交换的比较"></a>电路交换、报文交换、分组交换的比较</h3><p>&#160; &#160; &#160; &#160;<br>1、电路交换<br>公共电话网(PSTN网)和移动网(包括GSM和CDMA网)采用的都是电路交换技术，它的基本特点是采用面向连接的方式，在双方进行通信之前，需要为通信双方分配一条具有固定宽带的通信电路，通信双方在通信过程中一直占用所分配的资源，直到通信结束，并且在电路的建立和释放过程中都需要利用相关的信令协议。这种方式的优点是在通信过程中可以保证为用户提供足够的带宽，并且实时性强，时延小，交换设备成本低，但同时带来的缺点是信道利用率低，一旦电路被建立不管通信双方是否处于通话状态分配的电路一直被占用。比如我们拨号的时候，对方应答则建立连接，双方进入占线状态。</p>
<p>2、报文交换<br>    报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式；由于报文长度差异很大，长报文可能导致很大的时延；为了满足各种长度报文的需要并且达到高效的目的，节点需要分配不同大小的缓冲区，否则就有可能造成数据传送的失败，这样对每个节点来说缓冲区的分配也比较困难。另外一个缺点是出错时，整个报文都将重传。这种方式已经淘汰，但是对于后面应运而生的分组交换是一种启发。</p>
<p>3、分组交换<br>    分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的地址和编号信息）逐个地发送出去。采用分组交换技术，在通信之前不需要建立连接，每个节点首先将前一节点送来的分组收下并保存在缓冲区中，然后根据分组头部中的地址信息选择适当的链路将其发送至下一个节点，这样在通信过程中可以根据用户的要求和网络的能力来动态分配带宽。分组交换比电路交换的信道利用率高，但时延较大。分组转发的带来的问题：排队时延以及增加头部带来的开销。 </p>
<p>&#160; &#160; &#160; &#160;总之，若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493698933186&amp;di=3be4210907fd965f5f49758fc5c76763&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D566293858%2C4184530263%26fm%3D214%26gp%3D0.jpg" alt=""></p>
<h3 id="OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构"><a href="#OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构" class="headerlink" title="OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构"></a>OSI七层协议体系结构和各自作用及TCP／IP四层（五层）结构</h3><p>&#160; &#160; &#160; &#160;在这里首先大概介绍每层的功能，后面章节对具体每层进行分析其中相关功能和技术，如下图所示：<br><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg" alt=""></p>
<h4 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h4><p>&#160; &#160; &#160; &#160;通过传输介质发送和接收二进制比特流。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。传输介质有双绞线，同轴电缆，光缆，微波接力。采用的技术有信道复用。物理层记住两个重要的设备名称，<font color="red">中继器</font>（Repeater，也叫放大器）和<font color="red">集线器</font>。他们都用于连接物理特性相同的网段，集线器所起的作用相当于多端口的中继器，中继器一般两个端口，而集线器很多。</p>
<h4 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h4><p>&#160; &#160; &#160; &#160;数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<font color="red">有关数据链路层的三个基本问题：<br><br>&#160; &#160; &#160; &#160;1.封装成帧，在一段数据的前后分别添加首部和尾部；<br><br>&#160; &#160; &#160; &#160;2.透明传输，设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符，在这两个字符之前插入一个转义字符“ESC”;<br><br>&#160; &#160; &#160; &#160;3.错检测：循环冗余检验CRC，接受到的都是正确的，错误的都没接受所以并没有保障可靠的传输。</font>


<p>&#160; &#160; &#160; &#160;主要的协议：点对点PPP协议，对点到点信道；以太网协议，CSMA／DA协议：载波监听多点接入/冲突检测，针对广播信道，将许多计算机连接到一根总线上，局域网中的MAC地址，48位；FDDI光纤分布式数据接口。</p>
<p>&#160; &#160; &#160; &#160;两个重要设备名称：网桥和交换机。太网交换机实质上就是一个多接口的网桥。用于连接同一逻辑网络中、物理层规范不同的网段，这些网段的拓扑结构和其上的数据帧格式，都可以不同，它们具有物理地址，但没有逻辑地址。</p>
<h4 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h4><p>　　网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。</p>
<p>　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：</p>
<p>　　1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</p>
<p>　　2&gt; 基本数据单位为IP数据报；</p>
<p>　　3&gt; 包含的主要协议：</p>
<p>　　<font color="red">IP协议（Internet Protocol，因特网互联协议）;</font></p>
<p>　　ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</p>
<p>　　ARP协议（Address Resolution Protocol，地址解析协议）;</p>
<p>　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</p>
<p>　　4&gt; 重要的设备：路由器</p>
<h4 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h4><p>&#160; &#160; &#160; &#160;第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>&#160; &#160; &#160; &#160;传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。<br>&#160; &#160; &#160; &#160;网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。</p>
<p><font color="red">有关网络层的重点：</font></p>
<p>&#160; &#160; &#160; &#160;1.传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；</p>
<p>&#160; &#160; &#160; &#160;2.包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；</p>
<p>&#160; &#160; &#160; &#160;3.重要设备：网关。</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>　　为操作系统或网络应用程序提供访问网络服务的接口。</p>
<p>　　会话层、表示层和应用层重点：</p>
<p>　　1&gt; 数据传输基本单位为报文；</p>
<p>　　<font color="red">2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</font>
　　</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&#160; &#160; &#160; &#160;如下图，各层分布如下，我们在下一节中重点了解网络层ip、运输层tcp，udp和应用层的相关知识。<br>　　<br><img src="https://uploadfiles.nowcoder.com/images/20160825/537870_1472105349302_FEE2F1DA56B2D9B0ED608E700E39130D" alt=""></p>
<p>本文参考连接:<a href="http://www.cnblogs.com/maybe2030/p/4781555.html" target="_blank" rel="external">计算机网络知识总结</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络-概述（一）&quot;&gt;&lt;a href=&quot;#计算机网络-概述（一）&quot; class=&quot;headerlink&quot; title=&quot;计算机网络-概述（一）&quot;&gt;&lt;/a&gt;计算机网络-概述（一）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;非计算机专业，有过计算机网络的课程，但是理解的很浅显，最近从很多的学习过程中感觉这方面确实要加强，因为主要的学习方向是Java Web，但是却连计算机网络的知识都不扎实，确实也说不过去，希望能系统的学习一下，查阅了网上的资料，下载了相关视频，书籍和ppt，学的是《计算机网络》谢希仁版的教材，下面记录学习中的重点部分和理解。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>算法基础篇：排序（二）</title>
    <link href="http://yoursite.com/2016/12/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/06/算法基础篇：排序（二）/</id>
    <published>2016-12-06T02:07:42.000Z</published>
    <updated>2017-05-06T10:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改进排序算法及其Java实现"><a href="#改进排序算法及其Java实现" class="headerlink" title="改进排序算法及其Java实现"></a>改进排序算法及其Java实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上节讲了经典的三个排序算法，这节将对改进的排序算法进行分析，有快速排序和归并排序。对于排序和数据结构，推荐一个很棒的网站，支持能动态的看排序过程，可以单步，调节快慢：<font color="red"><a href="http://zh.visualgo.net" target="_blank" rel="external"><strong>学习利器</strong></a></font></p>
  <a id="more"></a>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&#160; &#160; &#160;&#160; 快速排序（Quicksort）是对<em>冒泡排序</em>的一种改进。</p>
<p>&#160; &#160; &#160;&#160; 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序对海量数据来说，相对其他排序方式是较快的， 他的时间复杂度比经典排序小且常系数也比较小才称为快速排序。以数组{49,38,65,97,76,13,27,49}为例，选择第一个元素49为基准,初始化关键字： [49,38,65,97,76,13,27,49]</p>
<p>&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="http://img.blog.csdn.net/20160426213936501" alt=""></p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 首先随机选择数列中的一个数（可用随机数产生，但也可以就选第一个数），然后进行一个partition函数，他的思想是扫描一遍数列把大于这个基数的数都放在右边，小于这个基数的数都放在左边。最后利用分治的思想，对基数的右边和左边分别在进行这个partition操作，最后数列就有序了。我这里为了代码尽量简洁，写出以下代码。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>//快速排序，s代表数列，l是数列第一项索引，r是数列最后一项的索引
public static void quicksort(int[] s,int l,int r){
//用i，j接住首位和末位，后面分别代表小于区间和🐠等于区间。x代表基数，这里用首位代表基数，没有随机产生
    int i=l,j=r,x=s[l];
    //执行操作条件
    if(l&lt;r){
        //循环结束条件
        while(i&lt;j){
            //从右至左找小于基数的数
            while(i&lt;j&amp;&amp;s[j]&gt;=x)
                j--;//如果大于等于基数j--，因为它们顺序正确
             //找到之后放在左边，此处精妙的使用i++
            if(i&lt;j)
                s[i++]=s[j];
            //从左至右找大于等于基数的数
            while(i&lt;j&amp;&amp;s[i]&lt;x)
                i++;
            //放在
            if(i&lt;j)
                s[j--]=s[i];
        }
        //最后把基数放在i位置上，完成了partition操作
        s[i]=x;
        //对数列左边和右边分别递归
        quicksort(s,l,i-1);
        quicksort(s,i+1,r);
    }
}
</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>&#160; &#160; &#160;&#160; 基本原理如下：对于给定的一组记录，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序，最后再用递归方法将排好序的半子表合并成为越来越大的有序序列。 经过第一轮比较后得到最小的记录，然后将该记录的位置与第一个记录的位置交换；接着对不包括第一个记录以外的其他记录进行第二次比较，得到最小记录并与第二个位置记录交换；重复该过程，直到进行比较的记录只剩下一个为止。</p>
<p>&#160; &#160; &#160;&#160;以数组{50,10,90,30,70,40,80,60,20}为例，排序过程如下图：</p>
<p><img src="http://img.blog.csdn.net/20160427172905073" alt=""></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code>public static void merge(int[] a, int low, int mid, int high) {
    int[] temp = new int[high - low + 1];
    int i = low;// 左指针
    int j = mid + 1;// 右指针
    int k = 0;
    // 把较小的数先移到新数组中
    while (i &lt;= mid &amp;&amp; j &lt;= high) {
        if (a[i] &lt; a[j]) {
            temp[k++] = a[i++];
        } else {
            temp[k++] = a[j++];
        }
    }
    // 把左边剩余的数移入数组
    while (i &lt;= mid) {
        temp[k++] = a[i++];
    }
    // 把右边边剩余的数移入数组
    while (j &lt;= high) {
        temp[k++] = a[j++];
    }
    // 把新数组中的数覆盖nums数组
    for (int k2 = 0; k2 &lt; temp.length; k2++) {
        a[k2 + low] = temp[k2];
    }
}

public static void mergeSort(int[] a, int low, int high) {
    int mid = (low + high) / 2;
    if (low &lt; high) {
        // 左边
        mergeSort(a, low, mid);
        // 右边
        mergeSort(a, mid + 1, high);
        // 左右归并
        merge(a, low, mid, high);
        System.out.println(Arrays.toString(a));
    }

}
</code></pre><p> &#160; &#160; &#160;&#160;&#160; &#160; &#160;&#160;<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493531505656&amp;di=3fcca775d3be2b21bad6ac93d3a7ade9&amp;imgtype=0&amp;src=http%3A%2F%2Fimgs.aixifan.com%2Fcontent%2F2016_09_10%2F1473520477.gif" alt=""></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改进排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#改进排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;改进排序算法及其Java实现&quot;&gt;&lt;/a&gt;改进排序算法及其Java实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上节讲了经典的三个排序算法，这节将对改进的排序算法进行分析，有快速排序和归并排序。对于排序和数据结构，推荐一个很棒的网站，支持能动态的看排序过程，可以单步，调节快慢：&lt;font color=red&gt;&lt;a href=&quot;http://zh.visualgo.net&quot;&gt;&lt;strong&gt;学习利器&lt;/strong&gt;&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="经典算法" scheme="http://yoursite.com/tags/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础篇：排序（一）</title>
    <link href="http://yoursite.com/2016/12/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/01/算法基础篇：排序（一）/</id>
    <published>2016-12-01T04:19:38.000Z</published>
    <updated>2017-05-06T10:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法及其Java实现"><a href="#基础排序算法及其Java实现" class="headerlink" title="基础排序算法及其Java实现"></a>基础排序算法及其Java实现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;看完了牛客网上的买的算法课程，准备首先从基础的<font color="red"><strong>数据结构</strong></font>和<font color="red"><strong>算法</strong></font>开始写。  </p>
<p>  &#160; &#160; &#160; &#160;本篇先从基础的排序开始，需要要掌握的有<em>冒泡排序</em>，<em>选择排序</em>和 <em>插入排序</em>。</p>
  <a id="more"></a>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>  1.<em>第一次循环</em>：从0到n-2（即0&lt;=i&lt;n-1-0），每个位置上的数拿本身和后一位相比，如果比后一位大就交换两个位置的值。</p>
<p>  2.<em>第二次循环</em>：从0到n-3即（即0&lt;=i&lt;n-1-1），操作同第一次循环一样。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：0位置上的数（即0&lt;=i&lt;n-1-(n-2)），操作同第一次循环。</p>
<p>  &#160; &#160; &#160; &#160;说明：为了实现本身和后一位相比直到最后，要用内层循环实现，范围区间已在上面给出，外层共有n-1次循环，我们可以写出代码如下。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>public static int[] BubbleSort(int[] A, int n) {

    // 给变量赋初识值
    int temp,i = 0,j = 0;
    //外层循环计数如上面算法思想的减数部分
    for(;i &lt; n-1;++i){
    //内层循环来实现相邻两个比较
        for(;j&lt;n-i-1;++j){
        //前一个比后一个大，冒泡到最后
        //说明：逆序排列的话条件相反
            if(A [j] &gt; A [j+1]){
                temp = A[j];
                A[j] = A[j+1];
                A[j+1] = temp;
            }
        }
    }
    return A;
}
</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从0到n-1（即1&lt;=i&lt;n），选出区间最小值放到位置0上。</p>
<p>  2.<em>第二次循环</em>：从1到n-1（即2&lt;=i&lt;n），选出最小值放到位置1上。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从n-2到n-1（即n-2&lt;=i&lt;n），选出最小值放在位置n-2上。</p>
<p>  &#160; &#160; &#160; &#160;说明：内层循环选取区间内的最小值，循环区间上面已给出，利用附加空间的int k来存储最小值的索引，最后和对应位置值交换，外层循环循环n-1次。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] selectSort(int[] data){
//初始化变量，需要额外的k存最小智的索引
    int i, j, k, tmp = 0;
    //外层循环，0-n-2，循环n-2次
    for (i = 0; i &lt; data.length - 1; i++) {
        //记录下区间第一个值
        k = i;
        //内层循环从区间第二个值开始比较
        for (j = i + 1; j &lt; data.length; j++)
        //更新最小值索引
            if (data[j] &lt; data[k])
                k = j;
        //如果最小值索引不是当前位置，交换他们的值
        if (k != i) {
            tmp = data[i];
            data[i] = data[k];
            data[k] = tmp;
        }
    }
    return data;
}
</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p> 1.<em>第一次循环</em>：从位置1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——1区间一定有序。</p>
<p>  2.<em>第二次循环</em>：从位置2上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——2区间一定有序。</p>
<p>  ….多次循环后….</p>
<p>  3.<em>第n-1次循环</em>：从位置n-1上的数开始，与它的前一位比较，如果比他小就交换它们的值，并从它的前一位开始继续向前比较，直接当前位置比前一个位置大，停止循环，或者直到和位置0上的数相比，比较结束，此时0——n-1区间即整个数列就有序了。</p>
<p>  &#160; &#160; &#160; &#160;说明：外层循环循环n-1次。从1到n-1，即1&lt;=i&lt;n。内层循环首先取当前索引的前一位索引，与当前索引位置的值比较，如果当前索引位置较小就交换当前索引和前一位的值，并从它的前一位开始继续向前比较。根据以上思路可以写出实现代码。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>public static int[] insertionSort(int[] A, int n) {
    // 外层循环从1——n-1，共n-1次。
    for(int i=1;i&lt;n;++i){
        //j从当前索引i前一位开始，每次比较后j递减更新当前索引位置
        for(int j=i-1;j&gt;=0;--j){
            //比较前一位和当前索引位置，如果当前位置小则交换
            if(A[j]&gt;A[j+1]){
                int temp=A[j];
                A[j]=A[j+1];
                A[j+1]=temp;
            }
            //如果当前位置大，停止内层循环
            else
                break;
        }

    }
    return A;
}
</code></pre><p>明天讲其他几种，最后试着插入一个动图！！！</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://ww2.sinaimg.cn/bmiddle/88070423gw1ep30aw8an7g204d04gkgd.gif" alt="亦菲表演机器猫"></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法及其Java实现&quot;&gt;&lt;a href=&quot;#基础排序算法及其Java实现&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法及其Java实现&quot;&gt;&lt;/a&gt;基础排序算法及其Java实现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看完了牛客网上的买的算法课程，准备首先从基础的&lt;font color=red&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/font&gt;和&lt;font color=red&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/font&gt;开始写。  &lt;/p&gt;
&lt;p&gt;  &amp;#160; &amp;#160; &amp;#160; &amp;#160;本篇先从基础的排序开始，需要要掌握的有&lt;em&gt;冒泡排序&lt;/em&gt;，&lt;em&gt;选择排序&lt;/em&gt;和 &lt;em&gt;插入排序&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="经典算法" scheme="http://yoursite.com/tags/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://yoursite.com/2016/11/27/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/11/27/hexo搭建个人博客/</id>
    <published>2016-11-27T02:14:11.000Z</published>
    <updated>2017-05-04T12:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-nodejs-markdown搭建hexo"><a href="#git-nodejs-markdown搭建hexo" class="headerlink" title="git+nodejs+markdown搭建hexo"></a>git+nodejs+markdown搭建hexo</h1><h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。<br><a id="more"></a></p>
<h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p>
<p><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">创始人 John Gruber 的 Markdown 语法说明</a></p>
<p><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 中文版语法说明</a></p>
<h3 id="Mac下的编辑器Mou和MacDown"><a href="#Mac下的编辑器Mou和MacDown" class="headerlink" title="Mac下的编辑器Mou和MacDown"></a>Mac下的编辑器Mou和MacDown</h3><p>代码高亮</p>
<p>Mou 和 MacDown 都支持 fenced code blocks（前后三个反引号可以表示代码块），但 MacDown 支持加语言标识符实现代码高亮，这对程序员来说简直是福音啊，非常棒的功能。</p>
<p>MacDown 支持代码高亮<br>MacDown 支持代码高亮<br>GFM Task List 支持</p>
<p>MacDown 支持 Task list，有了这个功能，你可以将你的 MD 编辑器立马变成 TODO list，是不是很赞？</p>
<p>MacDown 对 Task list 的支持<br>MacDown 对 Task list 的支持<br>Jekyll Front-matter 支持</p>
<p>很多人使用 Jekyll 作为博客引擎，这时 Jekyll 的前面那段该怎么去渲染呢？MacDown 和 github 一样可以支持。</p>
<p>MacDown 对 Jekyll front-matter 的支持<br>MacDown 对 Jekyll front-matter 的支持</p>
<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><p><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">参考链接</a></p>
<h2 id="nodejs-git-并安装hexo"><a href="#nodejs-git-并安装hexo" class="headerlink" title="nodejs+git 并安装hexo"></a>nodejs+git 并安装hexo</h2><h3 id="这个教程很多，下面给个链接"><a href="#这个教程很多，下面给个链接" class="headerlink" title="这个教程很多，下面给个链接"></a>这个教程很多，下面给个链接</h3><p><a href="http://www.jianshu.com/p/ecd51e8ef2fa" target="_blank" rel="external">参考链接</a></p>
<h2 id="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"><a href="#next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。" class="headerlink" title="next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。"></a>next主题安装，并个性化设置，这个真是走了很多弯路。根据官方文档一步步来。</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git-nodejs-markdown搭建hexo&quot;&gt;&lt;a href=&quot;#git-nodejs-markdown搭建hexo&quot; class=&quot;headerlink&quot; title=&quot;git+nodejs+markdown搭建hexo&quot;&gt;&lt;/a&gt;git+nodejs+markdown搭建hexo&lt;/h1&gt;&lt;h2 id=&quot;markdown语法&quot;&gt;&lt;a href=&quot;#markdown语法&quot; class=&quot;headerlink&quot; title=&quot;markdown语法&quot;&gt;&lt;/a&gt;markdown语法&lt;/h2&gt;&lt;p&gt;Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。&lt;br&gt;
    
    </summary>
    
      <category term="hexo相关" scheme="http://yoursite.com/categories/hexo%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
