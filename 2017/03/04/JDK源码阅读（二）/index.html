<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="baidu-site-verification" content="fim5UXPJUw" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JDK集合类源码," />





  <link rel="alternate" href="/atom.xml" title="Jessie_Zou’s Homepage" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="JDK源码阅读（二）前言&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。">
<meta name="keywords" content="JDK集合类源码">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK源码阅读（二）">
<meta property="og:url" content="http://yoursite.com/2017/03/04/JDK源码阅读（二）/index.html">
<meta property="og:site_name" content="Jessie_Zou’s Homepage">
<meta property="og:description" content="JDK源码阅读（二）前言&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。">
<meta property="og:image" content="http://opb7t58xj.bkt.clouddn.com/%E9%9B%86%E5%90%88%E7%B1%BB.png">
<meta property="og:image" content="http://images.cnitblog.com/blog/400827/201409/041358026259354.jpg">
<meta property="og:updated_time" content="2017-05-11T12:44:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK源码阅读（二）">
<meta name="twitter:description" content="JDK源码阅读（二）前言&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。">
<meta name="twitter:image" content="http://opb7t58xj.bkt.clouddn.com/%E9%9B%86%E5%90%88%E7%B1%BB.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/04/JDK源码阅读（二）/"/>





  <title>JDK源码阅读（二） | Jessie_Zou’s Homepage</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jessie_Zou’s Homepage</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的学习笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/04/JDK源码阅读（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jessie Zou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jessie_Zou’s Homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JDK源码阅读（二）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-04T14:46:22+08:00">
                2017-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JDK源码解析/" itemprop="url" rel="index">
                    <span itemprop="name">JDK源码解析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/04/JDK源码阅读（二）/" class="leancloud_visitors" data-flag-title="JDK源码阅读（二）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JDK源码阅读（二）"><a href="#JDK源码阅读（二）" class="headerlink" title="JDK源码阅读（二）"></a>JDK源码阅读（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。</p>
 <a id="more"></a>
<h2 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a>总体框图</h2><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E9%9B%86%E5%90%88%E7%B1%BB.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中就说明了集合类之间的一些关系，包含接口、抽象类和实现类还有继承实现的关系。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&#160; &#160; &#160; &#160;HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。现在又出现了concurrent包里面的，我们更要知道，在并发情况下更高效。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>&#160; &#160; &#160; &#160;HashMap的底层主要是基于<font color="red">数组和链表</font>来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://images.cnitblog.com/blog/400827/201409/041358026259354.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。我们看看HashMap中Entry类的代码：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">/** Entry是单向链表。    </div><div class="line">     * 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">     *它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </div><div class="line">    **/  </div><div class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">        final K key;    </div><div class="line">        V value;    </div><div class="line">        // 指向下一个节点    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        final int hash;    </div><div class="line">   </div><div class="line">        // 构造函数。    </div><div class="line">        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">            value = v;    </div><div class="line">            next = n;    </div><div class="line">            key = k;    </div><div class="line">            hash = h;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final K getKey() &#123;    </div><div class="line">            return key;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V getValue() &#123;    </div><div class="line">            return value;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V setValue(V newValue) &#123;    </div><div class="line">            V oldValue = value;    </div><div class="line">            value = newValue;    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 判断两个Entry是否相等    </div><div class="line">        // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">        // 否则，返回false    </div><div class="line">        public final boolean equals(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry e = (Map.Entry)o;    </div><div class="line">            Object k1 = getKey();    </div><div class="line">            Object k2 = e.getKey();    </div><div class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">                Object v1 = getValue();    </div><div class="line">                Object v2 = e.getValue();    </div><div class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                    return true;    </div><div class="line">            &#125;    </div><div class="line">            return false;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 实现hashCode()    </div><div class="line">        public final int hashCode() &#123;    </div><div class="line">            return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">                   (value==null ? 0 : value.hashCode());    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final String toString() &#123;    </div><div class="line">            return getKey() + &quot;=&quot; + getValue();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当从HashMap中删除元素时，绘调用recordRemoval()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">``` </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;&lt;font color=red&gt;HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。&lt;/font&gt;　</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 源码分析</div><div class="line">#### 关键属性</div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;这是hashmap一些重要属性。</div></pre></td></tr></table></figure>
<p>transient Entry[] table;//存储元素的实体数组</p>
<p>transient int size;//存放元素的个数</p>
<p>int threshold; //临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量</p>
<p> final float loadFactor; //加载因子</p>
<p>transient int modCount;//被修改的次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;其中loadFactor加载因子是表示Hsah表中元素的填满的程度.</div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）。冲突的机会越大,则查找的成本越高.</div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;因此,必须在 &quot;冲突的机会&quot;与&quot;空间利用率&quot;之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的&quot;时-空&quot;矛盾的平衡与折衷.</div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 构造方法</div></pre></td></tr></table></figure>
<p>public HashMap(int initialCapacity, float loadFactor) {<br>        //确保数字合法<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException(“Illegal initial capacity: “ +<br>                                              initialCapacity);<br>        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))<br>            throw new IllegalArgumentException(“Illegal load factor: “ +<br>                                              loadFactor);</p>
<pre><code> // Find a power of 2 &gt;= initialCapacity
 int capacity = 1;   //初始容量
 while (capacity &lt; initialCapacity)   //确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂
     capacity &lt;&lt;= 1;

 this.loadFactor = loadFactor;
 threshold = (int)(capacity * loadFactor);
 table = new Entry[capacity];
init();
</code></pre><p>   }</p>
<pre><code>public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
</code></pre><p>   }</p>
<pre><code>public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
    table = new Entry[DEFAULT_INITIAL_CAPACITY];
   init();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;我们可以看到在构造HashMap的时候如果我们指定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的。默认初始容量为16，默认加载因子为0.75。我们可以看到上面代码中13-15行，这段代码的作用是确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂，至于为什么要把容量设置为2的n次幂，我们等下再看。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">#### put</div></pre></td></tr></table></figure>
<p>public V put(K key, V value) {<br>     // 若“key为null”，则将该键值对添加到table[0]中。<br>         if (key == null)<br>            return putForNullKey(value);<br>     // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。<br>         int hash = hash(key.hashCode());<br>     //搜索指定hash值在对应table中的索引<br>         int i = indexFor(hash, table.length);<br>     // 循环遍历Entry数组,若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！<br>         for (Entry<k,v> e = table[i]; e != null; e = e.next) {<br>             Object k;<br>              if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { //如果key相同则覆盖并返回旧值<br>                  V oldValue = e.value;<br>                 e.value = value;<br>                 e.recordAccess(this);<br>                 return oldValue;<br>              }<br>         }<br>     //修改次数+1<br>         modCount++;<br>     //将key-value添加到table[i]处<br>     addEntry(hash, key, value, i);<br>     return null;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;注意：第2和3行的作用就是处理key值为null的情况,如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0].我们再回去看看put方法中第4行，它是通过key的hashCode值计算hash码,得到hash码之后就会通过hash码去计算出应该存储在数组中的索引,这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</div></pre></td></tr></table></figure></k,v></p>
<p>private V putForNullKey(V value) {<br>        for (Entry<k,v> e = table[0]; e != null; e = e.next) {<br>            if (e.key == null) {   //如果有key为null的对象存在，则覆盖掉<br>                V oldValue = e.value;<br>                e.value = value;<br>                e.recordAccess(this);<br>                return oldValue;<br>           }<br>       }<br>        modCount++;<br>        addEntry(0, null, value, 0); //如果键为null的话，则hash值为0<br>        return null;<br>    }</k,v></p>
<pre><code>//计算hash值的方法 通过键的hashCode来计算
static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}


static int indexFor(int h, int length) { //根据hash值和数组长度算出索引值
   //这里不能随便算取，用hash&amp;(length-1)是有原因的，
   //这样可以确保算出来的索引是在数组大小范围内，不会超出
     return h &amp; (length-1);  
 }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</div></pre></td></tr></table></figure>
<p> void addEntry(int hash, K key, V value, int bucketIndex) {<br>          //如果要加入的位置有值，将该位置原先的值设置为新entry的next,<br>         //也就是新entry链表的下一个节点<br>         Entry<k,v> e = table[bucketIndex];<br>         table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>         if (size++ &gt;= threshold) //如果大于临界值就扩容<br>             resize(2 * table.length); //以2的倍数扩容<br>     }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。第4行和第5行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，HashMap扩容是扩为原来的两倍。resize()如下:</div></pre></td></tr></table></figure></k,v></p>
<p>void resize(int newCapacity) {<br>        Entry[] oldTable = table;<br>        int oldCapacity = oldTable.length;<br>        if (oldCapacity == MAXIMUM_CAPACITY) {<br>            threshold = Integer.MAX_VALUE;<br>            return;<br>       }</p>
<pre><code>    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);//用来将原先table的元素全部移到newTable里面
    table = newTable;  //再将newTable赋值给table
    threshold = (int)(newCapacity * loadFactor);//重新计算临界值
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;新建了一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将HashMap的全部元素添加到新的HashMap中,并重新计算元素在新的数组中的索引位置</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小 x loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为 2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</div><div class="line"></div><div class="line">#### get</div></pre></td></tr></table></figure>
<p>public V get(Object key) {<br>    if (key == null)<br>        return getForNullKey();<br>    int hash = hash(key.hashCode());<br>    for (Entry<k,v> e = table[indexFor(hash, table.length)];<br>        e != null;<br>        e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br>            return e.value;<br>    }<br>    return null;<br>}</k,v></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&amp;#160; &amp;#160; &amp;#160; &amp;#160;有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">本文转自博文：[Java集合---HashMap源码剖析](http://www.cnblogs.com/ITtangtang/p/3948406.html)，感谢博主的总结。我们还可以从面试官的角度去想问题：参考[HashMap的工作原理](http://www.importnew.com/7099.html)。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 其他的map实现</div></pre></td></tr></table></figure>
<p>import java.util.HashMap;<br>import java.util.TreeMap;</p>
<p>/**</p>
<ul>
<li><p>Created by zoujing on 2017/3/04.<br>*/<br>public class mapDemo {</p>
<p> public static void main(String[] args) {</p>
<pre><code>hashmap();

treemap();

linkedmap();
</code></pre><p> }</p>
<p> //按key排序；<br> public static void treemap(){</p>
<pre><code>TreeMap&lt;String , Double&gt; map =  new TreeMap&lt;String , Double&gt;();
map.put(&quot;ccc&quot; , 89.0);
map.put(&quot;aaa&quot; , 80.0);
map.put(&quot;zzz&quot; , 80.0);
map.put(&quot;bbb&quot; , 89.0);
System.out.println(map);
</code></pre><p> }</p>
<p> public static void hashmap(){</p>
<pre><code>HashMap&lt;String,Double&gt; map=new HashMap&lt;&gt;();
map.put(&quot;ccc&quot; , 89.0);
map.put(&quot;aaa&quot; , 80.0);
map.put(&quot;zzz&quot; , 80.0);
map.put(&quot;bbb&quot; , 89.0);
System.out.println(map);
</code></pre><p> }</p>
<pre><code>public static void hashmap(){
 HashMap&lt;String,Double&gt; map=new HashMap&lt;&gt;();
 map.put(&quot;ccc&quot; , 89.0);
 map.put(&quot;aaa&quot; , 80.0);
 map.put(&quot;zzz&quot; , 80.0);
 map.put(&quot;bbb&quot; , 89.0);
 System.out.println(map);
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>```</p>
<p>&#160; &#160; &#160; &#160;对于LinkedHashMap，输出顺序和插入顺序一样；对于hashmap，顺序是随机的；对于treemap。当程序执行 map.put(“ccc” , 89.0); 时，系统将直接把 “ccc”-89.0 这个 Entry 放入 Map 中，这个 Entry 就是该“红黑树”的根节点。接着程序执行 map.put(“aaa” , 80.0); 时，程序会将 “aaa”-80.0 作为新节点添加到已有的红黑树中。以后每向 TreeMap 中放入一个 key-value 对，系统都需要将该 Entry 当成一个新节点，添加成已有红黑树中，通过这种方式就可保证 TreeMap 中所有 key 总是按某种规则排列。例如我们输出上面程序，将看到如下结果（所有 key 由小到大地排列）：</p>
<pre><code>{aaa=80.0, ccc=89.0, bbb=89.0, zzz=80.0}
{aaa=80.0, bbb=89.0, ccc=89.0, zzz=80.0}
{ccc=89.0, aaa=80.0, zzz=80.0, bbb=89.0}
</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>&#160; &#160; &#160; &#160;TreeMap 的实现使用了红黑树数据结构，也就是一棵自平衡的排序二叉树，这样就可以保证快速检索指定节点。对于 TreeMap 而言，它采用一种被称为“红黑树”的排序二叉树来保存 Map 中每个 Entry —— 每个 Entry 都被当成“红黑树”的一个节点对待。</p>
<p>&#160; &#160; &#160; &#160;TreeMap、TreeSet 比 HashMap、HashSet 的优势在于：TreeMap 中的所有 Entry 总是按 key 根据指定排序规则保持有序状态，TreeSet 中所有元素总是根据指定排序规则保持有序状态。但是插入性能变低。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>&#160; &#160; &#160; &#160;输出顺序按输入顺序一样，是hashmap的一个子类。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>&#160; &#160; &#160; &#160;现在使用的较少了，是hashtable的线程安全版本，且不允许插入null值，效率较低，我们后面重点介绍concurrent包里面的效率较高的map。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共同点：</p>
<p>&#160; &#160; &#160; &#160;HashMap,LinkedHashMap,TreeMap都属于Map；Map 主要用于存储键(key)值(value)对，根据键得到值，因此键不允许键重复,但允许值重复。  </p>
<p>不同点：</p>
<ol>
<li>HashMap里面存入的键值对在取出的时候是随机的,也是我们最常用的一个Map.它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。  </li>
<li>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。  </li>
<li>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现.  (应用场景：购物车等需要顺序的)<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.png" alt="Jessie Zou WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.png" alt="Jessie Zou Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JDK集合类源码/" rel="tag"># JDK集合类源码</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/06/JDK源码阅读（三）/" rel="next" title="JDK源码阅读（三）">
                <i class="fa fa-chevron-left"></i> JDK源码阅读（三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/02/JDK源码阅读（一）/" rel="prev" title="JDK源码阅读（一）">
                JDK源码阅读（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


             
     <div class="comments" id="comments">
       
            <div id="uyan_frame"></div>
       
     </div>
   
        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Jessie Zou" />
          <p class="site-author-name" itemprop="name">Jessie Zou</p>
           
              <p class="site-description motion-element" itemprop="description">学习需要系统深入，写博客需要总结思考。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wustzoujing" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2798119891/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK源码阅读（二）"><span class="nav-number">1.</span> <span class="nav-text">JDK源码阅读（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总体框图"><span class="nav-number">1.2.</span> <span class="nav-text">总体框图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">1.3.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap的数据结构"><span class="nav-number">1.3.2.</span> <span class="nav-text">HashMap的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.3.3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.3.4.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable"><span class="nav-number">1.3.5.</span> <span class="nav-text">HashTable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说明"><span class="nav-number">2.</span> <span class="nav-text">说明</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jessie Zou</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  



  

    
      
    

   
        <!-- UY BEGIN -->
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2132001"></script>
        <!-- UY END -->
    
  


  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("M7yofldRrFvn70AWv3mgUx0y-gzGzoHsz", "NUrCAtMBGo8JjxRoAqXFPm0W");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
